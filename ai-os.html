<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-OS</title>
    <link rel="stylesheet" href="ai-os.css">
    
    <!-- Pre-loaded Libraries for App Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.1/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="system-prompts.js"></script>
    <script src="system-apps-definitions.js"></script>
</head>
<body>
    <div class="desktop" id="desktop">
        <!-- Windows will be dynamically created here -->
    </div>

    <div class="status-bar">
        <div class="status-info">
            <span id="clock"></span> | Apps: <span id="app-count">0</span> | Cost: $<span id="api-cost">0.00</span> | LLM: <span id="current-provider-display">OpenRouter</span>
        </div>
        <div class="voice-controls">
            <span class="voice-status" id="voice-status">Voice Ready</span>
            <button class="voice-button" id="voice-button" title="Click or Hold to Talk">üé§</button>
        </div>
    </div>

    <!-- Voice Command Popup -->
    <div class="voice-command-popup" id="voice-command-popup"></div>

    <div class="taskbar">
        <button class="start-button" onclick="toggleStartMenu()">Start</button>
        <div class="model-toggle-container">
            <button class="model-toggle-button" id="model-toggle" onclick="toggleModelMode()">
                <span id="model-mode-text">Simple</span>
            </button>
        </div>
        <div class="app-icons" id="app-icons">
            <!-- App icons will be dynamically created here -->
        </div>
    </div>

    <div class="start-menu" id="start-menu">
        <div class="menu-section">
            <div class="menu-title">Request New App</div>
            <input type="text" class="request-input" id="app-request" placeholder="Describe the app you want (e.g., calculator, calendar, quiz app, weather app, etc.) - You can also paste screenshots with Ctrl+V">
            <div id="new-app-pasted-images" style="margin-top: 10px; display: none;">
                <div style="font-size: 12px; color: #ccc; margin-bottom: 8px;">üì∑ Pasted Images:</div>
                <div id="new-app-image-preview-container" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
            </div>
            <button class="request-button" onclick="requestApp()">Create App with AI</button>
        </div>
        
        <div class="menu-section">
            <div class="menu-title">Voice Commands</div>
            <p style="color: #ccc; font-size: 12px; margin: 0;">Click the microphone button in the top-right corner and say:</p>
            <p style="color: #ccc; font-size: 11px; margin: 5px 0 0 0;">"Create a calculator app" or "Make me a todo list"</p>
        </div>

        <div class="menu-section">
            <div class="menu-title">Apps</div>
            <div class="menu-item has-submenu" onclick="toggleAppsSubmenu()" onmouseenter="showAppsSubmenu()" onmouseleave="hideAppsSubmenuDelayed()">
                üì± All Apps
                <!-- Apps Sub-menu -->
                <div class="apps-submenu" id="apps-submenu" onmouseenter="showAppsSubmenu()" onmouseleave="hideAppsSubmenuDelayed()">
                    <div class="apps-submenu-title">All Apps</div>
                    <div id="apps-submenu-content">
                        <!-- Apps will be dynamically populated here -->
                    </div>
                </div>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-title">System</div>
            <div class="menu-item" onclick="showSettings()">‚öôÔ∏è Settings</div>
            <div class="menu-item" onclick="showAppList()">üìã App Manager</div>
            <div class="menu-item" onclick="triggerLoadApp()">üìÅ Load App</div>
            <div class="menu-item" onclick="closeAllApps()">‚ùå Close All Apps</div>
        </div>
    </div>

    <script>
        // ===== SHARED DATA REGISTRY SYSTEM WITH PERSISTENCE =====
        // Global shared data storage with LLM-optimized persistence

        console.log('Initializing shared data registry system with persistence...');
        window.sharedData = {};
        window.sharedDataMeta = {};
        window.dataSubscribers = {};
        
        // ===== PERSISTENCE MANAGER =====
        window.persistenceManager = {
            dbName: 'ai-os-storage',
            dbVersion: 1,
            db: null,
            
            // Initialize IndexedDB
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onerror = () => {
                        console.warn('IndexedDB failed, falling back to localStorage');
                        resolve(false); // Fallback to localStorage
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log('IndexedDB initialized successfully');
                        resolve(true);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create object store for persistent data
                        if (!db.objectStoreNames.contains('persistentData')) {
                            const store = db.createObjectStore('persistentData', { keyPath: 'name' });
                            store.createIndex('appId', 'config.appId', { unique: false });
                            store.createIndex('type', 'config.type', { unique: false });
                        }
                    };
                });
            },
            
            // Save data to persistence (IndexedDB primary, localStorage fallback)
            async save(name, data, config) {
                const item = {
                    name: name,
                    data: data,
                    config: config || {},
                    timestamp: Date.now(),
                    version: '1.0'
                };
                
                try {
                    if (this.db) {
                        // Try IndexedDB first
                        const transaction = this.db.transaction(['persistentData'], 'readwrite');
                        const store = transaction.objectStore('persistentData');
                        await new Promise((resolve, reject) => {
                            const request = store.put(item);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                        console.log(`Saved '${name}' to IndexedDB`);
                        return { success: true, storage: 'indexeddb' };
                    } else {
                        throw new Error('IndexedDB not available');
                    }
                } catch (error) {
                    // Fallback to localStorage
                    try {
                        const serializedItem = JSON.stringify(item);
                        const sizeInBytes = new Blob([serializedItem]).size;
                        const sizeInMB = (sizeInBytes / (1024 * 1024)).toFixed(2);
                        
                        // Check if the item is too large (warn if > 1MB, reject if > 4MB)
                        if (sizeInBytes > 4 * 1024 * 1024) {
                            throw new Error(`Data too large (${sizeInMB}MB). Cannot save to localStorage.`);
                        } else if (sizeInBytes > 1024 * 1024) {
                            console.warn(`Large data object '${name}' (${sizeInMB}MB) being saved to localStorage`);
                        }
                        
                        localStorage.setItem(`ai-os-${name}`, serializedItem);
                        console.log(`Saved '${name}' to localStorage (fallback) - Size: ${sizeInMB}MB`);
                        return { success: true, storage: 'localstorage' };
                    } catch (fallbackError) {
                        console.error(`Failed to save '${name}':`, fallbackError);
                        
                        // If it's a quota error, try to clean up old data
                        if (fallbackError.name === 'QuotaExceededError') {
                            console.warn('localStorage quota exceeded. Consider cleaning up old data.');
                            // You could implement cleanup logic here if needed
                        }
                        
                        return { success: false, error: fallbackError.message };
                    }
                }
            },
            
            // Load data from persistence
            async load(name) {
                try {
                    if (this.db) {
                        // Try IndexedDB first
                        const transaction = this.db.transaction(['persistentData'], 'readonly');
                        const store = transaction.objectStore('persistentData');
                        const item = await new Promise((resolve, reject) => {
                            const request = store.get(name);
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        if (item) {
                            console.log(`Loaded '${name}' from IndexedDB`);
                            return item;
                        }
                    }
                    
                    // Fallback to localStorage
                    const localItem = localStorage.getItem(`ai-os-${name}`);
                    if (localItem) {
                        const item = JSON.parse(localItem);
                        console.log(`Loaded '${name}' from localStorage`);
                        return item;
                    }
                    
                    return null;
                } catch (error) {
                    console.error(`Failed to load '${name}':`, error);
                    return null;
                }
            },
            
            // Load all persistent data
            async loadAll() {
                const items = [];
                
                try {
                    if (this.db) {
                        // Load from IndexedDB
                        const transaction = this.db.transaction(['persistentData'], 'readonly');
                        const store = transaction.objectStore('persistentData');
                        const allItems = await new Promise((resolve, reject) => {
                            const request = store.getAll();
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        items.push(...allItems);
                    }
                    
                    // Also check localStorage for fallback items
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('ai-os-')) {
                            try {
                                const item = JSON.parse(localStorage.getItem(key));
                                const name = key.replace('ai-os-', '');
                                // Only add if not already loaded from IndexedDB
                                if (!items.find(existing => existing.name === name)) {
                                    items.push(item);
                                }
                            } catch (error) {
                                console.warn(`Failed to parse localStorage item '${key}':`, error);
                            }
                        }
                    }
                    
                    console.log(`Loaded ${items.length} persistent items`);
                    return items;
                } catch (error) {
                    console.error('Failed to load persistent data:', error);
                    return [];
                }
            },
            
            // Delete data from persistence
            async delete(name) {
                try {
                    if (this.db) {
                        const transaction = this.db.transaction(['persistentData'], 'readwrite');
                        const store = transaction.objectStore('persistentData');
                        await new Promise((resolve, reject) => {
                            const request = store.delete(name);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                    }
                    
                    // Also remove from localStorage
                    localStorage.removeItem(`ai-os-${name}`);
                    console.log(`Deleted '${name}' from persistence`);
                    return { success: true };
                } catch (error) {
                    console.error(`Failed to delete '${name}':`, error);
                    return { success: false, error: error.message };
                }
            },
            
            // Delete all data for a specific app
            async deleteApp(appId) {
                try {
                    const deletedItems = [];
                    
                    if (this.db) {
                        const transaction = this.db.transaction(['persistentData'], 'readwrite');
                        const store = transaction.objectStore('persistentData');
                        const index = store.index('appId');
                        
                        const appItems = await new Promise((resolve, reject) => {
                            const request = index.getAll(appId);
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                        
                        for (const item of appItems) {
                            await new Promise((resolve, reject) => {
                                const deleteRequest = store.delete(item.name);
                                deleteRequest.onsuccess = () => resolve();
                                deleteRequest.onerror = () => reject(deleteRequest.error);
                            });
                            deletedItems.push(item.name);
                        }
                    }
                    
                    // Also check localStorage
                    const keysToDelete = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('ai-os-')) {
                            try {
                                const item = JSON.parse(localStorage.getItem(key));
                                if (item.config && item.config.appId === appId) {
                                    keysToDelete.push(key);
                                    deletedItems.push(item.name);
                                }
                            } catch (error) {
                                // Ignore parsing errors
                            }
                        }
                    }
                    
                    keysToDelete.forEach(key => localStorage.removeItem(key));
                    
                    console.log(`Deleted ${deletedItems.length} items for app '${appId}':`, deletedItems);
                    return { success: true, deleted: deletedItems.length, items: deletedItems };
                } catch (error) {
                    console.error(`Failed to delete app data for '${appId}':`, error);
                    return { success: false, error: error.message };
                }
            }
        };
        
        // ===== APP VERSION CONTROL SYSTEM =====
        
        // Track which apps already have version control listeners
        const appsWithVersionListeners = new Set();
        
        // Helper function to add version control event listeners
        function addVersionControlEventListeners(appId) {
            if (!window.versionManager) {
                console.error('Version manager not available for app', appId);
                return;
            }
            
            // Check if listeners already added for this app
            if (appsWithVersionListeners.has(appId)) {
                return;
            }
            
            const revertBtn = document.getElementById(`revert-btn-${appId}`);
            const saveBtn = document.getElementById(`save-btn-${appId}`);
            
            if (revertBtn) {
                revertBtn.addEventListener('click', () => {
                    if (!window.versionManager) return;
                    const history = window.versionManager.getHistory(appId);
                    if (history.length === 0) return;
                    
                    // Always show selection dialog for consistent UX, whether 1 or multiple snapshots
                    showVersionSelectionDialog(appId, history);
                });
            }
            
            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    if (!window.versionManager) return;
                    showCustomPrompt('Enter a description for this save point (optional):', 'Manual save', (description) => {
                        if (description !== null) {
                            window.versionManager.createSnapshot(appId, description || 'Manual save');
                        }
                    }, appId);
                });
            }
            
            // Mark this app as having listeners
            appsWithVersionListeners.add(appId);
        }
        
        window.versionManager = {
            snapshots: new Map(), // appId -> version history
            dirtyApps: new Set(), // Track which apps have unsaved changes
            activeSnapshots: new Map(), // appId -> currently active snapshot ID
            maxVersions: 10,      // configurable limit
            
            // Create snapshot before editing
            createSnapshot: function(appId, description = 'Auto-snapshot') {
                try {
                    const app = apps.find(a => a.id === appId);
                    if (!app) {
                        console.warn(`Cannot create snapshot: App ${appId} not found`);
                        return false;
                    }
                    
                    // Get current app state
                    const contentElement = document.getElementById(`content_${appId}`);
                    const styleElement = document.getElementById(`style-${appId}`);
                    const scriptElement = document.getElementById(`script-${appId}`);
                    
                    const snapshot = {
                        id: Date.now(),
                        timestamp: new Date().toISOString(),
                        description: description,
                        state: {
                            html: contentElement ? contentElement.innerHTML : '',
                            css: styleElement ? (styleElement.getAttribute('data-original-css') || styleElement.textContent) : '',
                            javascript: scriptElement ? scriptElement.textContent : '',
                            title: app.title,
                            icon: app.icon,
                            windowState: this.getWindowState(appId),
                            sharedData: this.captureSharedData(appId)
                        }
                    };
                    
                    // Get or create version history for this app
                    if (!this.snapshots.has(appId)) {
                        this.snapshots.set(appId, []);
                    }
                    
                    const history = this.snapshots.get(appId);
                    history.push(snapshot);
                    
                    // Limit history size
                    if (history.length > this.maxVersions) {
                        history.shift(); // Remove oldest
                    }
                    
                    console.log(`üì∏ Created snapshot for app ${appId}: ${description}`);
                    
                    // Set this as the active snapshot
                    this.activeSnapshots.set(appId, snapshot.id);
                    
                    // Mark app as clean after saving
                    this.markAppClean(appId);
                    
                    return true;
                    
                } catch (error) {
                    console.error(`Failed to create snapshot for app ${appId}:`, error);
                    return false;
                }
            },
            
            // Restore from snapshot
            restoreSnapshot: function(appId, snapshotId = null) {
                try {
                    const history = this.snapshots.get(appId);
                    if (!history || history.length === 0) {
                        console.warn(`No snapshots available for app ${appId}`);
                        return false;
                    }
                    
                    // Get the snapshot (latest if no ID specified)
                    let snapshot;
                    if (snapshotId) {
                        snapshot = history.find(s => s.id === snapshotId);
                    } else {
                        snapshot = history[history.length - 1]; // Latest
                    }
                    
                    if (!snapshot) {
                        console.warn(`Snapshot not found for app ${appId}`);
                        return false;
                    }
                    
                    // Show loading state
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #0078d4;">‚Ü∂ Reverting...</h3>
                                <p style="color: #666; margin: 0;">Restoring to: ${snapshot.description}</p>
                            </div>
                        `;
                    }
                    
                    // Restore after a brief delay for visual feedback
                    setTimeout(() => {
                        this.performRestore(appId, snapshot);
                    }, 500);
                    
                    return true;
                    
                } catch (error) {
                    console.error(`Failed to restore snapshot for app ${appId}:`, error);
                    return false;
                }
            },
            
            // Perform the actual restore
            performRestore: function(appId, snapshot) {
                try {
                    const app = apps.find(a => a.id === appId);
                    if (!app) return;
                    
                    // Restore HTML content
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = snapshot.state.html;
                    }
                    
                    // Restore CSS
                    if (snapshot.state.css) {
                        addAppCSS(snapshot.state.css, appId);
                    }
                    
                    // Restore JavaScript
                    if (snapshot.state.javascript) {
                        executeAppJavaScript(snapshot.state.javascript, appId);
                    }
                    
                    // Restore app metadata
                    updateAppTitle(appId, snapshot.state.title);
                    updateAppIcon(appId, snapshot.state.icon);
                    
                    // Restore window state
                    if (snapshot.state.windowState) {
                        this.restoreWindowState(appId, snapshot.state.windowState);
                    }
                    
                    // Restore shared data
                    if (snapshot.state.sharedData) {
                        this.restoreSharedData(appId, snapshot.state.sharedData);
                    }
                    
                    // Set this as the active snapshot
                    this.activeSnapshots.set(appId, snapshot.id);
                    
                    // Mark app as clean after restoring
                    this.markAppClean(appId);
                    
                    console.log(`‚úÖ Restored app ${appId} to snapshot: ${snapshot.description}`);
                    
                    // Show success notification
                    showCustomAlert(`App reverted to: ${snapshot.description}`, 'Revert Successful', appId);
                    
                } catch (error) {
                    console.error(`Failed to perform restore for app ${appId}:`, error);
                    showCustomAlert(`Failed to revert app: ${error.message}`, 'Revert Failed', appId);
                }
            },
            
            // Get current window state
            getWindowState: function(appId) {
                const windowElement = document.getElementById(`window_${appId}`);
                if (!windowElement) return null;
                
                return {
                    width: windowElement.style.width,
                    height: windowElement.style.height,
                    left: windowElement.style.left,
                    top: windowElement.style.top,
                    zIndex: windowElement.style.zIndex
                };
            },
            
            // Restore window state
            restoreWindowState: function(appId, windowState) {
                const windowElement = document.getElementById(`window_${appId}`);
                if (!windowElement || !windowState) return;
                
                if (windowState.width) windowElement.style.width = windowState.width;
                if (windowState.height) windowElement.style.height = windowState.height;
                if (windowState.left) windowElement.style.left = windowState.left;
                if (windowState.top) windowElement.style.top = windowState.top;
                if (windowState.zIndex) windowElement.style.zIndex = windowState.zIndex;
            },
            
            // Capture app-related shared data
            captureSharedData: function(appId) {
                const appData = {};
                const allData = window.dataRegistry.getAllData();
                
                // Find data objects associated with this app
                Object.keys(allData).forEach(key => {
                    const meta = window.dataRegistry.getDataInfo(key);
                    if (meta.config && meta.config.appId === appId) {
                        appData[key] = JSON.parse(JSON.stringify(allData[key])); // Deep copy
                    }
                });
                
                return appData;
            },
            
            // Restore app-related shared data
            restoreSharedData: function(appId, sharedData) {
                Object.keys(sharedData).forEach(key => {
                    window.dataRegistry.updateData(key, sharedData[key]);
                });
            },
            
            // Update version control UI
            updateVersionControls: function(appId) {
                const versionControls = document.getElementById(`version-controls-${appId}`);
                if (!versionControls) return;
                
                const history = this.snapshots.get(appId);
                const hasSnapshots = history && history.length > 0;
                const isDirty = this.isAppDirty(appId);
                
                // Update revert button state
                const revertBtn = versionControls.querySelector('.revert-btn');
                if (revertBtn) {
                    revertBtn.disabled = !hasSnapshots;
                    revertBtn.style.opacity = hasSnapshots ? '1' : '0.5';
                }
                
                // Update save button state
                const saveBtn = versionControls.querySelector('.save-btn');
                if (saveBtn) {
                    saveBtn.disabled = !isDirty;
                    saveBtn.style.opacity = isDirty ? '1' : '0.5';
                }
                
                // Update version indicator
                const indicator = versionControls.querySelector('.version-indicator');
                if (indicator) {
                    if (isDirty) {
                        indicator.textContent = 'Modified';
                        indicator.style.color = '#ffc107';
                    } else {
                        indicator.textContent = hasSnapshots ? `${history.length}` : 'No versions';
                        indicator.style.color = '#6c757d';
                    }
                }
            },
            
            // Check if app has unsaved changes
            isAppDirty: function(appId) {
                return this.dirtyApps.has(appId);
            },
            
            // Mark app as dirty (has unsaved changes)
            markAppDirty: function(appId) {
                this.dirtyApps.add(appId);
                this.updateVersionControls(appId);
            },
            
            // Mark app as clean (no unsaved changes)
            markAppClean: function(appId) {
                this.dirtyApps.delete(appId);
                this.updateVersionControls(appId);
            },
            
            // Get version history for an app
            getHistory: function(appId) {
                return this.snapshots.get(appId) || [];
            },
            
            // Delete a specific snapshot
            deleteSnapshot: function(appId, snapshotId) {
                const history = this.snapshots.get(appId);
                if (!history) return false;
                
                // Don't allow deletion of active snapshot
                const activeSnapshotId = this.activeSnapshots.get(appId);
                if (snapshotId === activeSnapshotId) {
                    showCustomAlert('Cannot delete the currently active snapshot.', 'Delete Failed');
                    return false;
                }
                
                // Remove the snapshot
                const updatedHistory = history.filter(snapshot => snapshot.id !== snapshotId);
                this.snapshots.set(appId, updatedHistory);
                
                console.log(`üóëÔ∏è Deleted snapshot ${snapshotId} for app ${appId}`);
                this.updateVersionControls(appId);
                return true;
            },
            
            // Clear all snapshots for an app
            clearHistory: function(appId) {
                this.snapshots.delete(appId);
                this.updateVersionControls(appId);
            }
        };
        
        // Version selection dialog for multiple snapshots
        function showVersionSelectionDialog(appId, history) {
            const modal = document.createElement('div');
            modal.className = 'custom-modal';
            
            // Position relative to app window
            const appWindow = document.getElementById(`window_${appId}`);
            if (appWindow) {
                modal.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(2px);
                `;
            } else {
                // Fallback to fixed positioning if app window not found
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
            }
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 600px;
                max-height: 70vh;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            `;
            
            const activeSnapshotId = window.versionManager.activeSnapshots.get(appId);
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 20px 0; color: #333;">Manage App Versions</h3>
                <div id="version-list" style="margin-bottom: 20px;">
                    ${history.slice().reverse().map((snapshot, index) => {
                        const isActive = snapshot.id === activeSnapshotId;
                        const isLatest = index === 0;
                        return `
                            <div class="version-item" data-snapshot-id="${snapshot.id}" style="
                                padding: 12px;
                                border: 2px solid ${isActive ? '#28a745' : '#ddd'};
                                border-radius: 4px;
                                margin-bottom: 8px;
                                cursor: pointer;
                                transition: all 0.2s;
                                background-color: ${isActive ? '#f8fff9' : 'white'};
                                position: relative;
                            " onmouseover="if(!${isActive}) this.style.backgroundColor='#f8f9fa'"
                               onmouseout="this.style.backgroundColor='${isActive ? '#f8fff9' : 'white'}'">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                    <div style="flex: 1;">
                                        <div style="font-weight: bold; color: #333;">
                                            ${snapshot.description}
                                            ${isActive ? ' <span style="color: #28a745; font-size: 12px;">(ACTIVE)</span>' : ''}
                                        </div>
                                        <div style="font-size: 12px; color: #666;">
                                            ${new Date(snapshot.timestamp).toLocaleString()}
                                            ${isLatest ? ' (Latest)' : ''}
                                        </div>
                                    </div>
                                    <button class="delete-snapshot-btn" data-snapshot-id="${snapshot.id}" style="
                                        background: #dc3545;
                                        color: white;
                                        border: none;
                                        border-radius: 3px;
                                        padding: 4px 8px;
                                        font-size: 12px;
                                        cursor: pointer;
                                        margin-left: 10px;
                                        ${isActive ? 'opacity: 0.5; cursor: not-allowed;' : ''}
                                    " ${isActive ? 'disabled' : ''} title="${isActive ? 'Cannot delete active snapshot' : 'Delete this snapshot'}">üóëÔ∏è</button>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="cancel-revert" style="
                        padding: 8px 16px;
                        border: 1px solid #ccc;
                        background: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Cancel</button>
                    <button id="confirm-revert" style="
                        padding: 8px 16px;
                        border: none;
                        background: #007bff;
                        color: white;
                        border-radius: 4px;
                        cursor: pointer;
                    " disabled>Revert to Selected</button>
                </div>
            `;
            
            modal.appendChild(dialog);
            
            // Append to app window if available, otherwise to document body
            if (appWindow) {
                appWindow.appendChild(modal);
            } else {
                document.body.appendChild(modal);
            }
            
            let selectedSnapshotId = null;
            
            // Add click handlers for version items (for selection)
            dialog.querySelectorAll('.version-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    // Don't select if clicking on delete button
                    if (e.target.classList.contains('delete-snapshot-btn')) return;
                    
                    // Remove previous selection
                    dialog.querySelectorAll('.version-item').forEach(i => {
                        const isActive = parseInt(i.dataset.snapshotId) === activeSnapshotId;
                        i.style.backgroundColor = isActive ? '#f8fff9' : 'white';
                        i.style.borderColor = isActive ? '#28a745' : '#ddd';
                    });
                    
                    // Highlight selected item
                    item.style.backgroundColor = '#e3f2fd';
                    item.style.borderColor = '#2196f3';
                    
                    selectedSnapshotId = parseInt(item.dataset.snapshotId);
                    document.getElementById('confirm-revert').disabled = false;
                });
            });
            
            // Add click handlers for delete buttons
            dialog.querySelectorAll('.delete-snapshot-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent item selection
                    const snapshotId = parseInt(btn.dataset.snapshotId);
                    
                    if (snapshotId === activeSnapshotId) {
                        showCustomAlert('Cannot delete the currently active snapshot.', 'Delete Failed');
                        return;
                    }
                    
                    showCustomConfirm('Are you sure you want to delete this snapshot? This action cannot be undone.', (confirmed) => {
                        if (confirmed) {
                            if (window.versionManager.deleteSnapshot(appId, snapshotId)) {
                                // Refresh the dialog with updated history
                                if (modal.parentNode) {
                                    modal.parentNode.removeChild(modal);
                                }
                                const updatedHistory = window.versionManager.getHistory(appId);
                                if (updatedHistory.length > 0) {
                                    showVersionSelectionDialog(appId, updatedHistory);
                                }
                            }
                        }
                    }, appId);
                });
            });
            
            // Cancel button
            document.getElementById('cancel-revert').addEventListener('click', () => {
                if (modal.parentNode) {
                    modal.parentNode.removeChild(modal);
                }
            });
            
            // Confirm button
            document.getElementById('confirm-revert').addEventListener('click', () => {
                if (selectedSnapshotId) {
                    window.versionManager.restoreSnapshot(appId, selectedSnapshotId);
                }
                if (modal.parentNode) {
                    modal.parentNode.removeChild(modal);
                }
            });
            
            // Click outside to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    if (modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                }
            });
        }
        
        // ===== CUSTOM NON-BLOCKING DIALOGS =====
        
        // Custom prompt dialog
        function showCustomPrompt(message, defaultValue = '', callback, appId = null) {
            const modal = document.createElement('div');
            modal.className = 'custom-modal';
            
            // If appId is provided, position relative to app window
            if (appId) {
                const appWindow = document.getElementById(`window_${appId}`);
                if (appWindow) {
                    modal.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                        backdrop-filter: blur(2px);
                    `;
                } else {
                    // Fallback to fixed positioning if app window not found
                    modal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                    `;
                }
            } else {
                // Default fixed positioning for system-wide dialogs
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
            }
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333;">${message}</h3>
                <input type="text" id="prompt-input" value="${defaultValue}" style="
                    width: 100%;
                    padding: 8px 12px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 14px;
                    margin-bottom: 20px;
                    box-sizing: border-box;
                ">
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="prompt-cancel" style="
                        padding: 8px 16px;
                        border: 1px solid #ccc;
                        background: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Cancel</button>
                    <button id="prompt-ok" style="
                        padding: 8px 16px;
                        border: none;
                        background: #007bff;
                        color: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">OK</button>
                </div>
            `;
            
            modal.appendChild(dialog);
            
            // Append to app window if appId provided, otherwise to document body
            if (appId) {
                const appWindow = document.getElementById(`window_${appId}`);
                if (appWindow) {
                    appWindow.appendChild(modal);
                } else {
                    document.body.appendChild(modal);
                }
            } else {
                document.body.appendChild(modal);
            }
            
            // Set flag to prevent app key handlers from interfering
            window.customDialogOpen = true;
            
            const input = document.getElementById('prompt-input');
            const cancelBtn = document.getElementById('prompt-cancel');
            const okBtn = document.getElementById('prompt-ok');
            
            // Focus and select input
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
            
            function cleanup() {
                // Remove modal from its parent (either app window or document body)
                if (modal.parentNode) {
                    modal.parentNode.removeChild(modal);
                }
                // Clear flag to re-enable app key handlers
                window.customDialogOpen = false;
            }
            
            // Cancel button
            cancelBtn.addEventListener('click', () => {
                cleanup();
                callback(null);
            });
            
            // OK button
            okBtn.addEventListener('click', () => {
                const value = input.value.trim();
                cleanup();
                callback(value || defaultValue);
            });
            
            // Enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    okBtn.click();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelBtn.click();
                }
            });
            
            // Click outside to cancel
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    cancelBtn.click();
                }
            });
        }
        
        // Custom confirm dialog
        function showCustomConfirm(message, callback, appId = null) {
            const modal = document.createElement('div');
            modal.className = 'custom-modal';
            
            // If appId is provided, position relative to app window
            if (appId) {
                const appWindow = document.getElementById(`window_${appId}`);
                if (appWindow) {
                    modal.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                        backdrop-filter: blur(2px);
                    `;
                } else {
                    // Fallback to fixed positioning if app window not found
                    modal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.5);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                    `;
                }
            } else {
                // Default fixed positioning for system-wide dialogs
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
            }
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 15px 0; color: #333;">Confirm Action</h3>
                <p style="margin: 0 0 20px 0; color: #666; line-height: 1.4;">${message}</p>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button id="confirm-cancel" style="
                        padding: 8px 16px;
                        border: 1px solid #ccc;
                        background: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Cancel</button>
                    <button id="confirm-ok" style="
                        padding: 8px 16px;
                        border: none;
                        background: #dc3545;
                        color: white;
                        border-radius: 4px;
                        cursor: pointer;
                    ">Confirm</button>
                </div>
            `;
            
            modal.appendChild(dialog);
            
            // Append to app window if appId provided, otherwise to document body
            if (appId) {
                const appWindow = document.getElementById(`window_${appId}`);
                if (appWindow) {
                    appWindow.appendChild(modal);
                } else {
                    document.body.appendChild(modal);
                }
            } else {
                document.body.appendChild(modal);
            }
            
            // Set flag to prevent app key handlers from interfering
            window.customDialogOpen = true;
            
            const cancelBtn = document.getElementById('confirm-cancel');
            const okBtn = document.getElementById('confirm-ok');
            
            function cleanup() {
                // Remove modal from its parent (either app window or document body)
                if (modal.parentNode) {
                    modal.parentNode.removeChild(modal);
                }
                // Clear flag to re-enable app key handlers
                window.customDialogOpen = false;
            }
            
            // Cancel button
            cancelBtn.addEventListener('click', () => {
                cleanup();
                callback(false);
            });
            
            // OK button
            okBtn.addEventListener('click', () => {
                cleanup();
                callback(true);
            });
            
            // Escape key
            document.addEventListener('keydown', function escapeHandler(e) {
                if (e.key === 'Escape') {
                    document.removeEventListener('keydown', escapeHandler);
                    cancelBtn.click();
                }
            });
            
            // Click outside to cancel
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    cancelBtn.click();
                }
            });
        }
        
        // ===== CUSTOM POPUP SYSTEM =====
        
        function showCustomAlert(message, title = 'Alert', appId = null) {
            const popupId = 'popup_' + Date.now();
            const isAppRelated = appId !== null;
            
            // Create popup HTML
            const popupHTML = `
                <div class="custom-popup-overlay" id="${popupId}_overlay">
                    <div class="custom-popup ${isAppRelated ? 'app-popup' : 'system-popup'}">
                        <div class="custom-popup-header">
                            <span class="custom-popup-title">${title}</span>
                            <button class="custom-popup-close" onclick="closeCustomPopup('${popupId}')">&times;</button>
                        </div>
                        <div class="custom-popup-content">
                            <p>${message}</p>
                        </div>
                        <div class="custom-popup-buttons">
                            <button class="custom-popup-btn custom-popup-btn-primary" onclick="closeCustomPopup('${popupId}')">OK</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to DOM
            document.body.insertAdjacentHTML('beforeend', popupHTML);
            
            // Position popup
            const popup = document.getElementById(popupId + '_overlay');
            if (isAppRelated && appId) {
                // Position over the app window
                const appWindow = document.getElementById(`window_${appId}`);
                if (appWindow) {
                    const rect = appWindow.getBoundingClientRect();
                    popup.style.position = 'fixed';
                    popup.style.top = rect.top + 'px';
                    popup.style.left = rect.left + 'px';
                    popup.style.width = rect.width + 'px';
                    popup.style.height = rect.height + 'px';
                    popup.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                }
            }
            
            return popupId;
        }
        
        function showCustomConfirm(message, title = 'Confirm', appId = null) {
            return new Promise((resolve) => {
                const popupId = 'popup_' + Date.now();
                const isAppRelated = appId !== null;
                
                // Create popup HTML
                const popupHTML = `
                    <div class="custom-popup-overlay" id="${popupId}_overlay">
                        <div class="custom-popup ${isAppRelated ? 'app-popup' : 'system-popup'}">
                            <div class="custom-popup-header">
                                <span class="custom-popup-title">${title}</span>
                                <button class="custom-popup-close" onclick="resolveCustomConfirm('${popupId}', false)">&times;</button>
                            </div>
                            <div class="custom-popup-content">
                                <p>${message}</p>
                            </div>
                            <div class="custom-popup-buttons">
                                <button class="custom-popup-btn custom-popup-btn-secondary" onclick="resolveCustomConfirm('${popupId}', false)">Cancel</button>
                                <button class="custom-popup-btn custom-popup-btn-primary" onclick="resolveCustomConfirm('${popupId}', true)">OK</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add to DOM
                document.body.insertAdjacentHTML('beforeend', popupHTML);
                
                // Position popup
                const popup = document.getElementById(popupId + '_overlay');
                if (isAppRelated && appId) {
                    // Position over the app window
                    const appWindow = document.getElementById(`window_${appId}`);
                    if (appWindow) {
                        const rect = appWindow.getBoundingClientRect();
                        popup.style.position = 'fixed';
                        popup.style.top = rect.top + 'px';
                        popup.style.left = rect.left + 'px';
                        popup.style.width = rect.width + 'px';
                        popup.style.height = rect.height + 'px';
                        popup.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                    }
                }
                
                // Store resolver
                window[`confirmResolver_${popupId}`] = resolve;
            });
        }
        
        function closeCustomPopup(popupId) {
            const popup = document.getElementById(popupId + '_overlay');
            if (popup) {
                popup.remove();
            }
        }
        
        function resolveCustomConfirm(popupId, result) {
            const resolver = window[`confirmResolver_${popupId}`];
            if (resolver) {
                resolver(result);
                delete window[`confirmResolver_${popupId}`];
            }
            closeCustomPopup(popupId);
        }

        // Create the enhanced dataRegistry API object
        window.dataRegistry = {
            // Get specific data object
            getData: function(name) {
                return window.sharedData[name];
            },
            
            // Get all registered data objects
            getAllData: function() {
                return { ...window.sharedData };
            },
            
            // Get data object information (description, structure)
            getDataInfo: function(name) {
                return window.sharedDataMeta[name] || {};
            },
            
            // ===== LLM-OPTIMIZED PERSISTENCE API =====
            
            // Unified register method with explicit options
            register: function(name, data, options = {}) {
                const config = {
                    persistent: options.persistent || false,
                    type: options.type || 'data',           // 'app' or 'data'
                    appId: options.appId || null,           // explicit app association
                    description: options.description || '',
                    savePrompt: options.savePrompt !== false // default true for apps
                };
                
                // Store in memory
                window.sharedData[name] = data;
                window.sharedDataMeta[name] = {
                    description: config.description,
                    structure: this.analyzeDataStructure(data),
                    registeredAt: new Date().toISOString(),
                    config: config
                };
                
                console.log(`Data object '${name}' registered:`, config.description);
                
                // Handle persistence
                let saveResult = { success: true, saved: false };
                if (config.persistent) {
                    if (config.type === 'app' && config.savePrompt) {
                        // Show save dialog for apps and get result
                        const userConfirmed = this.showSaveDialogSync(name, data, config);
                        saveResult.saved = userConfirmed;
                        if (!userConfirmed) {
                            console.log(`User cancelled saving '${name}'`);
                        }
                    } else {
                        // Auto-save for data objects
                        this.saveToPersistence(name, data, config);
                        saveResult.saved = true;
                    }
                }
                
                // Notify subscribers
                this.notifySubscribers(name, data, 'registered');
                
                return { success: true, name: name, config: config, saved: saveResult.saved };
            },
            
            // LLM-friendly helper: Register app with save dialog
            registerApp: function(appId, appData, options = {}) {
                return this.register(`${appId}_app`, appData, {
                    persistent: true,
                    type: 'app',
                    appId: appId,
                    description: options.description || `${appId} application`,
                    savePrompt: options.savePrompt !== false,
                    ...options
                });
            },
            
            // LLM-friendly helper: Register app data (auto-save)
            registerAppData: function(appId, dataName, data, options = {}) {
                return this.register(`${appId}_${dataName}`, data, {
                    persistent: options.persistent !== false, // default true
                    type: 'data',
                    appId: appId,
                    description: options.description || `${appId} ${dataName}`,
                    savePrompt: false, // never prompt for data
                    ...options
                });
            },
            
            // Show save dialog for apps
            showSaveDialog: async function(name, data, config) {
                const appName = config.appId || name;
                const confirmed = await showCustomConfirm(`Save changes to ${appName}?`, 'Save Changes');
                
                if (confirmed) {
                    this.saveToPersistence(name, data, config);
                } else {
                    console.log(`User skipped saving '${name}'`);
                }
            },
            
            // Synchronous save dialog that returns user choice
            showSaveDialogSync: async function(name, data, config) {
                const appName = config.appId || name;
                const confirmed = await showCustomConfirm(`Save changes to ${appName}?`, 'Save Changes');
                
                if (confirmed) {
                    this.saveToPersistence(name, data, config);
                    return true;
                } else {
                    console.log(`User skipped saving '${name}'`);
                    return false;
                }
            },
            
            // Save to persistence
            saveToPersistence: async function(name, data, config) {
                try {
                    const result = await window.persistenceManager.save(name, data, config);
                    if (result.success) {
                        console.log(`Successfully saved '${name}' to ${result.storage}`);
                        
                        // Update metadata to indicate persistence
                        if (window.sharedDataMeta[name]) {
                            window.sharedDataMeta[name].persistent = true;
                            window.sharedDataMeta[name].lastSaved = new Date().toISOString();
                        }
                    } else {
                        console.error(`Failed to save '${name}':`, result.error);
                    }
                    return result;
                } catch (error) {
                    console.error(`Error saving '${name}':`, error);
                    return { success: false, error: error.message };
                }
            },
            
            // Load from persistence
            loadFromPersistence: async function(name) {
                try {
                    const item = await window.persistenceManager.load(name);
                    if (item) {
                        // Restore to memory
                        window.sharedData[name] = item.data;
                        window.sharedDataMeta[name] = {
                            description: item.config.description || 'Restored from persistence',
                            structure: this.analyzeDataStructure(item.data),
                            registeredAt: new Date(item.timestamp).toISOString(),
                            config: item.config,
                            persistent: true,
                            lastLoaded: new Date().toISOString()
                        };
                        
                        console.log(`Restored '${name}' from persistence`);
                        this.notifySubscribers(name, item.data, 'restored');
                        return item.data;
                    }
                    return null;
                } catch (error) {
                    console.error(`Error loading '${name}':`, error);
                    return null;
                }
            },
            
            // Load all persistent data on startup
            loadAllPersistent: async function() {
                try {
                    const items = await window.persistenceManager.loadAll();
                    let loadedCount = 0;
                    
                    for (const item of items) {
                        // Restore to memory
                        window.sharedData[item.name] = item.data;
                        window.sharedDataMeta[item.name] = {
                            description: item.config.description || 'Restored from persistence',
                            structure: this.analyzeDataStructure(item.data),
                            registeredAt: new Date(item.timestamp).toISOString(),
                            config: item.config,
                            persistent: true,
                            lastLoaded: new Date().toISOString()
                        };
                        
                        this.notifySubscribers(item.name, item.data, 'restored');
                        loadedCount++;
                    }
                    
                    console.log(`Restored ${loadedCount} persistent data objects`);
                    return { success: true, loaded: loadedCount, items: items };
                } catch (error) {
                    console.error('Error loading persistent data:', error);
                    return { success: false, error: error.message };
                }
            },
            
            // Delete app and all its data
            deleteApp: async function(appId) {
                try {
                    // Delete from persistence
                    const persistResult = await window.persistenceManager.deleteApp(appId);
                    
                    // Delete from memory
                    const memoryKeys = Object.keys(window.sharedData).filter(key => {
                        const meta = window.sharedDataMeta[key];
                        return meta && meta.config && meta.config.appId === appId;
                    });
                    
                    memoryKeys.forEach(key => {
                        delete window.sharedData[key];
                        delete window.sharedDataMeta[key];
                        this.notifySubscribers(key, null, 'deleted');
                    });
                    
                    console.log(`Deleted app '${appId}' and ${memoryKeys.length} associated data objects`);
                    return {
                        success: true,
                        deletedFromPersistence: persistResult.deleted || 0,
                        deletedFromMemory: memoryKeys.length,
                        totalDeleted: (persistResult.deleted || 0) + memoryKeys.length
                    };
                } catch (error) {
                    console.error(`Error deleting app '${appId}':`, error);
                    return { success: false, error: error.message };
                }
            },
            
            // Delete individual data object
            deleteData: function(name) {
                try {
                    // Check if data exists
                    if (!window.sharedData.hasOwnProperty(name)) {
                        return { success: false, error: `Data object '${name}' not found` };
                    }
                    
                    const meta = window.sharedDataMeta[name];
                    let deletedFromPersistence = 0;
                    
                    // Delete from persistence if it's a persistent object
                    if (meta && meta.config && meta.config.persistent) {
                        try {
                            window.persistenceManager.delete(name);
                            deletedFromPersistence = 1;
                            console.log(`Deleted '${name}' from persistence`);
                        } catch (error) {
                            console.warn(`Failed to delete '${name}' from persistence:`, error);
                        }
                    }
                    
                    // Delete from memory
                    delete window.sharedData[name];
                    delete window.sharedDataMeta[name];
                    
                    // Notify subscribers
                    this.notifySubscribers(name, null, 'deleted');
                    
                    console.log(`Deleted data object '${name}'`);
                    return {
                        success: true,
                        deletedFromPersistence: deletedFromPersistence,
                        deletedFromMemory: 1,
                        totalDeleted: deletedFromPersistence + 1
                    };
                } catch (error) {
                    console.error(`Error deleting data object '${name}':`, error);
                    return { success: false, error: error.message };
                }
            },
            
            // ===== BACKWARD COMPATIBILITY =====
            
            // Register new data object (legacy method - now with persistence support)
            registerData: function(name, data, description, structure) {
                // Use the new register method with persistence enabled by default
                return this.register(name, data, {
                    persistent: true,
                    description: description || 'No description provided',
                    structure: structure || this.analyzeDataStructure(data),
                    type: 'data'
                });
            },
            
            // Update existing data object
            updateData: function(name, newData) {
                if (window.sharedData.hasOwnProperty(name)) {
                    window.sharedData[name] = newData;
                    console.log(`Data object '${name}' updated`);
                    
                    // If this is a persistent object, save it
                    const meta = window.sharedDataMeta[name];
                    if (meta && meta.config && meta.config.persistent) {
                        this.saveToPersistence(name, newData, meta.config);
                    }
                    
                    // Notify subscribers of data change
                    this.notifySubscribers(name, newData, 'updated');
                } else {
                    console.warn(`Data object '${name}' not found for update`);
                }
            },
            
            // Subscribe to data changes
            subscribe: function(name, callback) {
                if (!window.dataSubscribers[name]) {
                    window.dataSubscribers[name] = [];
                }
                window.dataSubscribers[name].push(callback);
                console.log(`Subscribed to data object '${name}'`);
            },
            
            // Unsubscribe from data changes
            unsubscribe: function(name, callback) {
                if (window.dataSubscribers[name]) {
                    const index = window.dataSubscribers[name].indexOf(callback);
                    if (index > -1) {
                        window.dataSubscribers[name].splice(index, 1);
                        console.log(`Unsubscribed from data object '${name}'`);
                    }
                }
            },
            
            // Notify subscribers of data changes
            notifySubscribers: function(name, data, action) {
                if (window.dataSubscribers[name]) {
                    window.dataSubscribers[name].forEach(callback => {
                        try {
                            callback(data, action, name);
                        } catch (error) {
                            console.error(`Error in data subscriber for '${name}':`, error);
                        }
                    });
                }
                
                // Also dispatch global event for backward compatibility
                const event = new CustomEvent('sharedDataChanged', {
                    detail: { name: name, value: data, action: action }
                });
                document.dispatchEvent(event);
            },
            
            // Analyze data structure for metadata
            analyzeDataStructure: function(data) {
                return analyzeDataStructure(data);
            }
        };
        
        // Function to analyze data structure automatically
        function analyzeDataStructure(data) {
            if (data === null) return 'null';
            if (data === undefined) return 'undefined';
            
            const type = typeof data;
            
            if (type === 'boolean') {
                return `Boolean: ${data}`;
            }
            
            if (type === 'number') {
                return `Number: ${data}`;
            }
            
            if (type === 'string') {
                if (data.length > 50) {
                    return `String (${data.length} chars): "${data.substring(0, 47)}..."`;
                }
                return `String: "${data}"`;
            }
            
            if (type === 'function') {
                return 'Function';
            }
            
            if (Array.isArray(data)) {
                if (data.length === 0) {
                    return 'Array: [] (empty)';
                }
                
                const firstItem = data[0];
                const itemType = typeof firstItem;
                
                if (itemType === 'object' && firstItem !== null) {
                    const keys = Object.keys(firstItem).slice(0, 3);
                    const keyStr = keys.length > 3 ? `${keys.join(', ')}, ...` : keys.join(', ');
                    return `Array[${data.length}] of objects: [{${keyStr}}]`;
                } else {
                    return `Array[${data.length}] of ${itemType}s: [${firstItem}, ...]`;
                }
            }
            
            if (type === 'object') {
                // Check for special objects
                if (data instanceof Date) {
                    return `Date: ${data.toISOString()}`;
                }
                
                if (data instanceof RegExp) {
                    return `RegExp: ${data.toString()}`;
                }
                
                // Check for Web Storage API
                if (data && typeof data.getItem === 'function' && typeof data.setItem === 'function') {
                    return 'Web Storage API: {getItem(), setItem(), removeItem(), clear(), length, key()}';
                }
                
                // Regular object
                const keys = Object.keys(data);
                if (keys.length === 0) {
                    return 'Object: {} (empty)';
                }
                
                const keyStr = keys.length > 5 ? `${keys.slice(0, 5).join(', ')}, ...` : keys.join(', ');
                return `Object: {${keyStr}}`;
            }
            
            return `${type}`;
        }
        
        // Legacy functions for backward compatibility
        function getSharedData(name) {
            return window.dataRegistry.getData(name);
        }
        
        function setSharedData(name, value) {
            window.dataRegistry.updateData(name, value);
        }
        
        function registerSharedData(name, data, description, structure) {
            window.dataRegistry.registerData(name, data, description, structure);
        }
        
        // Initialize with default data
        registerSharedData('user-preferences', {theme: 'light', language: 'en'}, 'User interface preferences and settings', 'Object: {theme: string ("light"|"dark"), language: string (ISO code like "en", "de")}');
        
        // Initialize cost tracking data (will be updated when cost tracking is loaded)
        registerSharedData('cost-history', [], 'API usage cost tracking history for monitoring expenses', 'Array of objects: [{timestamp: string (ISO date), cost: number (decimal), description: string, prompt: string (truncated to 200 chars)}]');
        registerSharedData('cost-tracking-enabled', true, 'Boolean flag controlling whether API costs are tracked', 'Boolean: true (tracking enabled) | false (tracking disabled)');
        
        // Initialize apps management data
        registerSharedData('running-apps', [], 'Registry of all currently running applications with their metadata', 'Array of objects: [{id: string, title: string, icon: string (emoji), type: string, isMinimized: boolean, isMaximized: boolean, isHidden: boolean, isSystemApp: boolean, generationMode: string, timestamp: string (ISO date)}]');
        
        // Initialize system data
        registerSharedData('system-info', {
            os: 'AI-OS',
            version: '1.0.0',
            startTime: new Date().toISOString(),
            totalAppsCreated: 0
        }, 'System information, version details, and runtime statistics', 'Object: {os: string ("AI-OS"), version: string (semver), startTime: string (ISO date), totalAppsCreated: number (counter)}');
        
        // Initialize storage references (non-persistent to avoid quota issues)
        window.dataRegistry.register('localStorage', localStorage, {
            persistent: false,
            description: 'Browser local storage for persistent data across sessions',
            structure: 'Web Storage API object: {getItem(key): string|null, setItem(key, value): void, removeItem(key): void, clear(): void, length: number, key(index): string|null}',
            type: 'data'
        });
        window.dataRegistry.register('sessionStorage', sessionStorage, {
            persistent: false,
            description: 'Browser session storage for temporary data within current session',
            structure: 'Web Storage API object: {getItem(key): string|null, setItem(key, value): void, removeItem(key): void, clear(): void, length: number, key(index): string|null}',
            type: 'data'
        });
        

        // Function to update the shared apps registry
        function updateSharedAppsRegistry() {
            if (typeof setSharedData === 'function') {
                // Create a sanitized version of apps for sharing (remove sensitive data)
                const sharedApps = apps.map(app => ({
                    id: app.id,
                    title: app.title,
                    icon: app.icon,
                    type: app.type,
                    isMinimized: app.isMinimized,
                    isMaximized: app.isMaximized,
                    isHidden: app.isHidden,
                    isSystemApp: app.isSystemApp || false,
                    generationMode: app.generationMode,
                    timestamp: app.timestamp || new Date().toISOString()
                }));
                setSharedData('running-apps', sharedApps);
            }
        }



        // Global app management system
        let apps = [];
        let nextAppId = 1;
        let activeWindow = null;
        let dragData = null;
        let resizeData = null;

        // Global key event listener that only forwards events to the active app
        function handleGlobalKeyEvent(event) {
            // Don't forward key events to apps when a custom dialog is open
            if (window.customDialogOpen) {
                return;
            }
            
            // Only forward key events to the currently active/focused app
            if (activeWindow && window.appKeyHandlers && window.appKeyHandlers[activeWindow]) {
                const handlers = window.appKeyHandlers[activeWindow][event.type];
                if (handlers && handlers.length > 0) {
                    // Call all registered handlers for this event type
                    handlers.forEach(handler => {
                        try {
                            handler(event);
                        } catch (error) {
                            console.error(`Error in key handler for app ${activeWindow}:`, error);
                        }
                    });
                }
            }
        }
        
        // Clean up key handlers when an app is closed
        function cleanupAppKeyHandlers(appId) {
            if (window.appKeyHandlers && window.appKeyHandlers[appId]) {
                delete window.appKeyHandlers[appId];
            }
        }

        // Initialize the system
        async function init() {
            updateClock();
            setInterval(updateClock, 1000);
            updateAppCount();
            
            // Initialize persistence system
            console.log('Initializing persistence system...');
            try {
                await window.persistenceManager.init();
                console.log('Persistence system initialized');
                
                // Load all persistent data
                const loadResult = await window.dataRegistry.loadAllPersistent();
                if (loadResult.success) {
                    console.log(`Loaded ${loadResult.loaded} persistent items on startup`);
                    
                    // Populate start menu with persistent apps
                    updateAppsSubmenu();
                } else {
                    console.warn('Failed to load persistent data:', loadResult.error);
                }
            } catch (error) {
                console.error('Failed to initialize persistence system:', error);
            }
            
            // Load and apply saved settings on startup BEFORE voice initialization
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                applySettingsToSystem(savedSettings);
                console.log('Loaded settings from cookie on startup');
            } else {
                // No settings found - start setup assistant
                console.log('No settings found, starting setup assistant');
                setTimeout(() => startSetupAssistant(), 500);
            }
            
            // Close start menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.start-menu') && !e.target.closest('.start-button')) {
                    document.getElementById('start-menu').classList.remove('show');
                }
            });
            
            // Initialize new app request image pasting functionality
            initializeNewAppImagePasting();
            
            // Initialize global key event management system
            window.appKeyHandlers = {};
            window.customDialogOpen = false;
            
            // Register global key event listeners
            document.addEventListener('keydown', handleGlobalKeyEvent);
            document.addEventListener('keyup', handleGlobalKeyEvent);
            document.addEventListener('keypress', handleGlobalKeyEvent);
        }

        // Global variable to store pasted images for new app requests
        let newAppPastedImages = [];

        function initializeNewAppImagePasting() {
            const appRequestInput = document.getElementById('app-request');
            if (!appRequestInput) return;

            // Add paste event listener for image support
            appRequestInput.addEventListener('paste', async (e) => {
                const items = e.clipboardData.items;
                
                for (let item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        e.preventDefault();
                        
                        const file = item.getAsFile();
                        if (file) {
                            try {
                                // Convert image to base64
                                const base64 = await fileToBase64NewApp(file);
                                
                                // Add to pasted images array
                                const imageData = {
                                    base64: base64,
                                    type: file.type,
                                    name: `new-app-image-${Date.now()}.${file.type.split('/')[1]}`
                                };
                                newAppPastedImages.push(imageData);
                                
                                // Show image preview
                                showNewAppImagePreview(imageData, newAppPastedImages.length - 1);
                                
                                // Show the pasted images container
                                const pastedImagesContainer = document.getElementById('new-app-pasted-images');
                                if (pastedImagesContainer) {
                                    pastedImagesContainer.style.display = 'block';
                                }
                                
                                console.log('Image pasted successfully for new app:', imageData.name);
                            } catch (error) {
                                console.error('Error processing pasted image for new app:', error);
                                showCustomAlert('Error processing pasted image. Please try again.', 'Error');
                            }
                        }
                    }
                }
            });

            // Helper function to convert file to base64 for new app
            function fileToBase64NewApp(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            // Helper function to show image preview for new app
            function showNewAppImagePreview(imageData, index) {
                const container = document.getElementById('new-app-image-preview-container');
                if (!container) return;

                const previewDiv = document.createElement('div');
                previewDiv.style.cssText = `
                    position: relative;
                    display: inline-block;
                    border: 1px solid #666;
                    border-radius: 4px;
                    overflow: hidden;
                `;

                const img = document.createElement('img');
                img.src = imageData.base64;
                img.style.cssText = `
                    width: 60px;
                    height: 60px;
                    object-fit: cover;
                    display: block;
                `;

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '√ó';
                removeBtn.style.cssText = `
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    width: 16px;
                    height: 16px;
                    background: rgba(220, 53, 69, 0.8);
                    color: white;
                    border: none;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 10px;
                    line-height: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                removeBtn.addEventListener('click', () => {
                    // Remove from array
                    newAppPastedImages.splice(index, 1);
                    // Remove preview
                    previewDiv.remove();
                    // Hide container if no images left
                    if (newAppPastedImages.length === 0) {
                        const pastedImagesContainer = document.getElementById('new-app-pasted-images');
                        if (pastedImagesContainer) {
                            pastedImagesContainer.style.display = 'none';
                        }
                    }
                    // Update indices for remaining images
                    updateNewAppImageIndices();
                });

                previewDiv.appendChild(img);
                previewDiv.appendChild(removeBtn);
                container.appendChild(previewDiv);
            }

            // Helper function to update image indices after removal
            function updateNewAppImageIndices() {
                const container = document.getElementById('new-app-image-preview-container');
                if (!container) return;
                
                const previews = container.children;
                for (let i = 0; i < previews.length; i++) {
                    const removeBtn = previews[i].querySelector('button');
                    if (removeBtn) {
                        removeBtn.onclick = () => {
                            newAppPastedImages.splice(i, 1);
                            previews[i].remove();
                            if (newAppPastedImages.length === 0) {
                                document.getElementById('new-app-pasted-images').style.display = 'none';
                            }
                            updateNewAppImageIndices();
                        };
                    }
                }
            }
        }

        function updateClock() {
            const now = new Date();
            const clockElement = document.getElementById('clock');
            
            // Get clock format preference from settings
            const clockFormatSelect = document.getElementById('clock-format');
            const clockFormat = clockFormatSelect ? clockFormatSelect.value : '24';
            
            let timeString;
            if (clockFormat === '12') {
                // 12-hour format with AM/PM
                timeString = now.toLocaleTimeString('en-US', {
                    hour12: true,
                    hour: 'numeric',
                    minute: '2-digit',
                    second: '2-digit'
                });
            } else {
                // 24-hour format
                timeString = now.toLocaleTimeString('en-GB', {
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }
            
            if (clockElement) {
                clockElement.textContent = timeString;
            }
        }

        function updateAppCount() {
            document.getElementById('app-count').textContent = apps.length;
        }

        function updateProviderDisplay() {
            const providerElement = document.getElementById('current-provider-display');
            if (providerElement) {
                // Capitalize the provider name for display
                const displayName = CONFIG.CURRENT_LLM_PROVIDER.charAt(0).toUpperCase() + CONFIG.CURRENT_LLM_PROVIDER.slice(1);
                
                // Add current model in brackets
                const currentModel = CONFIG.MODEL || 'Unknown';
                providerElement.textContent = `${displayName} (${currentModel})`;
            }
        }

        function toggleStartMenu() {
            const menu = document.getElementById('start-menu');
            menu.classList.toggle('show');
        }

        function toggleModelMode() {
            const toggleButton = document.getElementById('model-toggle');
            const modeText = document.getElementById('model-mode-text');
            
            if (currentModelMode === 'Simple') {
                // Switch to Tough mode
                currentModelMode = 'Tough';
                CONFIG.MODEL = CONFIG.MODEL_TOUGH;
                modeText.textContent = 'Tough';
                toggleButton.classList.add('tough-mode');
            } else {
                // Switch to Simple mode
                currentModelMode = 'Simple';
                CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                modeText.textContent = 'Simple';
                toggleButton.classList.remove('tough-mode');
            }
            
            console.log(`Model mode switched to: ${currentModelMode} (${CONFIG.MODEL})`);
            
            // Update provider display to show new model
            updateProviderDisplay();
        }

        function generateAppId() {
            // Generate a unique ID using timestamp + random characters
            // This ensures uniqueness even after page reloads
            const timestamp = Date.now().toString(36); // Base36 timestamp (shorter)
            const randomPart = Math.random().toString(36).substr(2, 4); // 4 random chars
            return `app_${timestamp}${randomPart}`;
        }

        function validateAppNamespace(html, css, javascript, appId) {
            const issues = [];
            
            // Check HTML for proper ID prefixing
            const htmlIdMatches = html.match(/id=['"]([^'"]+)['"]/g) || [];
            htmlIdMatches.forEach(match => {
                const id = match.match(/id=['"]([^'"]+)['"]/)[1];
                if (!id.startsWith(`${appId}_`)) {
                    issues.push(`HTML ID "${id}" should be prefixed with "${appId}_"`);
                }
            });
            
            // Check HTML for proper class prefixing
            const htmlClassMatches = html.match(/class=['"]([^'"]+)['"]/g) || [];
            htmlClassMatches.forEach(match => {
                const classes = match.match(/class=['"]([^'"]+)['"]/)[1].split(' ');
                classes.forEach(className => {
                    if (className.trim() && !className.startsWith(`${appId}__`) && !className.startsWith('app-')) {
                        issues.push(`HTML class "${className}" should be prefixed with "${appId}__"`);
                    }
                });
            });
            
            // Check CSS for proper scoping
            if (css && !css.includes(`#content_${appId}`)) {
                issues.push('CSS should be scoped to the app container');
            }
            
            // Check JavaScript for namespace usage
            if (javascript && !javascript.includes('appId')) {
                issues.push('JavaScript should use the provided appId parameter for namespacing');
            }
            
            if (issues.length > 0) {
                console.warn(`Namespace validation issues for app ${appId}:`, issues);
                return { valid: false, issues };
            }
            
            return { valid: true, issues: [] };
        }

        function createAppHelperFunctions(appId) {
            return `
// App Helper Functions for ${appId}
const app = {
    id: '${appId}',
    
    // Get element by app-scoped ID (without prefix)
    getElementById: (id) => document.getElementById('${appId}_' + id),
    
    // Query within app container
    querySelector: (selector) => document.querySelector('#content_${appId} ' + selector),
    querySelectorAll: (selector) => document.querySelectorAll('#content_${appId} ' + selector),
    
    // App-scoped event system
    emit: (eventName, detail) => {
        document.dispatchEvent(new CustomEvent('${appId}:' + eventName, { detail }));
    },
    
    on: (eventName, handler) => {
        document.addEventListener('${appId}:' + eventName, handler);
    },
    
    off: (eventName, handler) => {
        document.removeEventListener('${appId}:' + eventName, handler);
    },
    
    // App data storage
    data: window['${appId}_data'] || (window['${appId}_data'] = {}),
    
    // Key event handling (only receives events when app has focus)
    onKey: (eventType, handler) => {
        if (!window.appKeyHandlers) window.appKeyHandlers = {};
        if (!window.appKeyHandlers['${appId}']) window.appKeyHandlers['${appId}'] = {};
        if (!window.appKeyHandlers['${appId}'][eventType]) window.appKeyHandlers['${appId}'][eventType] = [];
        window.appKeyHandlers['${appId}'][eventType].push(handler);
    },
    
    // Remove key event handler
    offKey: (eventType, handler) => {
        if (window.appKeyHandlers && window.appKeyHandlers['${appId}'] && window.appKeyHandlers['${appId}'][eventType]) {
            const index = window.appKeyHandlers['${appId}'][eventType].indexOf(handler);
            if (index > -1) {
                window.appKeyHandlers['${appId}'][eventType].splice(index, 1);
            }
        }
    },
    
    // Utility functions
    addClass: (elementId, className) => {
        const el = app.getElementById(elementId);
        if (el) el.classList.add('${appId}__' + className);
    },
    
    removeClass: (elementId, className) => {
        const el = app.getElementById(elementId);
        if (el) el.classList.remove('${appId}__' + className);
    }
};
            `;
        }

        // Debug function to test namespace isolation
        function testNamespaceIsolation() {
            console.log('üß™ Testing Namespace Isolation System...');
            
            // Test 1: Check if apps have unique IDs
            const appIds = apps.map(app => app.id);
            const uniqueIds = [...new Set(appIds)];
            console.log(`‚úÖ App ID Uniqueness: ${appIds.length === uniqueIds.length ? 'PASS' : 'FAIL'}`);
            
            // Test 2: Check if namespaces exist
            let namespaceCount = 0;
            apps.forEach(app => {
                const namespace = `app_${app.id.replace(/-/g, '_')}`;
                if (window[namespace]) {
                    namespaceCount++;
                }
            });
            console.log(`‚úÖ Namespace Creation: ${namespaceCount}/${apps.length} apps have namespaces`);
            
            // Test 3: Check CSS isolation
            const styleElements = document.querySelectorAll('[id^="style-app_"]');
            console.log(`‚úÖ CSS Isolation: ${styleElements.length} app-specific stylesheets found`);
            
            // Test 4: Check JavaScript isolation
            const scriptElements = document.querySelectorAll('[id^="script-app_"]');
            console.log(`‚úÖ JavaScript Isolation: ${scriptElements.length} app-specific scripts found`);
            
            // Test 5: Check container isolation
            const containers = document.querySelectorAll('[id^="content_app_"]');
            console.log(`‚úÖ Container Isolation: ${containers.length} app containers found`);
            
            console.log('üß™ Namespace Isolation Test Complete');
            
            return {
                uniqueIds: appIds.length === uniqueIds.length,
                namespaces: namespaceCount,
                cssIsolation: styleElements.length,
                jsIsolation: scriptElements.length,
                containers: containers.length
            };
        }

        // Make test function globally available for debugging
        window.testNamespaceIsolation = testNamespaceIsolation;

        function createWindow(appId, title, content, width = 400, height = 300, icon = 'üì±') {
            const desktop = document.getElementById('desktop');
            const window = document.createElement('div');
            window.className = 'window';
            window.id = `window_${appId}`;
            window.style.width = width + 'px';
            window.style.height = height + 'px';
            
            // Center the window in the desktop area (below header)
            const headerHeight = 50;
            const desktopRect = desktop.getBoundingClientRect();
            const availableWidth = desktopRect.width;
            const availableHeight = desktopRect.height;
            
            window.style.left = Math.max(0, (availableWidth - width) / 2) + 'px';
            window.style.top = Math.max(10, (availableHeight - height) / 2) + 'px';
            
            // Z-index is now handled by CSS class (9999)

            window.innerHTML = `
                <div class="window-header" onmousedown="startDrag(event, '${appId}')">
                    <div class="window-title" ontouchstart="startDrag(event, '${appId}')">
                        <span class="window-icon">${icon}</span>
                        <span class="window-title-text">${title}</span>
                    </div>
                    <div class="window-controls">
                        <button class="window-control minimize" onclick="minimizeWindow('${appId}')">‚àí</button>
                        <button class="window-control maximize" onclick="toggleMaximize('${appId}')">‚ñ°</button>
                        <button class="window-control close" onclick="closeWindow('${appId}')">√ó</button>
                    </div>
                </div>
                <div class="window-content" id="content_${appId}">
                    ${content}
                </div>
                <div class="window-system-toolbar">
                    <div class="version-controls" id="version-controls-${appId}">
                        <button class="toolbar-button revert-btn" id="revert-btn-${appId}" title="Revert to last saved state" disabled>
                            ‚Ü∂ Revert
                        </button>
                        <button class="toolbar-button save-btn" id="save-btn-${appId}" title="Save current state">
                            üíæ Save
                        </button>
                        <span class="version-indicator" title="Version status">
                            No versions
                        </span>
                    </div>
                    <div class="app-controls">
                        <button class="toolbar-button window-voice-button" id="voice-button-${appId}" title="Hold to talk - Modify this app with voice">üé§</button>
                        <button class="toolbar-button window-text-button" id="text-button-${appId}" title="Edit this app with text prompt">‚úèÔ∏è</button>
                        <button class="toolbar-button window-history-button" id="history-button-${appId}" title="View prompt history" onclick="showPromptHistory('${appId}')">üìú</button>
                        <button class="toolbar-button window-download-button" id="download-button-${appId}" title="Download this app">‚¨áÔ∏è</button>
                    </div>
                </div>
                <div class="resize-handle" onmousedown="startResize(event, '${appId}')"></div>
            `;

            desktop.appendChild(window);
            
            // Apply current theme to the app content
            applyThemeToApp(appId);
            
            // Dispatch app shown event for newly created apps
            setTimeout(() => dispatchAppShownEvent(appId), 100); // Small delay to ensure app is fully rendered
            
            // Add push-to-talk event handlers to the app voice button
            const appVoiceButton = document.getElementById(`voice-button-${appId}`);
            if (appVoiceButton) {
                // Mouse events for push-to-talk
                appVoiceButton.addEventListener('mousedown', function(e) {
                    if (e.button === 0) { // Left mouse button
                        e.preventDefault();
                        startAppVoiceCommand(appId);
                    }
                });

                appVoiceButton.addEventListener('mouseup', function(e) {
                    if (e.button === 0) { // Left mouse button
                        e.preventDefault();
                        stopAppVoiceCommand(appId);
                    }
                });

                // Touch events for mobile push-to-talk
                appVoiceButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startAppVoiceCommand(appId);
                });

                appVoiceButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    stopAppVoiceCommand(appId);
                });

                // Click event as fallback (toggle behavior)
                appVoiceButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (!isListening || currentModifyingAppId !== appId) {
                        startAppVoiceCommand(appId);
                    } else {
                        stopAppVoiceCommand(appId);
                    }
                });
            }
            
            // Add event listeners to toolbar buttons with a small delay to ensure DOM is ready
            setTimeout(() => {
                // Add event listener to the app text button
                const appTextButton = document.getElementById(`text-button-${appId}`);
                if (appTextButton) {
                    appTextButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        showTextPromptDialog(appId);
                    });
                } else {
                    console.warn(`Text button not found for app ${appId}`);
                }
                
                // Add event listener to the app download button
                const appDownloadButton = document.getElementById(`download-button-${appId}`);
                if (appDownloadButton) {
                    appDownloadButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        downloadApp(appId);
                    });
                } else {
                    console.warn(`Download button not found for app ${appId}`);
                }
                
                // Version control event listeners are now handled by addVersionControlEventListeners()
                
                const revertButton = document.getElementById(`revert-btn-${appId}`);
                if (revertButton) {
                    revertButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        const history = window.versionManager.getHistory(appId);
                        if (history.length === 0) {
                            showCustomAlert('No saved versions available to revert to.', 'No Versions');
                            return;
                        }
                        
                        if (history.length === 1) {
                            // Only one version, revert directly
                            showCustomConfirm(
                                `Revert to saved state: "${history[0].description}"?\n\nThis will undo all changes since the last save.`,
                                'Confirm Revert'
                            ).then(confirmed => {
                                if (confirmed) {
                                    window.versionManager.restoreSnapshot(appId);
                                }
                            });
                        } else {
                            // Multiple versions, show selection dialog
                            showVersionSelectionDialog(appId, history);
                        }
                    });
                } else {
                    console.warn(`Revert button not found for app ${appId}`);
                }
            }, 50);
            
            // Initialize version control for this app
            setTimeout(() => {
                // Add event listeners for version control buttons
                addVersionControlEventListeners(appId);
                
                // Create initial snapshot for new apps
                if (content !== SPINNER_ANIMATION && window.versionManager) {
                    window.versionManager.createSnapshot(appId, 'Initial state');
                }
                // Update version controls after snapshot creation
                if (window.versionManager) {
                    window.versionManager.updateVersionControls(appId);
                }
            }, 100);
            
            // Add click handler to window content to bring window to focus
            const windowContent = document.getElementById(`content_${appId}`);
            if (windowContent) {
                windowContent.addEventListener('click', function(e) {
                    // Only bring to front if clicking directly on content, not on child elements that might have their own handlers
                    bringToFront(appId);
                });
            }
            
            // Also add click handler to the window itself
            window.addEventListener('click', function(e) {
                bringToFront(appId);
            });
            
            bringToFront(appId);
            return window;
        }

        function generateAppIcon(customRequest, title) {
            // Convert request and title to lowercase for matching
            const request = customRequest.toLowerCase();
            const appTitle = title.toLowerCase();
            
            // Define icon mappings based on keywords
            const iconMappings = {
                // Math & Calculation
                'calculator': 'üßÆ',
                'calc': 'üßÆ',
                'math': 'üßÆ',
                'arithmetic': 'üßÆ',
                
                // Time & Calendar
                'clock': 'üïê',
                'time': '‚è∞',
                'timer': '‚è±Ô∏è',
                'stopwatch': '‚è±Ô∏è',
                'calendar': 'üìÖ',
                'schedule': 'üìÖ',
                'date': 'üìÖ',
                
                // Text & Documents
                'text': 'üìù',
                'note': 'üìù',
                'editor': 'üìù',
                'document': 'üìÑ',
                'word': 'üìÑ',
                'write': '‚úçÔ∏è',
                
                // Games
                'game': 'üéÆ',
                'puzzle': 'üß©',
                'quiz': '‚ùì',
                'trivia': 'üß†',
                'memory': 'üß†',
                'card': 'üÉè',
                'dice': 'üé≤',
                
                // Media
                'music': 'üéµ',
                'audio': 'üîä',
                'video': 'üé¨',
                'player': '‚ñ∂Ô∏è',
                'media': 'üé≠',
                
                // Tools & Utilities
                'tool': 'üîß',
                'utility': '‚öôÔ∏è',
                'converter': 'üîÑ',
                'generator': '‚ö°',
                'random': 'üé≤',
                
                // Communication
                'chat': 'üí¨',
                'message': 'üí¨',
                'mail': 'üìß',
                'email': 'üìß',
                
                // Weather & Environment
                'weather': 'üå§Ô∏è',
                'temperature': 'üå°Ô∏è',
                'forecast': 'üå¶Ô∏è',
                
                // Finance & Shopping
                'money': 'üí∞',
                'cost': 'üí∞',
                'price': 'üí≤',
                'budget': 'üí∞',
                'finance': 'üí∞',
                'shopping': 'üõí',
                'cart': 'üõí',
                
                // Health & Fitness
                'health': 'üè•',
                'fitness': 'üí™',
                'exercise': 'üèÉ',
                'workout': 'üí™',
                
                // Food & Cooking
                'food': 'üçΩÔ∏è',
                'recipe': 'üë®‚Äçüç≥',
                'cooking': 'üë®‚Äçüç≥',
                'restaurant': 'üçΩÔ∏è',
                
                // Travel & Maps
                'map': 'üó∫Ô∏è',
                'travel': '‚úàÔ∏è',
                'navigation': 'üß≠',
                'location': 'üìç',
                
                // Education & Learning
                'learn': 'üìö',
                'education': 'üéì',
                'study': 'üìñ',
                'book': 'üìö',
                'library': 'üìö',
                
                // Art & Design
                'art': 'üé®',
                'design': 'üé®',
                'draw': '‚úèÔ∏è',
                'paint': 'üé®',
                'color': 'üåà',
                
                // Science & Technology
                'science': 'üî¨',
                'lab': 'üî¨',
                'experiment': 'üß™',
                'data': 'üìä',
                'chart': 'üìà',
                'graph': 'üìä',
                
                // Default categories
                'app': 'üì±',
                'application': 'üì±',
                'program': 'üíª'
            };
            
            // Check for matches in request first, then title
            const searchText = `${request} ${appTitle}`;
            
            for (const [keyword, icon] of Object.entries(iconMappings)) {
                if (searchText.includes(keyword)) {
                    return icon;
                }
            }
            
            // Default icon if no match found
            return 'üì±';
        }

        function createApp(customRequest) {
            const appId = generateAppId();
            const title = 'New App';
            const icon = generateAppIcon(customRequest, title);
            const content = createAIGeneratedAppContent(customRequest, appId);

            const app = {
                id: appId,
                type: 'ai-generated',
                title: title,
                icon: icon,
                isMinimized: false,
                isMaximized: false,
                system: false,
                customRequest: customRequest,
                promptHistory: [],
                namespace: `app_${appId.replace(/-/g, '_')}` // Store namespace for cleanup
            };

            apps.push(app);
            updateSharedAppsRegistry();
            createWindow(appId, title, content, 400, 300, icon);
            createTaskbarIcon(appId, title, icon);
            updateAppCount();
            
            // Update apps submenu to include the new user-generated app
            updateAppsSubmenuContent();

            return appId;
        }

        function createAppWithImages(customRequest, images) {
            const appId = generateAppId();
            const title = 'New App';
            const icon = generateAppIcon(customRequest, title);
            const content = createAIGeneratedAppContentWithImages(customRequest, images, appId);

            const app = {
                id: appId,
                type: 'ai-generated',
                title: title,
                icon: icon,
                isMinimized: false,
                isMaximized: false,
                system: false,
                customRequest: customRequest,
                promptHistory: [],
                namespace: `app_${appId.replace(/-/g, '_')}`, // Store namespace for cleanup
                hasImages: true,
                imageCount: images.length
            };

            apps.push(app);
            updateSharedAppsRegistry();
            createWindow(appId, title, content, 400, 300, icon);
            createTaskbarIcon(appId, title, icon);
            updateAppCount();
            
            // Update apps submenu to include the new user-generated app
            updateAppsSubmenuContent();

            return appId;
        }

        function createTaskbarIcon(appId, title, appIcon = 'üì±') {
            const iconsContainer = document.getElementById('app-icons');
            const icon = document.createElement('div');
            icon.className = 'app-icon';
            icon.id = `icon_${appId}`;
            icon.onclick = () => toggleWindow(appId);
            icon.innerHTML = `<span class="taskbar-icon">${appIcon}</span>`;
            icon.title = title; // Show title on hover
            iconsContainer.appendChild(icon);
        }

        function requestApp() {
            const request = document.getElementById('app-request').value.trim();
            if (request || newAppPastedImages.length > 0) {
                if (newAppPastedImages.length > 0) {
                    console.log(`Creating app with ${newAppPastedImages.length} images`);
                    createAppWithImages(request, newAppPastedImages);
                } else {
                    createApp(request);
                }
                
                // Clear the input and images
                document.getElementById('app-request').value = '';
                newAppPastedImages = [];
                
                // Hide image preview container
                const pastedImagesContainer = document.getElementById('new-app-pasted-images');
                if (pastedImagesContainer) {
                    pastedImagesContainer.style.display = 'none';
                }
                
                // Clear image previews
                const imageContainer = document.getElementById('new-app-image-preview-container');
                if (imageContainer) {
                    imageContainer.innerHTML = '';
                }
                
                document.getElementById('start-menu').classList.remove('show');
            }
        }

        // Voice Recognition System using OpenAI Realtime API
        let isListening = false;

        // Initialize voice system on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up voice system...');
            
            // Voice button event handlers for Whisper API - attach immediately
            const voiceButton = document.getElementById('voice-button');
            console.log('Voice button element:', voiceButton);
            
            if (voiceButton) {
                voiceButton.addEventListener('click', function() {
                    console.log('Voice button clicked!'); // Debug log
                    if (!isListening) {
                        startVoiceSession();
                    } else {
                        stopVoiceSession();
                    }
                });
                console.log('Voice button click handler attached');
            } else {
                console.error('Voice button element not found!');
            }
            
            // Load saved settings first, then initialize voice system
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                if (savedSettings.voiceRecognitionType) {
                    voiceRecognitionType = savedSettings.voiceRecognitionType;
                    console.log(`Loaded voice recognition type from settings: ${voiceRecognitionType}`);
                }
                
                // Also apply the Web Speech API language if it's saved
                if (savedSettings.webSpeechLanguage && voiceRecognitionType === 'web') {
                    console.log(`Loaded Web Speech API language from settings: ${savedSettings.webSpeechLanguage}`);
                }
            }
            
            // Initialize voice in background (non-blocking) with correct settings
            initializeVoice().then(() => {
                console.log('Voice system initialized successfully');
            }).catch((error) => {
                console.warn('Voice initialization failed:', error);
                updateVoiceStatus('Voice Error', 'error');
            });

            // Also support mousedown/mouseup for push-to-talk
            document.getElementById('voice-button').addEventListener('mousedown', function(e) {
                if (e.button === 0 && !isListening) { // Left mouse button
                    startVoiceSession();
                }
            });

            document.getElementById('voice-button').addEventListener('mouseup', function(e) {
                if (e.button === 0 && isListening) { // Left mouse button
                    stopVoiceSession();
                }
            });

            // Touch events for mobile
            document.getElementById('voice-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (!isListening) {
                    startVoiceSession();
                }
            });

            document.getElementById('voice-button').addEventListener('touchend', function(e) {
                e.preventDefault();
                if (isListening) {
                    stopVoiceSession();
                }
            });

            // Initialize model mode to Simple (default) only if no settings were loaded
            // This prevents overwriting the model set from saved settings
            // Check if settings were already loaded in init()
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' && CONFIG.MODEL === 'google/gemini-2.5-flash-lite-preview-06-17') {
                // No settings were loaded, use default
                CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                console.log(`Model initialized to: ${currentModelMode} mode (${CONFIG.MODEL})`);
            } else {
                console.log(`Model loaded from settings: ${currentModelMode} mode (${CONFIG.MODEL})`);
            }
        });

        // Voice Handler supporting both Whisper and Web Speech API
        async function initializeVoice() {
            try {
                // Check Web Speech API support
                isWebSpeechSupported = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
                
                if (voiceRecognitionType === 'web' && isWebSpeechSupported) {
                    // Initialize Web Speech API
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    webSpeechRecognition = new SpeechRecognition();
                    webSpeechRecognition.continuous = false;
                    webSpeechRecognition.interimResults = false;
                    
                    // Get selected language from settings or saved settings or default to en-US
                    let selectedLanguage = 'en-US';
                    
                    // First try to get from UI element
                    const languageSelect = document.getElementById('web-speech-language');
                    if (languageSelect && languageSelect.value) {
                        selectedLanguage = languageSelect.value;
                    } else {
                        // If UI element not available, try to get from saved settings
                        const savedSettings = loadSettingsFromCookie();
                        if (savedSettings && savedSettings.webSpeechLanguage) {
                            selectedLanguage = savedSettings.webSpeechLanguage;
                        }
                    }
                    
                    webSpeechRecognition.lang = selectedLanguage;
                    console.log(`Web Speech API initialized with language: ${selectedLanguage}`);
                    
                    webSpeechRecognition.onresult = function(event) {
                        const transcript = event.results[0][0].transcript;
                        console.log('Web Speech transcript:', transcript);
                        handleVoiceTranscription(transcript);
                    };
                    
                    webSpeechRecognition.onerror = function(event) {
                        console.error('Web Speech error:', event.error);
                        updateVoiceStatus('Voice Error', 'error');
                        isListening = false;
                    };
                    
                    webSpeechRecognition.onend = function() {
                        console.log('Web Speech ended');
                        isListening = false;
                        updateVoiceStatus('Voice Ready', 'ready');
                    };
                    
                    updateVoiceStatus('Voice Ready (Web)', 'ready');
                    return true;
                } else {
                    // Initialize Whisper API (requires microphone access)
                    mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                    
                    updateVoiceStatus('Voice Ready (Whisper)', 'ready');
                    return true;
                }
            } catch (error) {
                console.error('Voice initialization failed:', error);
                updateVoiceStatus('Voice Error', 'error');
                return false;
            }
        }

        async function startVoiceSession() {
            console.log(`üéôÔ∏è startVoiceSession() called with type: ${voiceRecognitionType}`);
            console.log(`üîç isListening: ${isListening}`);
            
            if (isListening) {
                console.log(`‚ùå Already listening, returning early`);
                return;
            }
            
            try {
                isListening = true;
                updateVoiceStatus('Recording...', 'listening');
                console.log('‚úÖ Voice session starting...');
                
                if (voiceRecognitionType === 'web' && isWebSpeechSupported && webSpeechRecognition) {
                    // Use Web Speech API
                    console.log('üåê Starting Web Speech Recognition...');
                    webSpeechRecognition.start();
                } else {
                    // Use Whisper API
                    console.log('üé§ Starting Whisper recording...');
                    
                    if (!mediaStream) {
                        console.log(`‚ùå No mediaStream available, initializing...`);
                        try {
                            await initializeVoice();
                            console.log(`‚úÖ Voice system re-initialized`);
                        } catch (error) {
                            console.error(`‚ùå Failed to re-initialize voice system:`, error);
                            updateVoiceStatus('Voice Error', 'error');
                            isListening = false;
                            return;
                        }
                    }
                    
                    // Start recording audio for Whisper
                    mediaRecorder = new MediaRecorder(mediaStream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    // Clear and initialize audio chunks array
                    audioChunks = [];
                    console.log(`üßπ Initialized fresh audioChunks array, length: ${audioChunks.length}`);
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        console.log('Recording stopped, processing audio...');
                        updateVoiceStatus('Processing...', 'processing');
                        
                        // Create audio blob
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        
                        // Send to Whisper API
                        await transcribeAudio(audioBlob);
                    };
                    
                    mediaRecorder.start();
                }
                
            } catch (error) {
                console.error('Failed to start voice session:', error);
                stopVoiceSession();
                updateVoiceStatus('Voice Error', 'error');
            }
        }

        function handleVoiceTranscription(transcription) {
            console.log('Voice transcription received:', transcription);
            
            if (transcription.trim()) {
                // Show voice command popup
                showVoiceCommandPopup(transcription.trim());
                
                // Check if we're modifying an existing app or creating a new one
                if (currentModifyingAppId) {
                    // Modify existing app
                    modifyApp(currentModifyingAppId, transcription.trim());
                    
                    // Reset the voice button appearance
                    const voiceButton = document.querySelector(`#window_${currentModifyingAppId} .window-voice-button`);
                    if (voiceButton) {
                        voiceButton.classList.remove('recording');
                    }
                    
                    // Clear the modifying app ID
                    currentModifyingAppId = null;
                } else {
                    // Create new app based on voice command
                    createApp(transcription.trim());
                }
                
                updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
            } else {
                updateVoiceStatus('No speech detected', 'error');
                setTimeout(() => updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready'), 2000);
            }
        }

        async function transcribeAudio(audioBlob) {
            try {
                // Convert to FormData for Whisper API
                const formData = new FormData();
                formData.append('file', audioBlob, 'audio.webm');
                formData.append('model', 'whisper-1');
                formData.append('response_format', 'text');
                
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${CONFIG.OPENAI_API_KEY}`
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Whisper API error: ${response.status}`);
                }
                
                const transcription = await response.text();
                console.log('Whisper transcription:', transcription);
                
                // Use the common transcription handler
                handleVoiceTranscription(transcription);
                
            } catch (error) {
                console.error('Whisper transcription failed:', error);
                updateVoiceStatus('Transcription Error', 'error');
                setTimeout(() => updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready'), 2000);
            }
        }

        function stopVoiceSession() {
            console.log(`üõë Stopping voice session (type: ${voiceRecognitionType})...`);
            isListening = false;
            
            if (voiceRecognitionType === 'web' && webSpeechRecognition) {
                // Stop Web Speech API
                try {
                    webSpeechRecognition.stop();
                    console.log(`üõë Stopped Web Speech Recognition`);
                } catch (error) {
                    console.warn('Error stopping Web Speech Recognition:', error);
                }
            } else {
                // Stop Whisper recording
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    console.log(`üõë Stopping mediaRecorder...`);
                    mediaRecorder.stop();
                }
                
                // Clear audio chunks to prevent accumulation
                audioChunks = [];
                console.log(`üßπ Cleared audioChunks array`);
            }
            
            updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
        }

        // Removed old Realtime API functions - now using simple Whisper approach
        
        function processVoiceCommand(command) {
            const lowerCommand = command.toLowerCase();
            
            // Extract app creation requests
            if (lowerCommand.includes('create') || lowerCommand.includes('make') || lowerCommand.includes('build')) {
                // Remove command words and extract the app description
                let appRequest = command
                    .replace(/create|make|build|me|a|an/gi, '')
                    .replace(/app|application/gi, '')
                    .trim();
                
                if (appRequest) {
                    createApp(appRequest);
                    updateVoiceStatus(`Creating: ${appRequest}`, 'ready');
                }
            } else if (lowerCommand.includes('close all')) {
                closeAllApps();
                updateVoiceStatus('Closing all apps', 'ready');
            } else if (lowerCommand.includes('show apps') || lowerCommand.includes('app manager')) {
                showAppList();
                updateVoiceStatus('Opening App Manager', 'ready');
            } else {
                // Treat the entire command as an app request
                createApp(command);
                updateVoiceStatus(`Creating: ${command}`, 'ready');
            }
        }

        function updateVoiceStatus(text, state) {
            const voiceStatusElement = document.getElementById('voice-status');
            if (voiceStatusElement) {
                voiceStatusElement.textContent = text;
            }
            
            const voiceButton = document.getElementById('voice-button');
            if (voiceButton) {
                voiceButton.className = state;
            }
        }

        function showVoiceCommandPopup(command) {
            const popup = document.getElementById('voice-command-popup');
            if (!popup) return;
            
            // Set the command text
            popup.textContent = command;
            
            // Show the popup with fade-in
            popup.classList.add('show');
            
            // Fade out after 2 seconds
            setTimeout(() => {
                popup.classList.add('fade-out');
                
                // Remove classes after fade-out completes
                setTimeout(() => {
                    popup.classList.remove('show', 'fade-out');
                }, 500);
            }, 2000);
        }

        // Global variable to track which app is being modified
        let currentModifyingAppId = null;

        function startAppVoiceCommand(appId) {
            console.log(`üé§ Starting voice command for app: ${appId}`);
            console.log(`üîç Current isListening state: ${isListening}`);
            console.log(`üîç Current mediaStream:`, mediaStream);
            console.log(`üîç Current mediaRecorder:`, mediaRecorder);
            
            // Set the app being modified
            currentModifyingAppId = appId;
            console.log(`‚úÖ Set currentModifyingAppId to: ${currentModifyingAppId}`);
            
            // Visual feedback - make the voice button red and pulsing
            const voiceButton = document.querySelector(`#window_${appId} .window-voice-button`);
            if (voiceButton) {
                voiceButton.classList.add('recording');
                console.log(`‚úÖ Added 'recording' class to voice button for app ${appId}`);
            } else {
                console.error(`‚ùå Could not find voice button for app ${appId}`);
            }
            
            // Handle voice session for app modification
            if (isListening) {
                console.log(`üîÑ Already listening - stopping current session and starting app-specific session`);
                // Stop current session and start new one for app
                stopVoiceSession();
                // Wait a moment then start new session
                setTimeout(() => {
                    console.log(`üéôÔ∏è Starting new voice session for app ${appId}...`);
                    startVoiceSession();
                }, 100);
            } else {
                console.log(`üéôÔ∏è Starting new voice session for app modification...`);
                try {
                    startVoiceSession();
                    console.log(`‚úÖ startVoiceSession() called successfully`);
                } catch (error) {
                    console.error(`‚ùå Error calling startVoiceSession():`, error);
                }
            }
            
            // Update voice status to show app-specific recording
            updateVoiceStatus(`Recording for ${appId}`, 'listening');
        }

        function stopAppVoiceCommand(appId) {
            console.log(`üõë Stopping voice command for app: ${appId}`);
            
            // Stop the voice session
            stopVoiceSession();
            
            // Reset the voice button appearance
            const voiceButton = document.querySelector(`#window_${appId} .window-voice-button`);
            if (voiceButton) {
                voiceButton.classList.remove('recording');
                console.log(`‚úÖ Removed 'recording' class from voice button for app ${appId}`);
            }
            
            // DON'T clear currentModifyingAppId here - let transcribeAudio() handle it
            // The transcription process needs currentModifyingAppId to know which app to modify
            console.log(`‚úÖ Keeping currentModifyingAppId (${currentModifyingAppId}) for transcription processing`);
        }

        function showTextPromptDialog(appId) {
            const app = apps.find(a => a.id === appId);
            if (!app) {
                showCustomAlert('App not found!', 'Error');
                return;
            }

            // Get the app window element to position the dialog relative to it
            const appWindow = document.getElementById(`window_${appId}`);
            if (!appWindow) {
                showCustomAlert('App window not found!', 'Error');
                return;
            }

            // Create the modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'text-prompt-overlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(2px);
            `;

            // Create the dialog box
            const dialog = document.createElement('div');
            dialog.className = 'text-prompt-dialog';
            dialog.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 24px;
                max-width: 90%;
                width: 400px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;

            // Apply theme to dialog
            if (document.body.classList.contains('dark-theme')) {
                dialog.style.background = '#2c3e50';
                dialog.style.color = '#f8f9fa';
            }

            dialog.innerHTML = `
                <div style="margin-bottom: 16px;">
                    <h3 style="margin: 0 0 8px 0; color: ${document.body.classList.contains('dark-theme') ? '#f8f9fa' : '#333'}; font-size: 18px;">‚úèÔ∏è Edit App</h3>
                    <p style="margin: 0; color: ${document.body.classList.contains('dark-theme') ? '#e9ecef' : '#666'}; font-size: 14px;">Enter modification instructions for "${app.title}". You can also paste screenshots (Ctrl+V):</p>
                </div>
                <div style="margin-bottom: 20px;">
                    <textarea
                        id="text-prompt-input-${appId}"
                        placeholder="Add a new feature or modify the existing functionality... You can also paste screenshots here with Ctrl+V"
                        style="
                            width: 100%;
                            height: 120px;
                            padding: 12px;
                            border: 2px solid ${document.body.classList.contains('dark-theme') ? '#6c757d' : '#ddd'};
                            border-radius: 6px;
                            font-size: 14px;
                            font-family: inherit;
                            resize: vertical;
                            background: ${document.body.classList.contains('dark-theme') ? '#495057' : '#ffffff'};
                            color: ${document.body.classList.contains('dark-theme') ? '#f8f9fa' : '#333'};
                        "
                    ></textarea>
                    <div id="pasted-images-${appId}" style="margin-top: 10px; display: none;">
                        <div style="font-size: 12px; color: ${document.body.classList.contains('dark-theme') ? '#e9ecef' : '#666'}; margin-bottom: 8px;">üì∑ Pasted Images:</div>
                        <div id="image-preview-container-${appId}" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button
                        id="text-prompt-cancel-${appId}"
                        style="
                            background: #6c757d;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: 500;
                            transition: background 0.2s ease;
                        "
                    >Cancel</button>
                    <button
                        id="text-prompt-submit-${appId}"
                        style="
                            background: #0078d4;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: 500;
                            transition: background 0.2s ease;
                        "
                    >Apply Changes</button>
                </div>
            `;

            overlay.appendChild(dialog);
            appWindow.appendChild(overlay);

            // Set flag to prevent app key handlers from interfering
            window.customDialogOpen = true;

            // Focus the textarea
            const textarea = document.getElementById(`text-prompt-input-${appId}`);
            setTimeout(() => {
                textarea.focus();
                textarea.select();
            }, 100);

            // Store pasted images for this dialog
            let pastedImages = [];

            // Add paste event listener for image support
            textarea.addEventListener('paste', async (e) => {
                const items = e.clipboardData.items;
                
                for (let item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        e.preventDefault();
                        
                        const file = item.getAsFile();
                        if (file) {
                            try {
                                // Convert image to base64
                                const base64 = await fileToBase64(file);
                                
                                // Add to pasted images array
                                const imageData = {
                                    base64: base64,
                                    type: file.type,
                                    name: `pasted-image-${Date.now()}.${file.type.split('/')[1]}`
                                };
                                pastedImages.push(imageData);
                                
                                // Show image preview
                                showImagePreview(appId, imageData, pastedImages.length - 1);
                                
                                // Show the pasted images container
                                const pastedImagesContainer = document.getElementById(`pasted-images-${appId}`);
                                if (pastedImagesContainer) {
                                    pastedImagesContainer.style.display = 'block';
                                }
                                
                                console.log('Image pasted successfully:', imageData.name);
                            } catch (error) {
                                console.error('Error processing pasted image:', error);
                                showCustomAlert('Error processing pasted image. Please try again.', 'Error');
                            }
                        }
                    }
                }
            });

            // Helper function to convert file to base64
            function fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            // Helper function to show image preview
            function showImagePreview(appId, imageData, index) {
                const container = document.getElementById(`image-preview-container-${appId}`);
                if (!container) return;

                const previewDiv = document.createElement('div');
                previewDiv.style.cssText = `
                    position: relative;
                    display: inline-block;
                    border: 1px solid ${document.body.classList.contains('dark-theme') ? '#6c757d' : '#ddd'};
                    border-radius: 4px;
                    overflow: hidden;
                `;

                const img = document.createElement('img');
                img.src = imageData.base64;
                img.style.cssText = `
                    width: 80px;
                    height: 80px;
                    object-fit: cover;
                    display: block;
                `;

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '√ó';
                removeBtn.style.cssText = `
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    width: 20px;
                    height: 20px;
                    background: rgba(220, 53, 69, 0.8);
                    color: white;
                    border: none;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 12px;
                    line-height: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                removeBtn.addEventListener('click', () => {
                    // Remove from array
                    pastedImages.splice(index, 1);
                    // Remove preview
                    previewDiv.remove();
                    // Hide container if no images left
                    if (pastedImages.length === 0) {
                        const pastedImagesContainer = document.getElementById(`pasted-images-${appId}`);
                        if (pastedImagesContainer) {
                            pastedImagesContainer.style.display = 'none';
                        }
                    }
                });

                previewDiv.appendChild(img);
                previewDiv.appendChild(removeBtn);
                container.appendChild(previewDiv);
            }

            // Handle button clicks
            const cancelBtn = document.getElementById(`text-prompt-cancel-${appId}`);
            const submitBtn = document.getElementById(`text-prompt-submit-${appId}`);

            function closeDialog() {
                overlay.remove();
                // Clear flag to re-enable app key handlers
                window.customDialogOpen = false;
            }

            cancelBtn.addEventListener('click', closeDialog);

            submitBtn.addEventListener('click', () => {
                const promptText = textarea.value.trim();
                if (promptText || pastedImages.length > 0) {
                    console.log(`Text modification request for app ${appId}: ${promptText}`);
                    console.log(`Pasted images count: ${pastedImages.length}`);
                    
                    // Create modification request with images
                    const modificationData = {
                        text: promptText,
                        images: pastedImages
                    };
                    
                    modifyAppWithImages(appId, modificationData);
                    closeDialog();
                } else {
                    textarea.focus();
                    textarea.style.borderColor = '#dc3545';
                    setTimeout(() => {
                        textarea.style.borderColor = document.body.classList.contains('dark-theme') ? '#6c757d' : '#ddd';
                    }, 2000);
                }
            });

            // Handle Enter key (Ctrl+Enter to submit)
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    submitBtn.click();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeDialog();
                }
            });

            // Close on overlay click (but not dialog click)
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeDialog();
                }
            });

            // Add hover effects to buttons
            cancelBtn.addEventListener('mouseenter', () => {
                cancelBtn.style.background = '#5a6268';
            });
            cancelBtn.addEventListener('mouseleave', () => {
                cancelBtn.style.background = '#6c757d';
            });

            submitBtn.addEventListener('mouseenter', () => {
                submitBtn.style.background = '#106ebe';
            });
            submitBtn.addEventListener('mouseleave', () => {
                submitBtn.style.background = '#0078d4';
            });
        }

        function closeWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const icon = document.getElementById(`icon_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (app && app.isSystemApp) {
                // For system apps, hide instead of remove
                if (window) {
                    window.style.display = 'none';
                    app.isHidden = true;
                    updateSharedAppsRegistry();
                }
                if (icon) {
                    icon.style.display = 'none';
                }
                console.log(`System app ${appId} hidden`);
            } else {
                // For user apps, remove completely and clean up namespace
                if (window) window.remove();
                if (icon) icon.remove();
                
                // Clean up app-specific resources
                cleanupAppNamespace(appId);
                
                // Clean up version control listeners and dirty state
                if (appsWithVersionListeners.has(appId)) {
                    appsWithVersionListeners.delete(appId);
                }
                if (window.versionManager) {
                    if (window.versionManager.dirtyApps.has(appId)) {
                        window.versionManager.dirtyApps.delete(appId);
                    }
                    if (window.versionManager.activeSnapshots.has(appId)) {
                        window.versionManager.activeSnapshots.delete(appId);
                    }
                }
                
                apps = apps.filter(app => app.id !== appId);
                updateSharedAppsRegistry();
                console.log(`User app ${appId} removed and namespace cleaned`);
            }
            
            updateAppCount();
        }

        function cleanupAppNamespace(appId) {
            try {
                // Remove app-specific CSS
                const styleElement = document.getElementById(`style-${appId}`);
                if (styleElement) {
                    styleElement.remove();
                }
                
                // Remove app-specific JavaScript storage
                const scriptElement = document.getElementById(`script-${appId}`);
                if (scriptElement) {
                    scriptElement.remove();
                }
                
                // Clean up app namespace from window object
                const namespace = `app_${appId.replace(/-/g, '_')}`;
                if (window[namespace]) {
                    delete window[namespace];
                }
                
                // Remove app-specific event listeners
                const events = document._appEventListeners || {};
                Object.keys(events).forEach(eventName => {
                    if (eventName.startsWith(`${appId}:`)) {
                        delete events[eventName];
                    }
                });
                
                // Clean up app-specific key handlers
                cleanupAppKeyHandlers(appId);
                
                console.log(`Cleaned up namespace for app ${appId}`);
            } catch (error) {
                console.warn(`Error cleaning up namespace for app ${appId}:`, error);
            }
        }

        function minimizeWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                window.classList.add('minimized');
                app.isMinimized = true;
                updateSharedAppsRegistry();
                updateIconState(appId);
            }
        }

        function toggleMaximize(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                window.classList.toggle('maximized');
                app.isMaximized = !app.isMaximized;
                updateSharedAppsRegistry();
                bringToFront(appId);
            }
        }

        function toggleWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                if (app.isMinimized) {
                    window.classList.remove('minimized');
                    app.isMinimized = false;
                    updateSharedAppsRegistry();
                    bringToFront(appId);
                } else {
                    minimizeWindow(appId);
                }
                updateIconState(appId);
            }
        }

        function updateIconState(appId) {
            const icon = document.getElementById(`icon_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (icon && app) {
                icon.classList.toggle('active', !app.isMinimized);
            }
        }

        function bringToFront(appId) {
            const window = document.getElementById(`window_${appId}`);
            if (window) {
                const maxZ = Math.max(...Array.from(document.querySelectorAll('.window')).map(w => parseInt(w.style.zIndex) || 0));
                window.style.zIndex = maxZ + 1;
                activeWindow = appId;
            }
        }

        function startDrag(event, appId) {
            event.preventDefault();
            const window = document.getElementById(`window_${appId}`);
            if (window.classList.contains('maximized')) return;
            
            bringToFront(appId);
            
            // Handle both mouse and touch events
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            
            dragData = {
                appId: appId,
                startX: clientX,
                startY: clientY,
                startLeft: parseInt(window.style.left),
                startTop: parseInt(window.style.top)
            };
            
            // Add both mouse and touch event listeners
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }

        function drag(event) {
            if (!dragData) return;
            event.preventDefault(); // Prevent scrolling on touch
            
            // Handle both mouse and touch events
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            
            const window = document.getElementById(`window_${dragData.appId}`);
            const deltaX = clientX - dragData.startX;
            const deltaY = clientY - dragData.startY;
            
            window.style.left = (dragData.startLeft + deltaX) + 'px';
            window.style.top = (dragData.startTop + deltaY) + 'px';
        }

        function stopDrag() {
            dragData = null;
            // Remove both mouse and touch event listeners
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', stopDrag);
        }

        function startResize(event, appId) {
            event.preventDefault();
            event.stopPropagation();
            
            const window = document.getElementById(`window_${appId}`);
            if (window.classList.contains('maximized')) return;
            
            bringToFront(appId);
            
            resizeData = {
                appId: appId,
                startX: event.clientX,
                startY: event.clientY,
                startWidth: parseInt(window.style.width),
                startHeight: parseInt(window.style.height)
            };
            
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }

        function resize(event) {
            if (!resizeData) return;
            
            const window = document.getElementById(`window_${resizeData.appId}`);
            const deltaX = event.clientX - resizeData.startX;
            const deltaY = event.clientY - resizeData.startY;
            
            const newWidth = Math.max(300, resizeData.startWidth + deltaX);
            const newHeight = Math.max(200, resizeData.startHeight + deltaY);
            
            window.style.width = newWidth + 'px';
            window.style.height = newHeight + 'px';
        }

        function stopResize() {
            resizeData = null;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', stopResize);
        }

        function showAppList() {
            const appListContent = `
                <h3>App Manager</h3>
                <div style="margin-bottom: 15px;">
                    <button id="load-app-btn" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px;">üìÅ Load App</button>
                    <input type="file" id="app-file-input" accept=".json" style="display: none;">
                </div>
                <div style="max-height: 300px; overflow-y: auto;">
                    ${apps.map(app => `
                        <div style="padding: 10px; border: 1px solid #ddd; margin: 5px 0; border-radius: 4px;">
                            <strong>ID:</strong> ${app.id}<br>
                            <strong>Title:</strong> ${app.title}<br>
                            <strong>Type:</strong> ${app.type}<br>
                            ${app.customRequest ? `<strong>Request:</strong> ${app.customRequest}<br>` : ''}
                            <strong>Status:</strong> ${app.isMinimized ? 'Minimized' : 'Active'}
                            <div style="margin-top: 8px;">
                                <button onclick="downloadApp('${app.id}')" style="background: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 12px;">üíæ Download</button>
                                <button onclick="closeWindow('${app.id}')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">‚ùå Close</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Total apps: ${apps.length} | Next ID: app_${nextAppId}
                </p>
            `;
            
            // Create App Manager directly without AI generation
            const managerId = generateAppId();
            const managerApp = {
                id: managerId,
                type: 'system',
                title: 'App Manager',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System App Manager'
            };

            apps.push(managerApp);
            updateSharedAppsRegistry();
            createWindow(managerId, 'App Manager', appListContent);
            createTaskbarIcon(managerId, 'App Manager', 'üìã');
            updateAppCount();
            
            const contentElement = document.getElementById(`content_${managerId}`);
            
            // Add event listeners for the new buttons
            setTimeout(() => {
                const loadBtn = document.getElementById('load-app-btn');
                const fileInput = document.getElementById('app-file-input');
                
                if (loadBtn && fileInput) {
                    loadBtn.addEventListener('click', () => {
                        fileInput.click();
                    });
                    
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            loadAppFromFile(file);
                        }
                    });
                }
            }, 100);
            
            document.getElementById('start-menu').classList.remove('show');
        }

        function closeAllApps() {
            showCustomConfirm('Close all applications?', 'Confirm Close All').then(confirmed => {
                if (confirmed) {
                    [...apps].forEach(app => closeWindow(app.id));
                }
            });
            document.getElementById('start-menu').classList.remove('show');
        }

        function downloadApp(appId) {
            const app = apps.find(a => a.id === appId);
            if (!app) {
                showCustomAlert('App not found!', 'Error');
                return;
            }

            try {
                // Get the current app content
                const contentElement = document.getElementById(`content_${appId}`);
                const currentHTML = contentElement ? contentElement.innerHTML : '';
                
                // Get the current CSS for this app
                const styleElement = document.getElementById(`style-${appId}`);
                let currentCSS = '';
                
                if (styleElement) {
                    // Try to get original CSS from data attribute first
                    const originalCSS = styleElement.getAttribute('data-original-css');
                    if (originalCSS) {
                        currentCSS = originalCSS;
                        console.log(`Using original CSS for app ${appId}`);
                    } else {
                        // Fallback to current CSS content (may be namespaced)
                        currentCSS = styleElement.textContent;
                        console.log(`Using current CSS for app ${appId} (may be namespaced)`);
                    }
                }
                
                // Get the current JavaScript for this app (if any)
                const scriptElement = document.getElementById(`script-${appId}`);
                const currentJavaScript = scriptElement ? scriptElement.textContent : '';

                // Get window dimensions and position for restoration
                const windowElement = document.getElementById(`window_${appId}`);
                let windowState = {
                    width: 400,
                    height: 300,
                    left: 100,
                    top: 100
                };
                
                if (windowElement) {
                    windowState = {
                        width: parseInt(windowElement.style.width) || 400,
                        height: parseInt(windowElement.style.height) || 300,
                        left: parseInt(windowElement.style.left) || 100,
                        top: parseInt(windowElement.style.top) || 100
                    };
                }

                // Create comprehensive app data object with all current features
                const appData = {
                    // Basic app information
                    id: app.id,
                    title: app.title,
                    icon: app.icon || 'üì±',
                    type: app.type,
                    customRequest: app.customRequest,
                    
                    // App content
                    html: currentHTML,
                    css: currentCSS,
                    javascript: currentJavaScript,
                    
                    // Window state
                    windowState: windowState,
                    isMinimized: app.isMinimized,
                    isMaximized: app.isMaximized,
                    
                    // App history and modifications
                    modificationHistory: app.modificationHistory || [],
                    lastModification: app.lastModification || null,
                    promptHistory: app.promptHistory || [],
                    
                    // System app properties
                    isSystemApp: app.isSystemApp || false,
                    isHidden: app.isHidden || false,
                    generationMode: app.generationMode || 'SIMPLE',
                    
                    // Image support (if app was created with images)
                    hasImages: app.hasImages || false,
                    imageCount: app.imageCount || 0,
                    
                    // Namespace information for proper isolation
                    namespace: app.namespace || `app_${appId.replace(/-/g, '_')}`,
                    
                    // Export metadata
                    exportDate: new Date().toISOString(),
                    exportedBy: 'Self-Evolving OS v2.0.0',
                    version: '2.0',
                    
                    // Compatibility information
                    compatibility: {
                        minVersion: '2.0.0',
                        features: [
                            'namespace-isolation',
                            'theme-support',
                            'voice-modification',
                            'prompt-history',
                            'window-state-restoration'
                        ]
                    }
                };

                // Create and download the file with improved naming
                const dataStr = JSON.stringify(appData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                // Generate a more descriptive filename
                const sanitizedTitle = app.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const timestamp = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
                const filename = `${sanitizedTitle}_${app.id}_${timestamp}.json`;
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the blob URL
                setTimeout(() => {
                    URL.revokeObjectURL(link.href);
                }, 100);
                
                console.log(`Downloaded app: ${app.title} (${app.id}) as ${filename}`);
                
                // Show success notification
                showDownloadNotification(app.title, filename);
                
            } catch (error) {
                console.error('Error downloading app:', error);
                showCustomAlert(`Failed to download app: ${error.message}`, 'Error');
            }
        }

        function showDownloadNotification(appTitle, filename) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 10001;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 18px;">üíæ</span>
                    <div>
                        <div style="font-weight: bold;">App Downloaded</div>
                        <div style="font-size: 12px; opacity: 0.9;">${appTitle}</div>
                        <div style="font-size: 11px; opacity: 0.7;">${filename}</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // Animate out and remove
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function loadAppFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const appData = JSON.parse(e.target.result);
                    
                    // Validate the app data structure
                    if (!appData.title || !appData.html) {
                        throw new Error('Invalid app file format - missing required fields');
                    }
                    
                    // Check version compatibility
                    const appVersion = appData.version || '1.0';
                    const isLegacyFormat = parseFloat(appVersion) < 2.0;
                    
                    if (isLegacyFormat) {
                        console.log('Loading legacy app format, upgrading...');
                    }
                    
                    // Use the original app ID from the saved app, or generate one if missing
                    const appId = appData.id || generateAppId();
                    
                    // IMPROVEMENT: Three-step validation process before loading
                    
                    // Step 1: Check if app is in persistence by comparing appIds
                    const persistentApps = window.dataRegistry.getAllData();
                    const persistentAppExists = Object.keys(persistentApps).some(key => {
                        const data = persistentApps[key];
                        const meta = window.dataRegistry.getDataInfo(key);
                        return meta.config && meta.config.type === 'app' && meta.config.appId === appId;
                    });
                    
                    if (persistentAppExists) {
                        showCustomAlert(`App "${appData.title}" is already saved in persistence. Cannot load duplicate.`, 'App Already in Persistence');
                        return;
                    }
                    
                    // Step 2: Check if app is currently running/active
                    const existingApp = apps.find(app => app.id === appId);
                    if (existingApp) {
                        showCustomAlert(`App "${appData.title}" is already running. Cannot load duplicate.`, 'App Already Running');
                        return;
                    }
                    
                    // Create the app object with all modern features
                    const newApp = {
                        id: appId,
                        type: appData.type || 'imported',
                        title: appData.title,
                        icon: appData.icon || 'üì±',
                        isMinimized: false,
                        isMaximized: false,
                        customRequest: appData.customRequest || 'Imported app',
                        promptHistory: appData.promptHistory || [],
                        modificationHistory: appData.modificationHistory || [],
                        lastModification: appData.lastModification || null,
                        isSystemApp: appData.isSystemApp || false,
                        isHidden: false,
                        generationMode: appData.generationMode || 'SIMPLE',
                        hasImages: appData.hasImages || false,
                        imageCount: appData.imageCount || 0,
                        namespace: `app_${appId.replace(/-/g, '_')}`
                    };
                    
                    // Add to apps array
                    apps.push(newApp);
                    updateSharedAppsRegistry();
                    
                    // Determine window dimensions
                    let windowWidth = 400;
                    let windowHeight = 300;
                    
                    if (appData.windowState) {
                        windowWidth = appData.windowState.width || 400;
                        windowHeight = appData.windowState.height || 300;
                    }
                    
                    // Use the original content without modification since we're using the original app ID
                    const originalHTML = appData.html;
                    const originalCSS = appData.css || '';
                    const originalJavaScript = appData.javascript || '';
                    
                    console.log(`Loading app with original ID: ${appId}`);
                    
                    // Create the window with the original content
                    createWindow(appId, appData.title, originalHTML, windowWidth, windowHeight, newApp.icon);
                    createTaskbarIcon(appId, appData.title, newApp.icon);
                    
                    // Add CSS if present
                    if (originalCSS) {
                        addAppCSS(originalCSS, appId);
                    }
                    
                    updateAppCount();
                    
                    // Execute JavaScript and restore window state after content is fully rendered
                    setTimeout(() => {
                        try {
                            // Verify that the app content container exists before proceeding
                            const contentContainer = document.getElementById(`content_${appId}`);
                            if (!contentContainer) {
                                throw new Error(`App content container not found: content_${appId}`);
                            }
                            
                            console.log(`App container found: content_${appId}`);
                            
                            // Execute JavaScript if present
                            if (originalJavaScript) {
                                console.log(`Executing JavaScript for app ${appId}`);
                                try {
                                    executeAppJavaScript(originalJavaScript, appId);
                                    console.log(`JavaScript executed successfully for app ${appId}`);
                                } catch (jsError) {
                                    console.error(`JavaScript execution failed for app ${appId}:`, jsError);
                                    // Don't throw here, continue with other setup
                                }
                            }
                            
                            // Restore window position if available
                            if (appData.windowState) {
                                const windowElement = document.getElementById(`window_${appId}`);
                                if (windowElement) {
                                    windowElement.style.left = (appData.windowState.left || 100) + 'px';
                                    windowElement.style.top = (appData.windowState.top || 100) + 'px';
                                    console.log(`Restored window position for app ${appId}`);
                                }
                            } else {
                                // Auto-size and center the window based on content for legacy apps
                                autoSizeAndCenterWindow(appId);
                            }
                            
                            // Apply current theme to the imported app
                            applyThemeToApp(appId);
                            
                            // Update apps submenu to include the imported app
                            updateAppsSubmenuContent();
                            
                            console.log(`App ${appId} loaded successfully`);
                            
                        } catch (setupError) {
                            console.error(`Error during app setup for ${appId}:`, setupError);
                            // Show user-friendly error message
                            const contentContainer = document.getElementById(`content_${appId}`);
                            if (contentContainer) {
                                contentContainer.innerHTML = `
                                    <div style="padding: 20px; text-align: center; color: #dc3545;">
                                        <h3>‚ö†Ô∏è App Load Error</h3>
                                        <p>The app loaded but some features may not work correctly.</p>
                                        <p style="font-size: 12px; color: #666;">Error: ${setupError.message}</p>
                                    </div>
                                `;
                            }
                        }
                        
                    }, 500); // Increased timeout to ensure DOM is ready
                    
                    console.log(`Loaded app: ${appData.title} as ${appId} (version: ${appVersion})`);
                    
                    // Step 3: Ask user if they want to save to persistence
                    setTimeout(async () => {
                        try {
                            const shouldSave = await showCustomConfirm(
                                `Would you like to save "${appData.title}" to persistence? This will allow the app to be automatically restored in future sessions.`,
                                'Save to Persistence'
                            );
                            
                            if (shouldSave) {
                                // Save the app to persistence using the data registry
                                const saveResult = window.dataRegistry.registerApp(appId, {
                                    id: appId,
                                    title: appData.title,
                                    icon: appData.icon || 'üì±',
                                    html: appData.html,
                                    css: appData.css || '',
                                    javascript: appData.javascript || '',
                                    type: appData.type || 'imported',
                                    version: appVersion,
                                    customRequest: appData.customRequest || 'Imported app',
                                    promptHistory: appData.promptHistory || [],
                                    modificationHistory: appData.modificationHistory || [],
                                    lastModification: appData.lastModification || null,
                                    isSystemApp: appData.isSystemApp || false,
                                    generationMode: appData.generationMode || 'SIMPLE',
                                    hasImages: appData.hasImages || false,
                                    imageCount: appData.imageCount || 0,
                                    windowState: appData.windowState || null
                                }, {
                                    description: `Persistent app: ${appData.title}`,
                                    savePrompt: false // Don't show another prompt since we already asked
                                });
                                
                                if (saveResult.saved) {
                                    showCustomAlert(`App "${appData.title}" has been saved to persistence and will be available in future sessions.`, 'Saved to Persistence');
                                } else {
                                    console.log(`User chose not to save "${appData.title}" to persistence`);
                                }
                            } else {
                                console.log(`User chose not to save "${appData.title}" to persistence`);
                            }
                        } catch (error) {
                            console.error('Error during persistence save prompt:', error);
                        }
                    }, 1000); // Wait a bit longer to ensure app is fully loaded
                    
                    // Show success notification
                    showImportNotification(appData.title, appVersion, isLegacyFormat);
                    
                } catch (error) {
                    console.error('Failed to load app:', error);
                    showCustomAlert(`Failed to load app: ${error.message}`, 'Error');
                }
            };
            
            reader.onerror = function() {
                showCustomAlert('Failed to read the file', 'Error');
            };
            
            reader.readAsText(file);
        }

        function replaceAppIdReferences(content, oldAppId, newAppId) {
            if (!content || !oldAppId || !newAppId || oldAppId === newAppId) {
                return content;
            }
            
            let updatedContent = content;
            console.log(`Replacing app ID references: ${oldAppId} ‚Üí ${newAppId}`);
            
            // Escape special regex characters in app IDs
            const escapedOldAppId = oldAppId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const escapedNewAppId = newAppId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            
            // Define replacement patterns with more specific matching
            const replacements = [
                // HTML id attributes: id="oldAppId_something"
                {
                    pattern: new RegExp(`(id=["'])${escapedOldAppId}_([^"']+)(["'])`, 'g'),
                    replacement: `$1${newAppId}_$2$3`,
                    description: 'HTML id attributes'
                },
                // HTML class attributes: class="...oldAppId__something..."
                {
                    pattern: new RegExp(`(class=["'][^"']*\\s?)${escapedOldAppId}__([^"'\\s]+)`, 'g'),
                    replacement: `$1${newAppId}__$2`,
                    description: 'HTML class attributes'
                },
                // CSS selectors: #oldAppId_something
                {
                    pattern: new RegExp(`(#)${escapedOldAppId}_([\\w-]+)`, 'g'),
                    replacement: `$1${newAppId}_$2`,
                    description: 'CSS ID selectors'
                },
                // CSS selectors: .oldAppId__something
                {
                    pattern: new RegExp(`(\\.)${escapedOldAppId}__([\\w-]+)`, 'g'),
                    replacement: `$1${newAppId}__$2`,
                    description: 'CSS class selectors'
                },
                // JavaScript getElementById calls: getElementById('oldAppId_something')
                {
                    pattern: new RegExp(`(getElementById\\(['"])${escapedOldAppId}_([^'"]+)(['"]\\))`, 'g'),
                    replacement: `$1${newAppId}_$2$3`,
                    description: 'JavaScript getElementById calls'
                },
                // JavaScript querySelector calls: querySelector('#oldAppId_something')
                {
                    pattern: new RegExp(`(querySelector\\(['"]#)${escapedOldAppId}_([^'"]+)(['"]\\))`, 'g'),
                    replacement: `$1${newAppId}_$2$3`,
                    description: 'JavaScript querySelector calls'
                },
                // JavaScript querySelectorAll calls: querySelectorAll('#oldAppId_something')
                {
                    pattern: new RegExp(`(querySelectorAll\\(['"]#)${escapedOldAppId}_([^'"]+)(['"]\\))`, 'g'),
                    replacement: `$1${newAppId}_$2$3`,
                    description: 'JavaScript querySelectorAll calls'
                },
                // Content container references: content_oldAppId
                {
                    pattern: new RegExp(`\\bcontent_${escapedOldAppId}\\b`, 'g'),
                    replacement: `content_${newAppId}`,
                    description: 'Content container references'
                },
                // Window references: window_oldAppId
                {
                    pattern: new RegExp(`\\bwindow_${escapedOldAppId}\\b`, 'g'),
                    replacement: `window_${newAppId}`,
                    description: 'Window references'
                },
                // Style element references: style-oldAppId
                {
                    pattern: new RegExp(`\\bstyle-${escapedOldAppId}\\b`, 'g'),
                    replacement: `style-${newAppId}`,
                    description: 'Style element references'
                },
                // Script element references: script-oldAppId
                {
                    pattern: new RegExp(`\\bscript-${escapedOldAppId}\\b`, 'g'),
                    replacement: `script-${newAppId}`,
                    description: 'Script element references'
                },
                // Icon references: icon_oldAppId
                {
                    pattern: new RegExp(`\\bicon_${escapedOldAppId}\\b`, 'g'),
                    replacement: `icon_${newAppId}`,
                    description: 'Icon references'
                },
                // App namespace references: app_oldAppId (with underscores)
                {
                    pattern: new RegExp(`\\bapp_${escapedOldAppId.replace(/-/g, '_')}\\b`, 'g'),
                    replacement: `app_${newAppId.replace(/-/g, '_')}`,
                    description: 'App namespace references'
                }
            ];
            
            // Apply each replacement
            let totalReplacements = 0;
            replacements.forEach(({ pattern, replacement, description }) => {
                const matches = updatedContent.match(pattern);
                if (matches && matches.length > 0) {
                    console.log(`  ${description}: ${matches.length} matches`);
                    updatedContent = updatedContent.replace(pattern, replacement);
                    totalReplacements += matches.length;
                }
            });
            
            console.log(`Total replacements made: ${totalReplacements}`);
            return updatedContent;
        }

        function showImportNotification(appTitle, version, isLegacyFormat) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #007bff;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 10001;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 18px;">üìÅ</span>
                    <div>
                        <div style="font-weight: bold;">App Imported</div>
                        <div style="font-size: 12px; opacity: 0.9;">${appTitle}</div>
                        <div style="font-size: 11px; opacity: 0.7;">
                            Version: ${version}${isLegacyFormat ? ' (upgraded)' : ''}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // Animate out and remove
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function triggerLoadApp() {
            // Create a hidden file input and trigger it
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            fileInput.style.display = 'none';
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadAppFromFile(file);
                }
                // Clean up
                document.body.removeChild(fileInput);
            });
            
            document.body.appendChild(fileInput);
            fileInput.click();
            
            // Close the start menu
            document.getElementById('start-menu').classList.remove('show');
        }



        // Configuration for LLM integration
        const CONFIG = {
            OPENAI_API_KEY: 'sk-proj-...', // Replace with your actual OpenAI API key
            OPENROUTER_API_KEY: 'sk-...', // Replace with your actual OpenRouter API key
            OPENROUTER_URL: 'https://openrouter.ai/api/v1/chat/completions',
            MODEL_SIMPLE: 'google/gemini-2.5-flash-lite-preview-06-17',
            MODEL_TOUGH: 'anthropic/claude-sonnet-4',
            MODEL: 'google/gemini-2.5-flash-lite-preview-06-17', // Will be updated based on mode selection
            CURRENT_LLM_PROVIDER: 'openrouter' // Current LLM provider: 'openrouter', 'openai', or 'lmstudio'
        };

        // Model selection state
        let currentModelMode = 'Simple'; // Default to Simple mode
        let previousModelMode = 'Simple'; // Store previous mode for restoration

        // Global voice recognition settings
        let voiceRecognitionType = 'whisper'; // 'whisper' or 'web'
        
        // Global voice state for Whisper API
        let mediaRecorder = null;
        let audioChunks = [];
        let mediaStream = null;
        
        // Global voice state for Web Speech API
        let webSpeechRecognition = null;
        let isWebSpeechSupported = false;

        // Global cost tracking
        let costTrackingEnabled = true;
        
        // Initialize cost tracking through data registry
        function initializeCostTracking() {
            // Get existing cost history from data registry or create empty array
            let costHistory = window.dataRegistry.getData('cost-history') || [];
            
            // Make costHistory globally accessible for backward compatibility
            window.costHistory = costHistory;
            
            // Update data registry if it was empty
            if (!window.dataRegistry.getData('cost-history')) {
                window.dataRegistry.updateData('cost-history', costHistory);
            }
        }
        
        // Initialize cost tracking
        initializeCostTracking();
        

        // Global debug mode
        let debugMode = false;

        // Debug logging function
        function debugLog(...args) {
            if (debugMode) {
                console.log(...args);
            }
        }

        // Debug warn function
        function debugWarn(...args) {
            if (debugMode) {
                console.warn(...args);
            }
        }

        // Debug error function
        function debugError(...args) {
            if (debugMode) {
                console.error(...args);
            }
        }

        // Setup Assistant Functions
        function startSetupAssistant() {
            const setupContent = `
                <div class="setup-assistant">
                    <div class="setup-header">
                        <h2>üöÄ Welcome to Self-Evolving OS</h2>
                        <p>Let's set up your AI-powered operating system in just a few steps.</p>
                        <div class="setup-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="setup-progress-fill"></div>
                            </div>
                            <span class="progress-text" id="setup-progress-text">Step 1 of 4</span>
                        </div>
                    </div>
                    
                    <div class="setup-content" id="setup-content">
                        <!-- Step content will be dynamically loaded here -->
                    </div>
                    
                    <div class="setup-footer">
                        <button class="setup-btn secondary" id="setup-back" style="display: none;">‚Üê Back</button>
                        <div class="setup-footer-right">
                            <button class="setup-btn secondary" id="setup-skip">Skip Setup</button>
                            <button class="setup-btn primary" id="setup-next">Next ‚Üí</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Create Setup Assistant app
            const setupId = generateAppId();
            const setupApp = {
                id: setupId,
                type: 'system',
                title: 'Setup Assistant',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System Setup Assistant'
            };

            apps.push(setupApp);
            updateSharedAppsRegistry();
            createWindow(setupId, 'Setup Assistant', setupContent, 600, 500);
            createTaskbarIcon(setupId, 'Setup Assistant', 'üõ†Ô∏è');
            updateAppCount();
            
            // Add setup-specific CSS
            addSetupAssistantCSS(setupId);
            
            // Initialize setup assistant
            setTimeout(() => {
                initializeSetupAssistant(setupId);
            }, 100);
        }

        function addSetupAssistantCSS(appId) {
            const setupCSS = `
                .setup-assistant {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                }
                
                .setup-header {
                    padding: 30px 30px 20px 30px;
                    text-align: center;
                    background: white;
                    border-bottom: 1px solid #dee2e6;
                }
                
                .setup-header h2 {
                    margin: 0 0 10px 0;
                    color: #0078d4;
                    font-size: 24px;
                    font-weight: 600;
                }
                
                .setup-header p {
                    margin: 0 0 20px 0;
                    color: #6c757d;
                    font-size: 16px;
                }
                
                .setup-progress {
                    display: flex;
                    align-items: center;
                    gap: 15px;
                }
                
                .progress-bar {
                    flex: 1;
                    height: 8px;
                    background: #e9ecef;
                    border-radius: 4px;
                    overflow: hidden;
                }
                
                .progress-fill {
                    height: 100%;
                    background: linear-gradient(90deg, #0078d4, #106ebe);
                    border-radius: 4px;
                    transition: width 0.3s ease;
                    width: 25%;
                }
                
                .progress-text {
                    font-size: 14px;
                    color: #6c757d;
                    font-weight: 500;
                    min-width: 80px;
                }
                
                .setup-content {
                    flex: 1;
                    padding: 30px;
                    overflow-y: auto;
                }
                
                .setup-step {
                    max-width: 500px;
                    margin: 0 auto;
                }
                
                .setup-step h3 {
                    margin: 0 0 20px 0;
                    color: #333;
                    font-size: 20px;
                    font-weight: 600;
                }
                
                .setup-step p {
                    margin: 0 0 20px 0;
                    color: #6c757d;
                    line-height: 1.6;
                }
                
                .setup-form-group {
                    margin-bottom: 20px;
                }
                
                .setup-form-group label {
                    display: block;
                    margin-bottom: 8px;
                    color: #333;
                    font-weight: 500;
                }
                
                .setup-form-group input,
                .setup-form-group select {
                    width: 100%;
                    padding: 12px;
                    border: 2px solid #e9ecef;
                    border-radius: 6px;
                    font-size: 14px;
                    transition: border-color 0.2s ease;
                }
                
                .setup-form-group input:focus,
                .setup-form-group select:focus {
                    outline: none;
                    border-color: #0078d4;
                }
                
                .setup-form-group .help-text {
                    margin-top: 5px;
                    font-size: 12px;
                    color: #6c757d;
                }
                
                .setup-option-card {
                    border: 2px solid #e9ecef;
                    border-radius: 8px;
                    padding: 20px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
                
                .setup-option-card:hover {
                    border-color: #0078d4;
                    background: #f8f9ff;
                }
                
                .setup-option-card.selected {
                    border-color: #0078d4;
                    background: #e3f2fd;
                }
                
                .setup-option-card h4 {
                    margin: 0 0 8px 0;
                    color: #333;
                    font-size: 16px;
                    font-weight: 600;
                }
                
                .setup-option-card p {
                    margin: 0;
                    color: #6c757d;
                    font-size: 14px;
                }
                
                .setup-test-result {
                    margin-top: 15px;
                    padding: 15px;
                    border-radius: 6px;
                    font-size: 14px;
                }
                
                .setup-test-result.success {
                    background: #d4edda;
                    color: #155724;
                    border: 1px solid #c3e6cb;
                }
                
                .setup-test-result.error {
                    background: #f8d7da;
                    color: #721c24;
                    border: 1px solid #f5c6cb;
                }
                
                .setup-test-result.warning {
                    background: #fff3cd;
                    color: #856404;
                    border: 1px solid #ffeaa7;
                }
                
                .setup-footer {
                    padding: 20px 30px;
                    background: white;
                    border-top: 1px solid #dee2e6;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                
                .setup-footer-right {
                    display: flex;
                    gap: 10px;
                }
                
                .setup-btn {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
                
                .setup-btn.primary {
                    background: #0078d4;
                    color: white;
                }
                
                .setup-btn.primary:hover {
                    background: #106ebe;
                }
                
                .setup-btn.secondary {
                    background: #6c757d;
                    color: white;
                }
                
                .setup-btn.secondary:hover {
                    background: #5a6268;
                }
                
                .setup-btn:disabled {
                    opacity: 0.6;
                    cursor: not-allowed;
                }
            `;
            
            addAppCSS(setupCSS, appId);
        }

        function initializeSetupAssistant(setupId) {
            let currentStep = 1;
            const totalSteps = 4;
            
            const steps = {
                1: createWelcomeStep,
                2: createAIModelStep,
                3: createVoiceAudioStep,
                4: createCompletionStep
            };
            
            function updateProgress() {
                const progressFill = document.getElementById('setup-progress-fill');
                const progressText = document.getElementById('setup-progress-text');
                
                if (progressFill) {
                    progressFill.style.width = `${(currentStep / totalSteps) * 100}%`;
                }
                if (progressText) {
                    progressText.textContent = `Step ${currentStep} of ${totalSteps}`;
                }
            }
            
            function showStep(stepNumber) {
                const content = document.getElementById('setup-content');
                const backBtn = document.getElementById('setup-back');
                const nextBtn = document.getElementById('setup-next');
                const skipBtn = document.getElementById('setup-skip');
                
                if (content && steps[stepNumber]) {
                    content.innerHTML = steps[stepNumber]();
                }
                
                // Update button visibility
                if (backBtn) {
                    backBtn.style.display = stepNumber > 1 ? 'block' : 'none';
                }
                
                if (nextBtn) {
                    nextBtn.textContent = stepNumber === totalSteps ? 'Finish' : 'Next ‚Üí';
                }
                
                if (skipBtn) {
                    skipBtn.style.display = stepNumber === totalSteps ? 'none' : 'block';
                }
                
                updateProgress();
                
                // Add step-specific event listeners
                setTimeout(() => {
                    addStepEventListeners(stepNumber);
                }, 100);
            }
            
            function addStepEventListeners(stepNumber) {
                if (stepNumber === 2) {
                    // AI Model step listeners
                    const providerCards = document.querySelectorAll('.setup-option-card[data-provider]');
                    providerCards.forEach(card => {
                        card.addEventListener('click', () => {
                            providerCards.forEach(c => c.classList.remove('selected'));
                            card.classList.add('selected');
                            
                            const provider = card.dataset.provider;
                            showProviderConfig(provider);
                        });
                    });
                    
                    const testBtn = document.getElementById('test-ai-connection');
                    if (testBtn) {
                        testBtn.addEventListener('click', testAIConnection);
                    }
                } else if (stepNumber === 3) {
                    // Voice & Audio step listeners
                    const voiceCards = document.querySelectorAll('.setup-option-card[data-voice]');
                    voiceCards.forEach(card => {
                        card.addEventListener('click', () => {
                            voiceCards.forEach(c => c.classList.remove('selected'));
                            card.classList.add('selected');
                            
                            const voiceType = card.dataset.voice;
                            showVoiceConfig(voiceType);
                        });
                    });
                    
                    const testMicBtn = document.getElementById('test-microphone-setup');
                    if (testMicBtn) {
                        testMicBtn.addEventListener('click', testMicrophone);
                    }
                    
                    const testVoiceBtn = document.getElementById('test-voice-recognition');
                    if (testVoiceBtn) {
                        testVoiceBtn.addEventListener('click', testVoiceRecognition);
                    }
                }
            }
            
            // Navigation event listeners
            const backBtn = document.getElementById('setup-back');
            const nextBtn = document.getElementById('setup-next');
            const skipBtn = document.getElementById('setup-skip');
            
            if (backBtn) {
                backBtn.addEventListener('click', () => {
                    if (currentStep > 1) {
                        currentStep--;
                        showStep(currentStep);
                    }
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentStep < totalSteps) {
                        if (validateCurrentStep(currentStep)) {
                            saveCurrentStepSettings(currentStep);
                            currentStep++;
                            showStep(currentStep);
                        }
                    } else {
                        // Finish setup
                        finishSetup(setupId);
                    }
                });
            }
            
            if (skipBtn) {
                skipBtn.addEventListener('click', () => {
                    showCustomConfirm('Skip setup? You can configure these settings later in the Settings app.', 'Skip Setup').then(confirmed => {
                        if (confirmed) {
                            finishSetup(setupId);
                        }
                    });
                });
            }
            
            // Start with first step
            showStep(1);
        }

        function createWelcomeStep() {
            return `
                <div class="setup-step">
                    <h3>üéâ Welcome to Self-Evolving OS</h3>
                    <p>This AI-powered operating system can create and modify applications using natural language commands. Let's configure it for your needs.</p>
                    
                    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="margin: 0 0 15px 0; color: #0078d4;">‚ú® What you can do:</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #6c757d;">
                            <li>Create apps by voice: "Create a calculator app"</li>
                            <li>Modify existing apps: "Add a dark mode to this app"</li>
                            <li>Use text commands in the Start menu</li>
                            <li>Download and share your created apps</li>
                        </ul>
                    </div>
                    
                    <div style="background: #fff3cd; padding: 15px; border-radius: 6px; border: 1px solid #ffeaa7;">
                        <strong style="color: #856404;">üìù Note:</strong>
                        <span style="color: #856404;">You'll need API keys for AI services. Don't worry - we'll help you set this up!</span>
                    </div>
                </div>
            `;
        }

        function createAIModelStep() {
            return `
                <div class="setup-step">
                    <h3>ü§ñ AI Model Configuration</h3>
                    <p>Choose your AI provider for app generation. Each has different features and pricing.</p>
                    
                    <div class="setup-option-card" data-provider="openrouter">
                        <h4>üåê OpenRouter (Recommended)</h4>
                        <p>Access to multiple AI models including Claude, GPT-4, and Gemini. Best balance of quality and cost.</p>
                    </div>
                    
                    <div class="setup-option-card" data-provider="openai">
                        <h4>üß† OpenAI API</h4>
                        <p>Direct access to GPT models. Higher quality but more expensive.</p>
                    </div>
                    
                    <div class="setup-option-card" data-provider="lmstudio">
                        <h4>üíª LMStudio (Local)</h4>
                        <p>Run AI models locally on your computer. Free but requires powerful hardware.</p>
                    </div>
                    
                    <div id="provider-config" style="margin-top: 20px;">
                        <!-- Provider-specific configuration will appear here -->
                    </div>
                    
                    <button id="test-ai-connection" class="setup-btn secondary" style="margin-top: 15px;">üß™ Test Connection</button>
                    <div id="ai-test-result"></div>
                </div>
            `;
        }

        function createVoiceAudioStep() {
            return `
                <div class="setup-step">
                    <h3>üé§ Voice & Audio Setup</h3>
                    <p>Configure voice recognition for hands-free app creation and modification.</p>
                    
                    <div class="setup-option-card selected" data-voice="whisper">
                        <h4>üéØ OpenAI Whisper (Recommended)</h4>
                        <p>High-accuracy speech recognition supporting 50+ languages. Requires internet connection.</p>
                    </div>
                    
                    <div class="setup-option-card" data-voice="web">
                        <h4>üåê Web Speech API</h4>
                        <p>Browser-based speech recognition. Free but limited language support and accuracy.</p>
                    </div>
                    
                    <div id="voice-config" style="margin-top: 20px;">
                        <!-- Voice-specific configuration will appear here -->
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="test-microphone-setup" class="setup-btn secondary">üé§ Test Microphone</button>
                        <button id="test-voice-recognition" class="setup-btn secondary">üó£Ô∏è Test Voice Recognition</button>
                    </div>
                    <div id="voice-test-result"></div>
                </div>
            `;
        }

        function createCompletionStep() {
            return `
                <div class="setup-step">
                    <h3>üéâ Setup Complete!</h3>
                    <p>Your Self-Evolving OS is ready to use. Here's what you can do next:</p>
                    
                    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="margin: 0 0 15px 0; color: #0078d4;">üöÄ Quick Start:</h4>
                        <ol style="margin: 0; padding-left: 20px; color: #6c757d;">
                            <li>Click the microphone button and say "Create a calculator app"</li>
                            <li>Or use the Start menu to type your app request</li>
                            <li>Try modifying apps with the voice button in each window</li>
                            <li>Access Settings anytime from the Start menu</li>
                        </ol>
                    </div>
                    
                    <div style="background: #d4edda; padding: 15px; border-radius: 6px; border: 1px solid #c3e6cb;">
                        <strong style="color: #155724;">‚úÖ Configuration Summary:</strong>
                        <div id="setup-summary" style="color: #155724; margin-top: 10px;">
                            <!-- Summary will be populated here -->
                        </div>
                    </div>
                </div>
            `;
        }

        function showProviderConfig(provider) {
            const configDiv = document.getElementById('provider-config');
            if (!configDiv) return;
            
            let configHTML = '';
            
            if (provider === 'openrouter') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-openrouter-key">OpenRouter API Key</label>
                        <input type="password" id="setup-openrouter-key" placeholder="sk-or-v1-...">
                        <div class="help-text">Get your API key from <a href="https://openrouter.ai/keys" target="_blank">openrouter.ai/keys</a></div>
                    </div>
                `;
            } else if (provider === 'openai') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-openai-key">OpenAI API Key</label>
                        <input type="password" id="setup-openai-key" placeholder="sk-...">
                        <div class="help-text">Get your API key from <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com/api-keys</a></div>
                    </div>
                `;
            } else if (provider === 'lmstudio') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-lmstudio-url">LMStudio Server URL</label>
                        <input type="url" id="setup-lmstudio-url" value="http://localhost:1234/v1/chat/completions">
                        <div class="help-text">Make sure LMStudio is running with a loaded model and server enabled</div>
                    </div>
                `;
            }
            
            configDiv.innerHTML = configHTML;
        }

        function showVoiceConfig(voiceType) {
            const configDiv = document.getElementById('voice-config');
            if (!configDiv) return;
            
            let configHTML = '';
            
            if (voiceType === 'whisper') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-whisper-key">OpenAI API Key (for Whisper)</label>
                        <input type="password" id="setup-whisper-key" placeholder="sk-proj-...">
                        <div class="help-text">Same as OpenAI API key. Get it from <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com/api-keys</a></div>
                    </div>
                `;
            } else if (voiceType === 'web') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-web-speech-lang">Language</label>
                        <select id="setup-web-speech-lang">
                            <option value="en-US">English (United States)</option>
                            <option value="en-GB">English (United Kingdom)</option>
                            <option value="es-ES">Spanish (Spain)</option>
                            <option value="fr-FR">French (France)</option>
                            <option value="de-DE">German (Germany)</option>
                            <option value="it-IT">Italian (Italy)</option>
                            <option value="pt-BR">Portuguese (Brazil)</option>
                            <option value="ru-RU">Russian (Russia)</option>
                            <option value="ja-JP">Japanese (Japan)</option>
                            <option value="zh-CN">Chinese (Mandarin)</option>
                        </select>
                        <div class="help-text">Choose your preferred language for voice recognition</div>
                    </div>
                `;
            }
            
            configDiv.innerHTML = configHTML;
        }

        async function testAIConnection() {
            const resultDiv = document.getElementById('ai-test-result');
            if (!resultDiv) return;
            
            const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
            if (!selectedProvider) {
                resultDiv.innerHTML = '<div class="setup-test-result error">Please select an AI provider first.</div>';
                return;
            }
            
            const provider = selectedProvider.dataset.provider;
            resultDiv.innerHTML = '<div class="setup-test-result warning">Testing connection...</div>';
            
            try {
                let apiKey = '';
                let apiUrl = '';
                
                if (provider === 'openrouter') {
                    apiKey = document.getElementById('setup-openrouter-key')?.value;
                    apiUrl = 'https://openrouter.ai/api/v1/chat/completions';
                } else if (provider === 'openai') {
                    apiKey = document.getElementById('setup-openai-key')?.value;
                    apiUrl = 'https://api.openai.com/v1/chat/completions';
                } else if (provider === 'lmstudio') {
                    apiUrl = document.getElementById('setup-lmstudio-url')?.value || 'http://localhost:1234/v1/chat/completions';
                    apiKey = 'not-needed';
                }
                
                if (!apiKey && provider !== 'lmstudio') {
                    resultDiv.innerHTML = '<div class="setup-test-result error">Please enter your API key.</div>';
                    return;
                }
                
                let headers = {
                    'Content-Type': 'application/json'
                };
                
                // Only add Authorization header for providers that need it
                if (provider !== 'lmstudio') {
                    headers['Authorization'] = `Bearer ${apiKey}`;
                }
                
                // Add OpenRouter-specific headers
                if (provider === 'openrouter') {
                    headers['HTTP-Referer'] = window.location.origin;
                    headers['X-Title'] = 'Self-Evolving OS Setup';
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        model: provider === 'openrouter' ? 'google/gemini-2.5-flash-lite-preview-06-17' :
                               provider === 'openai' ? 'gpt-4o-mini' : 'llama-3.2-3b-instruct',
                        messages: [{ role: 'user', content: 'Hello! This is a test message.' }],
                        ...(provider === 'openai' ?
                            { max_completion_tokens: 50, temperature: 1 } :
                            { max_tokens: 50, temperature: 0.5 })
                    })
                });
                
                if (response.ok) {
                    resultDiv.innerHTML = '<div class="setup-test-result success">‚úÖ Connection successful! AI provider is working correctly.</div>';
                } else {
                    const errorText = await response.text();
                    resultDiv.innerHTML = `<div class="setup-test-result error">‚ùå Connection failed: ${response.status} - ${errorText}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="setup-test-result error">‚ùå Connection failed: ${error.message}</div>`;
            }
        }

        async function testVoiceRecognition() {
            const resultDiv = document.getElementById('voice-test-result');
            if (!resultDiv) return;
            
            const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
            if (!selectedVoice) {
                resultDiv.innerHTML = '<div class="setup-test-result error">Please select a voice recognition method first.</div>';
                return;
            }
            
            const voiceType = selectedVoice.dataset.voice;
            resultDiv.innerHTML = '<div class="setup-test-result warning">üé§ Say something to test voice recognition...</div>';
            
            try {
                if (voiceType === 'web') {
                    // Test Web Speech API
                    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">‚ùå Web Speech API not supported in this browser.</div>';
                        return;
                    }
                    
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognition = new SpeechRecognition();
                    recognition.continuous = false;
                    recognition.interimResults = false;
                    recognition.lang = document.getElementById('setup-web-speech-lang')?.value || 'en-US';
                    
                    recognition.onresult = function(event) {
                        const transcript = event.results[0][0].transcript;
                        resultDiv.innerHTML = `<div class="setup-test-result success">‚úÖ Voice recognition working! You said: "${transcript}"</div>`;
                    };
                    
                    recognition.onerror = function(event) {
                        resultDiv.innerHTML = `<div class="setup-test-result error">‚ùå Voice recognition error: ${event.error}</div>`;
                    };
                    
                    recognition.start();
                    
                } else if (voiceType === 'whisper') {
                    // Test Whisper API
                    const apiKey = document.getElementById('setup-whisper-key')?.value;
                    if (!apiKey) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">Please enter your OpenAI API key first.</div>';
                        return;
                    }
                    
                    // Request microphone access for Whisper test
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        resultDiv.innerHTML = '<div class="setup-test-result success">‚úÖ Microphone access granted! Whisper API key will be tested when you create your first app.</div>';
                        stream.getTracks().forEach(track => track.stop());
                    } catch (error) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">‚ùå Microphone access denied. Please allow microphone access for voice recognition.</div>';
                    }
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="setup-test-result error">‚ùå Voice test failed: ${error.message}</div>`;
            }
        }

        function validateCurrentStep(stepNumber) {
            if (stepNumber === 2) {
                // Validate AI Model step
                const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
                if (!selectedProvider) {
                    showCustomAlert('Please select an AI provider.', 'Setup Required');
                    return false;
                }
                
                const provider = selectedProvider.dataset.provider;
                if (provider === 'openrouter') {
                    const apiKey = document.getElementById('setup-openrouter-key')?.value;
                    if (!apiKey) {
                        showCustomAlert('Please enter your OpenRouter API key.', 'Setup Required');
                        return false;
                    }
                } else if (provider === 'openai') {
                    const apiKey = document.getElementById('setup-openai-key')?.value;
                    if (!apiKey) {
                        showCustomAlert('Please enter your OpenAI API key.', 'Setup Required');
                        return false;
                    }
                }
            } else if (stepNumber === 3) {
                // Validate Voice & Audio step
                const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
                if (!selectedVoice) {
                    showCustomAlert('Please select a voice recognition method.', 'Setup Required');
                    return false;
                }
                
                const voiceType = selectedVoice.dataset.voice;
                if (voiceType === 'whisper') {
                    const apiKey = document.getElementById('setup-whisper-key')?.value;
                    if (!apiKey) {
                        showCustomAlert('Please enter your OpenAI API key for Whisper.', 'Setup Required');
                        return false;
                    }
                }
            }
            return true;
        }

        function saveCurrentStepSettings(stepNumber) {
            if (stepNumber === 2) {
                // Save AI Model settings
                const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
                if (selectedProvider) {
                    const provider = selectedProvider.dataset.provider;
                    
                    if (provider === 'openrouter') {
                        const apiKey = document.getElementById('setup-openrouter-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENROUTER_API_KEY = apiKey;
                            CONFIG.CURRENT_LLM_PROVIDER = 'openrouter';
                        }
                    } else if (provider === 'openai') {
                        const apiKey = document.getElementById('setup-openai-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENROUTER_API_KEY = apiKey; // Reuse same config key
                            CONFIG.OPENROUTER_URL = 'https://api.openai.com/v1/chat/completions';
                            CONFIG.CURRENT_LLM_PROVIDER = 'openai';
                        }
                    } else if (provider === 'lmstudio') {
                        const url = document.getElementById('setup-lmstudio-url')?.value;
                        if (url) {
                            CONFIG.OPENROUTER_API_KEY = 'not-needed';
                            CONFIG.OPENROUTER_URL = url;
                            CONFIG.CURRENT_LLM_PROVIDER = 'lmstudio';
                        }
                    }
                }
            } else if (stepNumber === 3) {
                // Save Voice & Audio settings
                const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
                if (selectedVoice) {
                    const voiceType = selectedVoice.dataset.voice;
                    voiceRecognitionType = voiceType;
                    
                    if (voiceType === 'whisper') {
                        const apiKey = document.getElementById('setup-whisper-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENAI_API_KEY = apiKey;
                        }
                    }
                }
            }
        }

        function finishSetup(setupId) {
            // Create final settings object and save to cookie
            const settings = {
                // Appearance Settings
                theme: 'light',
                
                // Voice & Audio Settings
                voiceRecognitionType: voiceRecognitionType,
                webSpeechLanguage: document.getElementById('setup-web-speech-lang')?.value || 'en-US',
                
                // AI Model Settings - Voice Recognition
                openaiWhisperKey: CONFIG.OPENAI_API_KEY || '',
                openaiWhisperUrl: 'https://api.openai.com/v1/audio/transcriptions',
                
                // AI Model Settings - Code Generation
                llmProvider: CONFIG.CURRENT_LLM_PROVIDER || 'openrouter',
                
                // Provider-specific settings
                openrouterApiKey: CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' ? CONFIG.OPENROUTER_API_KEY : '',
                openrouterUrl: CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' ? CONFIG.OPENROUTER_URL : 'https://openrouter.ai/api/v1/chat/completions',
                openrouterSimpleModel: 'google/gemini-2.5-flash-lite-preview-06-17',
                openrouterToughModel: 'anthropic/claude-sonnet-4',
                
                openaiApiKey: CONFIG.CURRENT_LLM_PROVIDER === 'openai' ? CONFIG.OPENROUTER_API_KEY : '',
                openaiUrl: CONFIG.CURRENT_LLM_PROVIDER === 'openai' ? CONFIG.OPENROUTER_URL : 'https://api.openai.com/v1/chat/completions',
                openaiSimpleModel: 'gpt-4o-mini',
                openaiToughModel: 'gpt-4o',
                
                lmstudioUrl: CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio' ? CONFIG.OPENROUTER_URL : 'http://localhost:1234/v1/chat/completions',
                lmstudioSimpleModel: 'llama-3.2-3b-instruct',
                lmstudioToughModel: 'llama-3.1-8b-instruct',
                
                // AI Model Settings - General
                apiTimeout: 30,
                maxRetries: 3,
                costTracking: true,
                
                // System Settings
                debugMode: false,
                performanceMode: false,
                autoCleanup: true,
                
                // Metadata
                version: '2.0.0',
                lastSaved: new Date().toISOString()
            };
            
            // Save settings to cookie
            const expires = new Date();
            expires.setFullYear(expires.getFullYear() + 1);
            document.cookie = `selfEvolvingOS_settings=${encodeURIComponent(JSON.stringify(settings))}; expires=${expires.toUTCString()}; path=/`;
            
            // Apply settings to system
            applySettingsToSystem(settings);
            
            // Update summary in completion step
            const summaryDiv = document.getElementById('setup-summary');
            if (summaryDiv) {
                summaryDiv.innerHTML = `
                    <div>ü§ñ AI Provider: ${CONFIG.CURRENT_LLM_PROVIDER || 'OpenRouter'}</div>
                    <div>üé§ Voice Recognition: ${voiceRecognitionType === 'web' ? 'Web Speech API' : 'OpenAI Whisper'}</div>
                    <div>üé® Theme: Light Mode</div>
                `;
            }
            
            // Initialize voice system with new settings
            setTimeout(async () => {
                try {
                    await initializeVoice();
                    console.log('Voice system initialized with setup settings');
                } catch (error) {
                    console.warn('Voice initialization failed during setup:', error);
                }
            }, 1000);
            
            console.log('Setup completed successfully!', settings);
            
            // Show completion message and close setup after delay
            setTimeout(() => {
                showCustomAlert('üéâ Setup completed! Your Self-Evolving OS is ready to use. Try saying "Create a calculator app" or use the Start menu.', 'Setup Complete');
                closeWindow(setupId);
            }, 2000);
        }

        // Settings persistence functions
        function saveSettingsToCookie() {
            const settings = {
                // Appearance Settings
                theme: document.getElementById('theme')?.value ?? 'light',
                
                // Voice & Audio Settings
                voiceRecognitionType: document.getElementById('voice-recognition-type')?.value ?? 'whisper',
                webSpeechLanguage: document.getElementById('web-speech-language')?.value ?? 'en-US',
                
                // AI Model Settings - Voice Recognition
                openaiWhisperKey: document.getElementById('openai-whisper-key')?.value ?? '',
                openaiWhisperUrl: document.getElementById('openai-whisper-url')?.value ?? 'https://api.openai.com/v1/audio/transcriptions',
                
                // AI Model Settings - Code Generation
                llmProvider: document.getElementById('llm-provider')?.value ?? 'openrouter',
                
                // OpenRouter settings
                openrouterApiKey: document.getElementById('openrouter-api-key')?.value ?? '',
                openrouterUrl: document.getElementById('openrouter-url')?.value ?? 'https://openrouter.ai/api/v1/chat/completions',
                openrouterSimpleModel: document.getElementById('openrouter-simple-model')?.value ?? 'google/gemini-2.5-flash-lite-preview-06-17',
                openrouterToughModel: document.getElementById('openrouter-tough-model')?.value ?? 'anthropic/claude-sonnet-4',
                
                // OpenAI settings
                openaiApiKey: document.getElementById('openai-api-key')?.value ?? '',
                openaiUrl: document.getElementById('openai-url')?.value ?? 'https://api.openai.com/v1/chat/completions',
                openaiSimpleModel: document.getElementById('openai-simple-model')?.value ?? 'gpt-4o-mini',
                openaiToughModel: document.getElementById('openai-tough-model')?.value ?? 'gpt-4o',
                
                // LMStudio settings
                lmstudioUrl: document.getElementById('lmstudio-url')?.value ?? 'http://localhost:1234/v1/chat/completions',
                lmstudioSimpleModel: document.getElementById('lmstudio-simple-model')?.value ?? 'llama-3.2-3b-instruct',
                lmstudioToughModel: document.getElementById('lmstudio-tough-model')?.value ?? 'llama-3.1-8b-instruct',
                
                // AI Model Settings - General
                apiTimeout: parseInt(document.getElementById('api-timeout')?.value) ?? 30,
                maxRetries: parseInt(document.getElementById('max-retries')?.value) ?? 3,
                costTracking: document.getElementById('cost-tracking')?.checked ?? true,
                
                // System Settings
                debugMode: document.getElementById('debug-mode')?.checked ?? false,
                performanceMode: document.getElementById('performance-mode')?.checked ?? false,
                autoCleanup: document.getElementById('auto-cleanup')?.checked ?? true,
                
                // Metadata
                version: '2.0.0',
                lastSaved: new Date().toISOString()
            };
            
            // Save to cookie (expires in 1 year)
            const expires = new Date();
            expires.setFullYear(expires.getFullYear() + 1);
            document.cookie = `selfEvolvingOS_settings=${encodeURIComponent(JSON.stringify(settings))}; expires=${expires.toUTCString()}; path=/`;
            
            console.log('Settings saved to cookie:', settings);
            return settings;
        }

        function loadSettingsFromCookie() {
            try {
                const cookies = document.cookie.split(';');
                const settingsCookie = cookies.find(cookie => cookie.trim().startsWith('selfEvolvingOS_settings='));
                
                if (settingsCookie) {
                    const settingsJson = decodeURIComponent(settingsCookie.split('=')[1]);
                    const settings = JSON.parse(settingsJson);
                    console.log('Settings loaded from cookie:', settings);
                    return settings;
                }
            } catch (error) {
                console.warn('Failed to load settings from cookie:', error);
            }
            
            return null;
        }

        function applySettingsToUI(settings) {
            if (!settings) return;
            
            try {
                // Appearance Settings
                const theme = document.getElementById('theme');
                if (theme) theme.value = settings.theme ?? 'light';
                
                // General Settings
                const clockFormat = document.getElementById('clock-format');
                if (clockFormat) clockFormat.value = settings.clockFormat ?? '24';
                
                // Voice & Audio Settings
                const voiceRecognitionTypeEl = document.getElementById('voice-recognition-type');
                if (voiceRecognitionTypeEl) {
                    voiceRecognitionTypeEl.value = settings.voiceRecognitionType ?? 'whisper';
                    // Update global variable
                    voiceRecognitionType = settings.voiceRecognitionType ?? 'whisper';
                }
                
                const webSpeechLanguage = document.getElementById('web-speech-language');
                if (webSpeechLanguage) webSpeechLanguage.value = settings.webSpeechLanguage ?? 'en-US';
                
                // AI Model Settings - Voice Recognition
                const openaiWhisperKey = document.getElementById('openai-whisper-key');
                if (openaiWhisperKey) openaiWhisperKey.value = settings.openaiWhisperKey ?? '';
                
                const openaiWhisperUrl = document.getElementById('openai-whisper-url');
                if (openaiWhisperUrl) openaiWhisperUrl.value = settings.openaiWhisperUrl ?? 'https://api.openai.com/v1/audio/transcriptions';
                
                // AI Model Settings - Code Generation
                const llmProvider = document.getElementById('llm-provider');
                if (llmProvider) llmProvider.value = settings.llmProvider ?? 'openrouter';
                
                // OpenRouter settings
                const openrouterApiKey = document.getElementById('openrouter-api-key');
                if (openrouterApiKey) openrouterApiKey.value = settings.openrouterApiKey ?? '';
                
                const openrouterUrl = document.getElementById('openrouter-url');
                if (openrouterUrl) openrouterUrl.value = settings.openrouterUrl ?? 'https://openrouter.ai/api/v1/chat/completions';
                
                const openrouterSimpleModel = document.getElementById('openrouter-simple-model');
                if (openrouterSimpleModel) openrouterSimpleModel.value = settings.openrouterSimpleModel ?? 'google/gemini-2.5-flash-lite-preview-06-17';
                
                const openrouterToughModel = document.getElementById('openrouter-tough-model');
                if (openrouterToughModel) openrouterToughModel.value = settings.openrouterToughModel ?? 'anthropic/claude-sonnet-4';
                
                // OpenAI settings
                const openaiApiKey = document.getElementById('openai-api-key');
                if (openaiApiKey) openaiApiKey.value = settings.openaiApiKey ?? '';
                
                const openaiUrl = document.getElementById('openai-url');
                if (openaiUrl) openaiUrl.value = settings.openaiUrl ?? 'https://api.openai.com/v1/chat/completions';
                
                const openaiSimpleModel = document.getElementById('openai-simple-model');
                if (openaiSimpleModel) openaiSimpleModel.value = settings.openaiSimpleModel ?? 'gpt-4o-mini';
                
                const openaiToughModel = document.getElementById('openai-tough-model');
                if (openaiToughModel) openaiToughModel.value = settings.openaiToughModel ?? 'gpt-4o';
                
                // LMStudio settings
                const lmstudioUrl = document.getElementById('lmstudio-url');
                if (lmstudioUrl) lmstudioUrl.value = settings.lmstudioUrl ?? 'http://localhost:1234/v1/chat/completions';
                
                const lmstudioSimpleModel = document.getElementById('lmstudio-simple-model');
                if (lmstudioSimpleModel) lmstudioSimpleModel.value = settings.lmstudioSimpleModel ?? 'llama-3.2-3b-instruct';
                
                const lmstudioToughModel = document.getElementById('lmstudio-tough-model');
                if (lmstudioToughModel) lmstudioToughModel.value = settings.lmstudioToughModel ?? 'llama-3.1-8b-instruct';
                
                // AI Model Settings - General
                const apiTimeout = document.getElementById('api-timeout');
                if (apiTimeout) apiTimeout.value = settings.apiTimeout ?? 30;
                
                const maxRetries = document.getElementById('max-retries');
                if (maxRetries) maxRetries.value = settings.maxRetries ?? 3;
                
                const costTracking = document.getElementById('cost-tracking');
                if (costTracking) costTracking.checked = settings.costTracking ?? true;
                
                // System Settings
                const debugMode = document.getElementById('debug-mode');
                if (debugMode) debugMode.checked = settings.debugMode ?? false;
                
                const performanceMode = document.getElementById('performance-mode');
                if (performanceMode) performanceMode.checked = settings.performanceMode ?? false;
                
                const autoCleanup = document.getElementById('auto-cleanup');
                if (autoCleanup) autoCleanup.checked = settings.autoCleanup ?? true;
                
                console.log('Settings applied to UI successfully');
                
            } catch (error) {
                console.error('Error applying settings to UI:', error);
            }
        }

        function applyTheme(theme) {
            // Remove existing theme classes
            document.body.classList.remove('light-theme', 'dark-theme');
            
            // Apply new theme class
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
            } else {
                document.body.classList.add('light-theme');
            }
            
            // Apply theme to all existing apps
            applyThemeToAllApps(theme);
            
            console.log(`Theme applied: ${theme}`);
        }

        function applyThemeToApp(appId) {
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            const contentElement = document.getElementById(`content_${appId}`);
            
            if (contentElement) {
                // Remove existing theme classes
                contentElement.classList.remove('app-light-theme', 'app-dark-theme');
                
                // Apply current theme class
                if (currentTheme === 'dark') {
                    contentElement.classList.add('app-dark-theme');
                } else {
                    contentElement.classList.add('app-light-theme');
                }
                
                console.log(`Theme ${currentTheme} applied to app ${appId}`);
            }
        }

        function applyThemeToAllApps(theme) {
            // Apply theme to all existing app content areas
            const allAppContents = document.querySelectorAll('[id^="content_"]');
            
            allAppContents.forEach(contentElement => {
                // Remove existing theme classes
                contentElement.classList.remove('app-light-theme', 'app-dark-theme');
                
                // Apply new theme class
                if (theme === 'dark') {
                    contentElement.classList.add('app-dark-theme');
                } else {
                    contentElement.classList.add('app-light-theme');
                }
            });
            
            console.log(`Theme ${theme} applied to ${allAppContents.length} existing apps`);
        }

        // App visibility event system
        function dispatchAppShownEvent(appId) {
            const event = new CustomEvent('appShown', {
                detail: { appId: appId }
            });
            document.dispatchEvent(event);
            debugLog(`App shown event dispatched for app: ${appId}`);
        }

        function applySettingsToSystem(settings) {
            if (!settings) return;
            
            try {
                // Apply theme
                if (settings.theme) {
                    applyTheme(settings.theme);
                }
                
                // Apply voice recognition type to global variable
                if (settings.voiceRecognitionType) {
                    voiceRecognitionType = settings.voiceRecognitionType;
                }
                
                // Apply API settings to CONFIG
                if (settings.openaiWhisperKey) {
                    CONFIG.OPENAI_API_KEY = settings.openaiWhisperKey;
                }
                
                // Apply LLM provider settings based on selected provider
                const currentProvider = settings.llmProvider || 'openrouter';
                
                if (currentProvider === 'openrouter') {
                    if (settings.openrouterApiKey) CONFIG.OPENROUTER_API_KEY = settings.openrouterApiKey;
                    if (settings.openrouterUrl) CONFIG.OPENROUTER_URL = settings.openrouterUrl;
                    if (settings.openrouterSimpleModel) CONFIG.MODEL_SIMPLE = settings.openrouterSimpleModel;
                    if (settings.openrouterToughModel) CONFIG.MODEL_TOUGH = settings.openrouterToughModel;
                } else if (currentProvider === 'openai') {
                    if (settings.openaiApiKey) CONFIG.OPENROUTER_API_KEY = settings.openaiApiKey; // Reuse the same config key
                    if (settings.openaiUrl) CONFIG.OPENROUTER_URL = settings.openaiUrl; // Reuse the same config key
                    if (settings.openaiSimpleModel) CONFIG.MODEL_SIMPLE = settings.openaiSimpleModel;
                    if (settings.openaiToughModel) CONFIG.MODEL_TOUGH = settings.openaiToughModel;
                } else if (currentProvider === 'lmstudio') {
                    CONFIG.OPENROUTER_API_KEY = 'not-needed'; // LMStudio doesn't need API key
                    if (settings.lmstudioUrl) CONFIG.OPENROUTER_URL = settings.lmstudioUrl; // Reuse the same config key
                    if (settings.lmstudioSimpleModel) CONFIG.MODEL_SIMPLE = settings.lmstudioSimpleModel;
                    if (settings.lmstudioToughModel) CONFIG.MODEL_TOUGH = settings.lmstudioToughModel;
                }
                
                // Store current provider in CONFIG
                CONFIG.CURRENT_LLM_PROVIDER = currentProvider;
                
                // Update CONFIG.MODEL to match the current mode with the new provider-specific models
                if (currentModelMode === 'Simple') {
                    CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                } else {
                    CONFIG.MODEL = CONFIG.MODEL_TOUGH;
                }
                
                // Update the provider display in the header
                updateProviderDisplay();
                
                // Apply cost tracking setting
                if (settings.costTracking !== undefined) {
                    costTrackingEnabled = settings.costTracking;
                    
                    // Update shared data registry (if available)
                    if (typeof setSharedData === 'function') {
                        setSharedData('cost-tracking-enabled', costTrackingEnabled);
                    }
                    
                    // Cost tracking app is now handled in the unified "All Apps" submenu
                }
                
                // Apply API timeout and max retries to CONFIG
                if (settings.apiTimeout) {
                    CONFIG.API_TIMEOUT = settings.apiTimeout * 1000; // Convert to milliseconds
                }
                
                if (settings.maxRetries) {
                    CONFIG.MAX_RETRIES = settings.maxRetries;
                }
                
                // Apply debug mode setting
                if (settings.debugMode !== undefined) {
                    debugMode = settings.debugMode;
                }
                
                if (debugMode) {
                    console.log('Settings applied to system successfully');
                    console.log('Updated CONFIG:', CONFIG);
                    console.log('Debug mode:', debugMode);
                }
                
            } catch (error) {
                console.error('Error applying settings to system:', error);
            }
        }

        // Cost tracking functions
        function addCostEntry(cost, description, prompt = '') {
            if (!costTrackingEnabled) return;
            
            const entry = {
                timestamp: new Date().toISOString(),
                cost: parseFloat(cost),
                description: description,
                prompt: prompt.substring(0, 200) + (prompt.length > 200 ? '...' : '') // Limit prompt length
            };
            
            // Get current cost history from data registry
            let costHistory = window.dataRegistry.getData('cost-history') || [];
            costHistory.push(entry);
            
            // Update data registry (this will notify all subscribers)
            window.dataRegistry.updateData('cost-history', costHistory);
            
            // Update global window reference for backward compatibility
            window.costHistory = costHistory;
            
            // Save to localStorage for persistence
            localStorage.setItem('costHistory', JSON.stringify(costHistory));
            
            debugLog('Cost entry added:', entry);
        }

        function loadCostHistory() {
            try {
                const saved = localStorage.getItem('costHistory');
                if (saved) {
                    const costHistory = JSON.parse(saved);
                    // Update data registry
                    window.dataRegistry.updateData('cost-history', costHistory);
                    // Update global window reference for backward compatibility
                    window.costHistory = costHistory;
                }
            } catch (error) {
                debugWarn('Failed to load cost history:', error);
                const costHistory = [];
                // Update data registry
                window.dataRegistry.updateData('cost-history', costHistory);
                // Update global window reference for backward compatibility
                window.costHistory = costHistory;
            }
        }




        function getHighestZIndex() {
            const windows = document.querySelectorAll('.window');
            let highest = 0;
            windows.forEach(window => {
                const zIndex = parseInt(window.style.zIndex) || 0;
                if (zIndex > highest) {
                    highest = zIndex;
                }
            });
            return highest;
        }


        function clearCostHistory() {
            showCustomConfirm('Are you sure you want to clear all cost history? This action cannot be undone.', 'Clear History').then(confirmed => {
                if (confirmed) {
                    const costHistory = [];
                
                // Update data registry (this will notify all subscribers)
                window.dataRegistry.updateData('cost-history', costHistory);
                
                // Update global window reference for backward compatibility
                window.costHistory = costHistory;
                localStorage.removeItem('costHistory');
                
                // Update status bar
                const costElement = document.getElementById('api-cost');
                if (costElement) {
                    costElement.textContent = '0.00';
                }
                
                // Reset total cost
                totalCost = 0;
                
                showCustomAlert('Cost history cleared successfully! Cost Tracking apps will automatically refresh.', 'Success');
                }
            });
        }
        
        // Make clearCostHistory globally accessible for generated apps
        window.clearCostHistory = clearCostHistory;

        // Global function for apps to load cost data
        function loadCostData() {
            // This function can be called by generated apps to get fresh cost data
            // Get current cost history from data registry
            const costHistory = window.dataRegistry.getData('cost-history') || [];
            const totalCost = costHistory.reduce((sum, entry) => sum + entry.cost, 0);
            return {
                costHistory: costHistory,
                totalCost: totalCost,
                callCount: costHistory.length
            };
        }
        
        // Make loadCostData globally accessible for generated apps
        window.loadCostData = loadCostData;

        // Debug function to check cost data state
        function debugCostData() {
            console.log('=== COST DATA DEBUG ===');
            console.log('costTrackingEnabled:', costTrackingEnabled);
            console.log('costHistory length:', costHistory.length);
            console.log('costHistory:', costHistory);
            console.log('window.costHistory:', window.costHistory);
            console.log('totalCost:', totalCost);
            console.log('localStorage costHistory:', localStorage.getItem('costHistory'));
            console.log('======================');
        }
        
        // Make debug function globally accessible
        window.debugCostData = debugCostData;

        // Test function to add a sample cost entry for debugging
        function addTestCostEntry() {
            addCostEntry(0.0025, 'Test Entry', 'This is a test cost entry for debugging');
            console.log('Test cost entry added. Total entries:', costHistory.length);
            debugCostData();
        }
        
        // Make test function globally accessible
        window.addTestCostEntry = addTestCostEntry;

        // Apps Sub-menu Functions
        let appsSubmenuTimeout = null;

        function showAppsSubmenu() {
            if (appsSubmenuTimeout) {
                clearTimeout(appsSubmenuTimeout);
                appsSubmenuTimeout = null;
            }
            
            const submenu = document.getElementById('apps-submenu');
            if (submenu) {
                updateAppsSubmenuContent();
                submenu.classList.add('show');
            }
        }

        function toggleAppsSubmenu() {
            const submenu = document.getElementById('apps-submenu');
            if (submenu) {
                if (submenu.classList.contains('show')) {
                    hideAppsSubmenu();
                } else {
                    showAppsSubmenu();
                }
            }
        }

        function hideAppsSubmenuDelayed() {
            appsSubmenuTimeout = setTimeout(() => {
                const submenu = document.getElementById('apps-submenu');
                if (submenu) {
                    submenu.classList.remove('show');
                }
            }, 300); // 300ms delay
        }

        function normalizeAppIconsAndTitles(apps) {
            return apps.map(app => {
                // Check if title starts with an emoji
                const emojiMatch = app.title.match(/^([\u{1F000}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])\s*(.+)$/u);
                
                if (emojiMatch) {
                    // Extract emoji and clean title
                    const emoji = emojiMatch[1];
                    const cleanTitle = emojiMatch[2].trim();
                    
                    return {
                        ...app,
                        title: cleanTitle,
                        icon: app.icon || emoji
                    };
                } else {
                    // Title is already clean, ensure icon exists
                    return {
                        ...app,
                        icon: app.icon || 'üì±'
                    };
                }
            });
        }

        function normalizeAllApps() {
            // Normalize all apps in the main apps array
            const normalizedApps = normalizeAppIconsAndTitles(apps);
            
            // Update the apps array in place
            for (let i = 0; i < apps.length; i++) {
                apps[i] = normalizedApps[i];
            }
            
            console.log('Normalized all apps:', apps.map(app => ({ title: app.title, icon: app.icon })));
        }

        function updateAppsSubmenuContent() {
            const content = document.getElementById('apps-submenu-content');
            if (!content) return;

            // Clear existing content
            content.innerHTML = '';

            // First normalize all apps in the main array
            normalizeAllApps();

            // Get all real apps (now normalized)
            const allApps = [...apps];
            
            // Add persistent apps that are not currently running
            const persistentApps = getPersistentApps();
            persistentApps.forEach(persistentApp => {
                const hasRunningApp = allApps.some(app =>
                    app.id === persistentApp.appId ||
                    app.title === persistentApp.title
                );
                
                // Check if this is a system app that shouldn't be duplicated
                const isSystemApp = Object.keys(SYSTEM_APPS_DEFINITIONS).includes(persistentApp.title);
                
                if (!hasRunningApp && !isSystemApp) {
                    allApps.push({
                        id: persistentApp.appId,
                        title: persistentApp.title,
                        icon: persistentApp.icon || 'üì±',
                        isPersistentApp: true,
                        type: 'persistent',
                        persistentData: persistentApp
                    });
                    console.log(`Added persistent app: ${persistentApp.title}`);
                } else if (isSystemApp) {
                    console.log(`Skipped persistent system app: ${persistentApp.title} (system app placeholder will be used)`);
                }
            });
            
            // Add system app placeholders from SYSTEM_APPS_DEFINITIONS for apps that don't exist yet
            console.log('All apps titles:', allApps.map(app => app.title));
            
            Object.keys(SYSTEM_APPS_DEFINITIONS).forEach(appName => {
                const appDefinition = SYSTEM_APPS_DEFINITIONS[appName];
                const hasRealApp = allApps.some(app =>
                    app.title === appName ||
                    app.title === `${appDefinition.icon} ${appName}`
                );
                
                console.log(`Has real ${appName} app:`, hasRealApp);
                
                if (!hasRealApp) {
                    allApps.push({
                        id: `system-${appName.toLowerCase().replace(/\s+/g, '-')}`,
                        title: appName,
                        icon: appDefinition.icon,
                        isSystemApp: true,
                        type: 'system'
                    });
                    console.log(`Added ${appName} placeholder`);
                }
            });

            // Sort apps alphabetically by title
            allApps.sort((a, b) => {
                const titleA = a.title.replace(/^[^\w]+/, ''); // Remove emoji/symbols for sorting
                const titleB = b.title.replace(/^[^\w]+/, '');
                return titleA.localeCompare(titleB);
            });

            // Create menu items for each app
            allApps.forEach(app => {
                const item = document.createElement('div');
                item.className = 'apps-submenu-item';
                
                // Create icon and title elements (now simplified)
                const iconSpan = document.createElement('span');
                iconSpan.className = 'submenu-app-icon';
                iconSpan.textContent = app.icon || 'üì±';
                
                const titleSpan = document.createElement('span');
                titleSpan.className = 'submenu-app-title';
                titleSpan.textContent = app.title;
                
                item.appendChild(iconSpan);
                item.appendChild(titleSpan);
                
                console.log('Creating submenu item for app:', app);
                
                // Check if this is a system app from definitions
                const systemAppOpenFunction = getSystemAppOpenFunction(app.title);
                
                if (systemAppOpenFunction) {
                    // Use the specific open function for system apps (both real and placeholder)
                    const systemAppHandler = () => {
                        console.log(`${app.title} submenu item clicked`);
                        systemAppOpenFunction();
                    };
                    item.onclick = systemAppHandler;
                    item.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        systemAppHandler();
                    });
                } else {
                    const appHandler = () => {
                        console.log('Regular app submenu item clicked for:', app.id);
                        
                        // Check if this is a persistent app that needs to be loaded
                        if (app.isPersistentApp && app.persistentData) {
                            console.log('Loading persistent app:', app.title);
                            loadPersistentApp(app.persistentData);
                            hideAppsSubmenu();
                            return;
                        }
                        
                        // Focus existing app or show it if minimized/hidden
                        if (app.isHidden) {
                            // For hidden system apps, show them
                            const windowElement = document.getElementById(`window_${app.id}`);
                            const iconElement = document.getElementById(`icon_${app.id}`);
                            if (windowElement) {
                                windowElement.style.display = 'block';
                                if (iconElement) iconElement.style.display = 'block';
                                app.isHidden = false;
                                windowElement.style.zIndex = getHighestZIndex() + 1;
                            }
                        } else if (app.isMinimized) {
                            toggleMinimize(app.id);
                        } else {
                            bringToFront(app.id);
                        }
                        hideAppsSubmenu();
                    };
                    item.onclick = appHandler;
                    item.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        appHandler();
                    });
                }
                
                content.appendChild(item);
            });

            // If no apps, show a message
            if (allApps.length === 0) {
                const noAppsItem = document.createElement('div');
                noAppsItem.className = 'apps-submenu-item';
                noAppsItem.textContent = 'No apps available';
                noAppsItem.style.color = '#888';
                noAppsItem.style.fontStyle = 'italic';
                content.appendChild(noAppsItem);
            }
        }

        function hideAppsSubmenu() {
            const submenu = document.getElementById('apps-submenu');
            if (submenu) {
                submenu.classList.remove('show');
            }
        }

        // Alias for updateAppsSubmenuContent to maintain compatibility
        function updateAppsSubmenu() {
            updateAppsSubmenuContent();
        }

        // ===== PERSISTENT APP MANAGEMENT =====
        
        // Get all persistent apps from the data registry
        function getPersistentApps() {
            const persistentApps = [];
            const allData = window.dataRegistry.getAllData();
            
            Object.keys(allData).forEach(key => {
                const meta = window.dataRegistry.getDataInfo(key);
                if (meta.config && meta.config.type === 'app' && meta.config.persistent) {
                    const appData = allData[key];
                    persistentApps.push({
                        appId: meta.config.appId,
                        title: appData.title || appData.name || key,
                        icon: appData.icon || 'üì±',
                        dataKey: key,
                        appData: appData,
                        config: meta.config
                    });
                }
            });
            
            console.log(`Found ${persistentApps.length} persistent apps:`, persistentApps);
            return persistentApps;
        }
        
        // Load a persistent app from storage
        async function loadPersistentApp(persistentAppData) {
            try {
                console.log('Loading persistent app:', persistentAppData);
                
                // Check if app is already running
                const existingApp = apps.find(app => app.id === persistentAppData.appId);
                if (existingApp) {
                    console.log('App already running, bringing to front');
                    bringToFront(existingApp.id);
                    return;
                }
                
                // Load the app data
                const appData = persistentAppData.appData;
                if (!appData) {
                    console.error('No app data found for persistent app');
                    return;
                }
                
                // Load associated data objects for this app
                const appDataObjects = {};
                const allData = window.dataRegistry.getAllData();
                Object.keys(allData).forEach(key => {
                    const meta = window.dataRegistry.getDataInfo(key);
                    if (meta.config && meta.config.appId === persistentAppData.appId && meta.config.type === 'data') {
                        appDataObjects[key] = allData[key];
                    }
                });
                
                console.log(`Loading ${Object.keys(appDataObjects).length} data objects for app ${persistentAppData.appId}`);
                
                // Create the app
                const newApp = {
                    id: persistentAppData.appId,
                    title: appData.title || appData.name,
                    icon: appData.icon || 'üì±',
                    type: 'user',
                    isMinimized: false,
                    isMaximized: false,
                    isHidden: false,
                    customRequest: `Loaded from persistence: ${appData.title || appData.name}`,
                    html: appData.html || '',
                    css: appData.css || '',
                    javascript: appData.javascript || '',
                    timestamp: new Date().toISOString(),
                    isPersistent: true
                };
                
                // Add to apps array
                apps.push(newApp);
                updateSharedAppsRegistry();
                
                // Create the window and UI
                const windowContent = appData.html || '<div>No content available</div>';
                createWindow(newApp.id, newApp.title, windowContent, 400, 300, newApp.icon);
                createTaskbarIcon(newApp.id, newApp.title, newApp.icon);
                updateAppCount();
                
                // Apply CSS and JavaScript
                if (appData.css) {
                    addAppCSS(appData.css, newApp.id);
                }
                
                if (appData.javascript) {
                    executeAppJavaScript(appData.javascript, newApp.id, newApp.title);
                }
                
                // Auto-size and center the window based on content
                setTimeout(() => {
                    autoSizeAndCenterWindow(newApp.id);
                    
                    // Add event listeners for version control buttons
                    addVersionControlEventListeners(newApp.id);
                    
                    // Create initial snapshot for loaded app
                    if (window.versionManager) {
                        window.versionManager.createSnapshot(newApp.id, 'Loaded from persistence');
                        window.versionManager.updateVersionControls(newApp.id);
                    }
                }, 100);
                
                // Update apps submenu
                updateAppsSubmenuContent();
                
                console.log(`Successfully loaded persistent app: ${newApp.title}`);
                
            } catch (error) {
                console.error('Error loading persistent app:', error);
                showCustomAlert(`Failed to load app: ${error.message}`, 'Error');
            }
        }
        
        // Save an app to persistence with LLM-friendly API
        async function saveAppToPersistence(appId, appData, options = {}) {
            try {
                const result = await window.dataRegistry.registerApp(appId, appData, {
                    description: options.description || `${appData.title || appData.name} application`,
                    savePrompt: options.savePrompt !== false
                });
                
                if (result.success) {
                    if (result.saved) {
                        console.log(`App ${appId} saved to persistence`);
                        updateAppsSubmenuContent();
                    } else {
                        console.log(`App ${appId} registered but not saved (user cancelled)`);
                    }
                    return result;
                } else {
                    console.error(`Failed to save app ${appId}:`, result.error);
                    return result;
                }
            } catch (error) {
                console.error(`Error saving app ${appId}:`, error);
                return { success: false, error: error.message };
            }
        }
        
        // Delete a persistent app and all its data
        async function deletePersistentApp(appId) {
            try {
                const result = await window.dataRegistry.deleteApp(appId);
                
                if (result.success) {
                    console.log(`Deleted persistent app ${appId} and ${result.totalDeleted} associated items`);
                    
                    // Also close the app if it's currently running
                    const runningApp = apps.find(app => app.id === appId);
                    if (runningApp) {
                        closeWindow(appId);
                    }
                    
                    // Update the apps submenu
                    updateAppsSubmenuContent();
                    
                    return result;
                } else {
                    console.error(`Failed to delete persistent app ${appId}:`, result.error);
                    return result;
                }
            } catch (error) {
                console.error(`Error deleting persistent app ${appId}:`, error);
                return { success: false, error: error.message };
            }
        }

        // Unified System App Opening Function
        function openSystemApp(appName) {
            console.log(`=== openSystemApp called for: ${appName} ===`);
            console.log('Current apps array:', apps);
            
            // Get app definition from dictionary
            const appDefinition = SYSTEM_APPS_DEFINITIONS[appName];
            if (!appDefinition) {
                console.error(`‚ùå No definition found for system app: ${appName}`);
                return;
            }
            
            // Check if app already exists in running apps
            const existingApp = apps.find(app => app.title === appName);
            console.log(`Found existing ${appName} app:`, existingApp);
            
            // Also check if app exists in persistence
            const persistentApps = getPersistentApps();
            const persistentApp = persistentApps.find(app => app.title === appName);
            console.log(`Found persistent ${appName} app:`, persistentApp);
            
            if (existingApp) {
                console.log(`Found existing ${appName} app with ID:`, existingApp.id);
                console.log('App state - isHidden:', existingApp.isHidden, 'isMinimized:', existingApp.isMinimized);
                
                // If app exists, show/focus the existing window
                const windowElement = document.getElementById(`window_${existingApp.id}`);
                const iconElement = document.getElementById(`icon_${existingApp.id}`);
                
                console.log('Window element exists:', !!windowElement);
                console.log('Icon element exists:', !!iconElement);
                
                if (windowElement) {
                    // Show if hidden
                    if (existingApp.isHidden) {
                        console.log(`Showing hidden ${appName} app`);
                        windowElement.style.display = 'block';
                        if (iconElement) iconElement.style.display = 'block';
                        existingApp.isHidden = false;
                        
                        // Update apps submenu to reflect the change
                        updateAppsSubmenuContent();
                    }
                    
                    // Unminimize if minimized
                    if (existingApp.isMinimized) {
                        console.log(`Unminimizing ${appName} app`);
                        toggleWindow(existingApp.id);
                    }
                    
                    // Bring to front
                    windowElement.style.zIndex = getHighestZIndex() + 1;
                    
                    // Dispatch app shown event to notify the app it's visible
                    dispatchAppShownEvent(existingApp.id);
                    
                    console.log(`Successfully opened existing ${appName} app`);
                    debugLog(`Opened existing ${appName} app`);
                } else {
                    console.log(`Window element missing, recreating ${appName} app window`);
                    // Window element doesn't exist, recreate it using the system app generation
                    generateSystemApp(appName, existingApp.id);
                    
                    // Ensure it's still marked as system app
                    existingApp.isSystemApp = true;
                    existingApp.isHidden = false;
                    
                    console.log(`Successfully recreated ${appName} app window`);
                    debugLog(`Recreated ${appName} app window`);
                }
            } else if (persistentApp) {
                console.log(`Loading ${appName} app from persistence`);
                // Load the persistent app
                loadPersistentApp(persistentApp);
            } else {
                console.log(`No existing ${appName} app found, creating new one`);
                // Create new AI-generated app
                const newAppId = generateSystemApp(appName);
                
                // Mark the new app as a system app
                const newApp = apps.find(app => app.id === newAppId);
                if (newApp) {
                    newApp.isSystemApp = true;
                    console.log(`Marked new ${appName} app as system app`);
                }
            }
            
            // Close start menu and submenu
            hideAppsSubmenu();
            document.getElementById('start-menu').classList.remove('show');
        }


        // System App Generation with Mode Management
        function generateSystemApp(appName, appId = null) {
            console.log(`üîß Generating system app: ${appName}`);
            
            // Get app definition from dictionary
            const appDefinition = SYSTEM_APPS_DEFINITIONS[appName];
            if (!appDefinition) {
                console.error(`‚ùå No definition found for system app: ${appName}`);
                return null;
            }
            
            // Store current mode for restoration
            previousModelMode = currentModelMode;
            
            // Set generation mode based on app definition
            const requiredMode = appDefinition.generationMode === 'TOUGH' ? 'Tough' : 'Simple';
            if (currentModelMode !== requiredMode) {
                console.log(`üîÑ Switching from ${currentModelMode} to ${requiredMode} mode for ${appName} generation`);
                setModelMode(requiredMode);
            }
            
            // Generate or use provided app ID - use consistent ID for system apps
            const finalAppId = appId || `system-${appName.toLowerCase().replace(/\s+/g, '-')}`;
            
            // Get app-specific settings
            const icon = getSystemAppIcon(appName);
            const dimensions = getSystemAppDimensions(appName);
            
            // Create app content using the definition's prompt
            const content = createAIGeneratedAppContent(appDefinition.prompt, finalAppId);

            const app = {
                id: finalAppId,
                type: 'ai-generated',
                title: appName,
                icon: icon,
                isMinimized: false,
                isMaximized: false,
                system: true,
                customRequest: appDefinition.prompt,
                isSystemApp: true,
                generationMode: appDefinition.generationMode,
                isHidden: false
            };

            apps.push(app);
            updateSharedAppsRegistry();
            createWindow(finalAppId, appName, content, dimensions.width, dimensions.height, icon);
            createTaskbarIcon(finalAppId, appName, icon);
            updateAppCount();
            
            // Update apps submenu to include the new system app
            updateAppsSubmenuContent();
            
            // Schedule mode restoration after generation completes
            scheduleModelModeRestoration();
            
            debugLog(`Created new ${appName} system app with ${appDefinition.generationMode} mode`);
            return finalAppId;
        }

        // Helper function to set model mode
        function setModelMode(mode) {
            const toggleButton = document.getElementById('model-toggle');
            const modeText = document.getElementById('model-mode-text');
            
            if (mode === 'Tough' && currentModelMode !== 'Tough') {
                currentModelMode = 'Tough';
                CONFIG.MODEL = CONFIG.MODEL_TOUGH;
                if (modeText) modeText.textContent = 'Tough';
                if (toggleButton) toggleButton.classList.add('tough-mode');
            } else if (mode === 'Simple' && currentModelMode !== 'Simple') {
                currentModelMode = 'Simple';
                CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                if (modeText) modeText.textContent = 'Simple';
                if (toggleButton) toggleButton.classList.remove('tough-mode');
            }
            
            console.log(`Model mode set to: ${currentModelMode} (${CONFIG.MODEL})`);
            
            // Update provider display to show new model
            updateProviderDisplay();
        }

        // Helper function to get system app icon
        function getSystemAppIcon(appName) {
            const appDefinition = SYSTEM_APPS_DEFINITIONS[appName];
            return appDefinition ? appDefinition.icon : 'üì±';
        }

        // Helper function to get system app open function
        function getSystemAppOpenFunction(appName) {
            // Check if app is defined in SYSTEM_APPS_DEFINITIONS
            if (SYSTEM_APPS_DEFINITIONS[appName]) {
                return () => openSystemApp(appName);
            }
            return null;
        }
        
        // Helper function to check if an app is a system app by name
        function isSystemAppByName(appName) {
            return SYSTEM_APPS_DEFINITIONS.hasOwnProperty(appName);
        }

        // Helper function to get system app dimensions
        function getSystemAppDimensions(appName) {
            const appDefinition = SYSTEM_APPS_DEFINITIONS[appName];
            return appDefinition && appDefinition.dimensions ? appDefinition.dimensions : { width: 400, height: 300 };
        }

        // Schedule model mode restoration after generation
        function scheduleModelModeRestoration() {
            // Wait for generation to complete (estimated time) then restore mode
            setTimeout(() => {
                if (previousModelMode !== currentModelMode) {
                    console.log(`üîÑ Restoring model mode from ${currentModelMode} back to ${previousModelMode}`);
                    setModelMode(previousModelMode);
                }
            }, 10000); // Wait 10 seconds for generation to complete
        }




        // Microphone test function
        async function testMicrophone() {
            let testStream = null;
            let audioContext = null;
            let analyser = null;
            let microphone = null;
            let dataArray = null;
            let animationId = null;
            
            try {
                // Create a modal dialog for the microphone test
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const testDialog = document.createElement('div');
                testDialog.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 10px;
                    text-align: center;
                    max-width: 400px;
                    width: 90%;
                `;
                
                testDialog.innerHTML = `
                    <h3 style="margin: 0 0 20px 0; color: #333;">üé§ Microphone Test</h3>
                    <p style="margin: 0 0 20px 0; color: #666;">Speak into your microphone to test audio levels</p>
                    <div style="margin: 20px 0;">
                        <div id="mic-level-bar" style="
                            width: 100%;
                            height: 20px;
                            background: #f0f0f0;
                            border-radius: 10px;
                            overflow: hidden;
                            position: relative;
                        ">
                            <div id="mic-level-fill" style="
                                height: 100%;
                                background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
                                width: 0%;
                                transition: width 0.1s ease;
                            "></div>
                        </div>
                        <p id="mic-level-text" style="margin: 10px 0 0 0; font-size: 14px; color: #666;">Audio Level: 0%</p>
                    </div>
                    <div id="mic-status" style="margin: 20px 0; font-size: 14px; color: #666;">Requesting microphone access...</div>
                    <button id="close-mic-test" style="
                        background: #dc3545;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                    ">Close Test</button>
                `;
                
                modal.appendChild(testDialog);
                document.body.appendChild(modal);
                
                const levelBar = document.getElementById('mic-level-fill');
                const levelText = document.getElementById('mic-level-text');
                const statusText = document.getElementById('mic-status');
                const closeBtn = document.getElementById('close-mic-test');
                
                // Close button handler
                closeBtn.addEventListener('click', () => {
                    cleanup();
                });
                
                // Click outside to close
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        cleanup();
                    }
                });
                
                function cleanup() {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    if (testStream) {
                        testStream.getTracks().forEach(track => track.stop());
                    }
                    if (audioContext) {
                        audioContext.close();
                    }
                    if (modal && modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                }
                
                // Request microphone access
                try {
                    testStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                    
                    statusText.textContent = 'Microphone access granted! Speak to see audio levels.';
                    statusText.style.color = '#28a745';
                    
                    // Set up audio analysis
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    microphone = audioContext.createMediaStreamSource(testStream);
                    
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    
                    microphone.connect(analyser);
                    
                    // Start monitoring audio levels
                    function updateAudioLevel() {
                        analyser.getByteFrequencyData(dataArray);
                        
                        // Calculate average volume
                        let sum = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            sum += dataArray[i];
                        }
                        const average = sum / bufferLength;
                        const percentage = Math.round((average / 255) * 100);
                        
                        // Update visual indicators
                        levelBar.style.width = percentage + '%';
                        levelText.textContent = `Audio Level: ${percentage}%`;
                        
                        // Color coding based on level
                        if (percentage < 10) {
                            levelBar.style.background = '#6c757d'; // Gray for very low
                        } else if (percentage < 30) {
                            levelBar.style.background = '#28a745'; // Green for good
                        } else if (percentage < 70) {
                            levelBar.style.background = '#ffc107'; // Yellow for moderate
                        } else {
                            levelBar.style.background = '#dc3545'; // Red for high
                        }
                        
                        // Update status based on audio level
                        if (percentage > 5) {
                            statusText.textContent = '‚úÖ Microphone is working! Audio detected.';
                            statusText.style.color = '#28a745';
                        } else {
                            statusText.textContent = 'üîá Speak louder or check microphone settings.';
                            statusText.style.color = '#ffc107';
                        }
                        
                        animationId = requestAnimationFrame(updateAudioLevel);
                    }
                    
                    updateAudioLevel();
                    
                } catch (error) {
                    console.error('Microphone access failed:', error);
                    statusText.textContent = '‚ùå Microphone access denied or failed. Please check permissions.';
                    statusText.style.color = '#dc3545';
                    
                    // Show specific error messages
                    if (error.name === 'NotAllowedError') {
                        statusText.textContent = '‚ùå Microphone access denied. Please allow microphone access and try again.';
                    } else if (error.name === 'NotFoundError') {
                        statusText.textContent = '‚ùå No microphone found. Please connect a microphone and try again.';
                    } else if (error.name === 'NotReadableError') {
                        statusText.textContent = '‚ùå Microphone is being used by another application.';
                    }
                }
                
            } catch (error) {
                console.error('Failed to create microphone test dialog:', error);
                showCustomAlert('Failed to start microphone test. Please try again.', 'Error');
            }
        }

        const SPINNER_ANIMATION = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                    <h2 style="margin: 0 0 30px 0; color: #333; font-weight: 300;">Creating your app</h2>
                    <div class="spinner" style="
                        width: 40px;
                        height: 40px;
                        border: 4px solid #f3f3f3;
                        border-top: 4px solid #0078d4;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                    "></div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
        `;


        // AI-Generated App Content Creator
        function createAIGeneratedAppContent(request, appId) {
            // Start LLM processing immediately
            setTimeout(() => processAppWithLLM(request, appId), 100);
            
            return SPINNER_ANIMATION;
        }

        // AI-Generated App Content Creator with Images
        function createAIGeneratedAppContentWithImages(request, images, appId) {
            // Start LLM processing with images immediately
            setTimeout(() => processAppWithLLMAndImages(request, images, appId), 100);
            
            return SPINNER_ANIMATION;
        }

        // LLM Processing Function
        async function processAppWithLLM(request, appId, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`üîÑ Processing app with LLM (attempt ${retryCount + 1}/${maxRetries})`);
                
                // Create prompt for windowed app generation
                const prompt = createWindowedAppPrompt(request, appId);
                
                // Call LLM API
                const response = await callLLMAPI(prompt, request, 'App Creation Request', appId);
                
                if (response && response.html) {
                    console.log(`‚úÖ LLM processing successful on attempt ${retryCount + 1}`);
                    
                    // Replace the placeholder content with the generated app
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Auto-size and center the window based on content
                        setTimeout(() => {
                            autoSizeAndCenterWindow(appId);
                        }, 100);
                        
                        // For system apps, use predefined title and icon from SYSTEM_APPS_DEFINITIONS
                        const app = apps.find(a => a.id === appId);
                        const isSystemApp = app && app.isSystemApp;
                        let finalTitle = response.title || 'Generated App';
                        let finalIcon = response.icon || 'üì±';
                        
                        if (isSystemApp) {
                            // Find the system app definition that matches this app
                            const systemAppName = Object.keys(SYSTEM_APPS_DEFINITIONS).find(name => {
                                const expectedId = `system-${name.toLowerCase().replace(/\s+/g, '-')}`;
                                return expectedId === appId;
                            });
                            
                            if (systemAppName) {
                                finalTitle = systemAppName;
                                finalIcon = SYSTEM_APPS_DEFINITIONS[systemAppName].icon;
                                console.log(`üîß Using predefined title '${finalTitle}' and icon '${finalIcon}' for system app ${appId}`);
                            }
                        }
                        
                        // Update app title
                        updateAppTitle(appId, finalTitle);
                        
                        // Update app icon
                        updateAppIcon(appId, finalIcon);
                        
                        // Save app to persistence
                        setTimeout(async () => {
                            try {
                                const appData = {
                                    title: finalTitle,
                                    icon: finalIcon,
                                    html: response.html,
                                    css: response.css || '',
                                    javascript: response.javascript || '',
                                    customRequest: request,
                                    timestamp: new Date().toISOString()
                                };
                                
                                const saveResult = await saveAppToPersistence(appId, appData, {
                                    description: `AI-generated app: ${appData.title}`,
                                    savePrompt: false
                                });
                                
                                if (saveResult.success) {
                                    console.log(`‚úÖ App ${appId} saved to persistence`);
                                } else {
                                    console.warn(`‚ö†Ô∏è Failed to save app ${appId} to persistence:`, saveResult.error);
                                }
                            } catch (error) {
                                console.error(`‚ùå Error saving app ${appId} to persistence:`, error);
                            }
                        }, 500);
                    }
                } else {
                    throw new Error('Invalid response from LLM - missing HTML content');
                }
                
            } catch (error) {
                console.error(`‚ùå LLM processing failed (attempt ${retryCount + 1}):`, error);
                
                // Don't retry if it's a configuration error
                const isConfigError = error.message.includes('not configured') ||
                                    error.message.includes('API key') ||
                                    error.message.includes('URL not configured');
                
                // Check if we should retry
                if (retryCount < maxRetries - 1 && !isConfigError) {
                    console.log(`üîÑ Retrying in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">üîÑ Retrying...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppWithLLM(request, appId, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`üí• All ${maxRetries} attempts failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">‚ùå Error</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        async function processAppWithLLMAndImages(request, images, appId, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`üîÑ Processing app with images (attempt ${retryCount + 1}/${maxRetries})`);
                
                // Create prompt for windowed app generation with images
                let prompt = createWindowedAppPrompt(request, appId);
                
                // Add image context
                if (images && images.length > 0) {
                    prompt += `\n\nIMAGE CONTEXT:\nThe user has provided ${images.length} screenshot(s) to help with app creation. Please analyze the provided images and incorporate any relevant visual information, UI elements, design patterns, or functionality shown in the screenshots into your app creation.`;
                }
                
                // Call LLM API with images
                const response = await callLLMAPIWithImages(prompt, request, images, 'App Creation Request with Images', appId);
                
                if (response && response.html) {
                    console.log(`‚úÖ LLM processing with images successful on attempt ${retryCount + 1}`);
                    
                    // Replace the placeholder content with the generated app
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Auto-size and center the window based on content
                        setTimeout(() => {
                            autoSizeAndCenterWindow(appId);
                        }, 100);
                        
                        // For system apps, use predefined title and icon from SYSTEM_APPS_DEFINITIONS
                        const app = apps.find(a => a.id === appId);
                        const isSystemApp = app && app.isSystemApp;
                        let finalTitle = response.title || 'Generated App';
                        let finalIcon = response.icon || 'üì±';
                        
                        if (isSystemApp) {
                            // Find the system app definition that matches this app
                            const systemAppName = Object.keys(SYSTEM_APPS_DEFINITIONS).find(name => {
                                const expectedId = `system-${name.toLowerCase().replace(/\s+/g, '-')}`;
                                return expectedId === appId;
                            });
                            
                            if (systemAppName) {
                                finalTitle = systemAppName;
                                finalIcon = SYSTEM_APPS_DEFINITIONS[systemAppName].icon;
                                console.log(`üîß Using predefined title '${finalTitle}' and icon '${finalIcon}' for system app ${appId}`);
                            }
                        }
                        
                        // Update app title
                        updateAppTitle(appId, finalTitle);
                        
                        // Update app icon
                        updateAppIcon(appId, finalIcon);
                        
                        // Save app to persistence
                        setTimeout(async () => {
                            try {
                                const appData = {
                                    title: finalTitle,
                                    icon: finalIcon,
                                    html: response.html,
                                    css: response.css || '',
                                    javascript: response.javascript || '',
                                    customRequest: request,
                                    hasImages: true,
                                    imageCount: images ? images.length : 0,
                                    timestamp: new Date().toISOString()
                                };
                                
                                const saveResult = await saveAppToPersistence(appId, appData, {
                                    description: `AI-generated app with images: ${appData.title}`,
                                    savePrompt: false
                                });
                                
                                if (saveResult.success) {
                                    console.log(`‚úÖ App ${appId} (with images) saved to persistence`);
                                } else {
                                    console.warn(`‚ö†Ô∏è Failed to save app ${appId} to persistence:`, saveResult.error);
                                }
                            } catch (error) {
                                console.error(`‚ùå Error saving app ${appId} to persistence:`, error);
                            }
                        }, 500);
                    }
                } else {
                    throw new Error('Invalid response from LLM - missing HTML content');
                }
                
            } catch (error) {
                console.error(`‚ùå LLM processing with images failed (attempt ${retryCount + 1}):`, error);
                
                // Don't retry if it's a configuration error
                const isConfigError = error.message.includes('not configured') ||
                                    error.message.includes('API key') ||
                                    error.message.includes('URL not configured');
                
                // Check if we should retry
                if (retryCount < maxRetries - 1 && !isConfigError) {
                    console.log(`üîÑ Retrying in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">üîÑ Retrying...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppWithLLMAndImages(request, images, appId, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`üí• All ${maxRetries} attempts failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">‚ùå Error</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        function createWindowedAppPrompt(request, appId) {
            // Get current theme
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            
            // Get available data objects from registry
            let availableDataObjects = 'None currently registered';
            if (window.dataRegistry && typeof window.dataRegistry.getAllData === 'function') {
                const allData = window.dataRegistry.getAllData();
                if (Object.keys(allData).length > 0) {
                    availableDataObjects = Object.keys(allData).map(key => {
                        const info = window.dataRegistry.getDataInfo ? window.dataRegistry.getDataInfo(key) : {};
                        const data = allData[key];
                        
                        // Analyze structure if not provided
                        let structure = info.structure;
                        if (!structure || structure === 'Unknown structure') {
                            structure = analyzeDataStructure(data);
                        }
                        
                        return `- ${key}: ${info.description || 'No description'} (${structure})`;
                    }).join('\n');
                }
            }
            
            let prompt = ROLE_PROMPT +
                         APPCREATION_PROMPT.replace(/{appId}/g, appId).replace(/{availableDataObjects}/g, availableDataObjects) +
                         NAMESPACEISOLATION_GUIDELINES.replace(/{appId}/g, appId) +
                         CSS_GUIDELINES.replace(/{currentTheme}/g, currentTheme) +
                         JAVASCRIPT_GUIDELINES.replace(/{appId}/g, appId) +
                         LIBRARIES_GUIDELINES.replace(/{appId}/g, appId) +
                         "Now create a functional app for: " + request;
  
            return prompt;
        }

        // Function to show prompt history for an app
        function showPromptHistory(appId) {
            const app = apps.find(a => a.id === appId);
            if (!app || !app.promptHistory || app.promptHistory.length === 0) {
                showCustomAlert('No prompt history available for this app.', 'Information');
                return;
            }

            // Create a modal window to display the prompt history
            const modal = document.createElement('div');
            modal.className = 'prompt-history-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 80%;
                max-height: 80%;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            `;

            // Apply theme to modal
            if (document.body.classList.contains('dark-theme')) {
                modalContent.style.background = '#2c3e50';
                modalContent.style.color = '#f8f9fa';
            }

            let historyHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">üìú Prompt History - ${app.title}</h2>
                    <button onclick="this.closest('.prompt-history-modal').remove()" style="
                        background: #dc3545;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        padding: 8px 12px;
                        cursor: pointer;
                        font-size: 16px;
                    ">√ó</button>
                </div>
                <div style="margin-bottom: 15px; color: #666;">
                    Total prompts: ${app.promptHistory.length}
                </div>
            `;

            app.promptHistory.forEach((entry, index) => {
                const typeIcon = entry.type === 'creation' ? 'üÜï' : '‚úèÔ∏è';
                const typeLabel = entry.type === 'creation' ? 'Creation' : 'Edit';
                
                historyHTML += `
                    <div style="
                        border: 1px solid #ddd;
                        border-radius: 6px;
                        margin-bottom: 15px;
                        padding: 15px;
                        background: ${document.body.classList.contains('dark-theme') ? '#34495e' : '#f8f9fa'};
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong>${typeIcon} ${typeLabel} #${index + 1}</strong>
                            <span style="color: #666; font-size: 14px;">${entry.date}</span>
                        </div>
                        ${entry.userRequest ? `
                            <div style="margin-bottom: 10px;">
                                <strong>User Request:</strong>
                                <div style="
                                    background: ${document.body.classList.contains('dark-theme') ? '#495057' : '#e9ecef'};
                                    padding: 8px;
                                    border-radius: 4px;
                                    margin-top: 5px;
                                    font-family: monospace;
                                    font-size: 14px;
                                ">${entry.userRequest}</div>
                            </div>
                        ` : ''}
                        <div>
                            <strong>Full Prompt:</strong>
                            <div style="
                                background: ${document.body.classList.contains('dark-theme') ? '#495057' : '#e9ecef'};
                                padding: 10px;
                                border-radius: 4px;
                                margin-top: 5px;
                                font-family: monospace;
                                font-size: 12px;
                                max-height: 200px;
                                overflow-y: auto;
                                white-space: pre-wrap;
                                word-wrap: break-word;
                            ">${entry.prompt}</div>
                        </div>
                    </div>
                `;
            });

            modalContent.innerHTML = historyHTML;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Function to record a prompt in an app's history
        function recordPromptInHistory(appId, prompt, type = 'creation', userRequest = '') {
            const app = apps.find(a => a.id === appId);
            if (app) {
                if (!app.promptHistory) {
                    app.promptHistory = [];
                }
                
                const historyEntry = {
                    timestamp: new Date().toISOString(),
                    type: type, // 'creation' or 'edit'
                    userRequest: userRequest,
                    prompt: prompt,
                    date: new Date().toLocaleString()
                };
                
                app.promptHistory.push(historyEntry);
                console.log(`Recorded ${type} prompt for app ${appId}:`, historyEntry);
            }
        }


        function escapeJsonString(str) {
            return str
                .replace(/\\/g, '\\\\')     // Escape backslashes
                .replace(/"/g, '\\"');      // Escape double quotes
            }

function escapeJsonString(str) {
    return str
        .replace(/\\/g, '\\\\')      // Escape backslash
        .replace(/"/g, '\\"')        // Escape double quote
        .replace(/\n/g, '\\n')       // Escape newline
        .replace(/\r/g, '\\r')       // Escape carriage return
        .replace(/\t/g, '\\t');      // Escape tab
}

function sanitizeJsonCodeFields(jsonStr) {
    // First try to parse directly
    try {
        JSON.parse(jsonStr);
        return jsonStr; // If valid JSON, return as is
    } catch (e) {
        // Proceed to sanitize if JSON is malformed
    }

    // Regex to extract key-value pairs with string values
    const fieldRegex = /"(\w+)"\s*:\s*"((?:\\.|[^"\\])*)"/gs;

    const sanitized = jsonStr.replace(fieldRegex, (match, key, value) => {
        if (["javascript", "html", "css"].includes(key)) {
            // First unescape to get raw code
            const unescaped = value
                .replace(/\\\\/g, '\\')   // unescape backslashes
                .replace(/\\"/g, '"')     // unescape double quotes
                .replace(/\\n/g, '\n')    // unescape newlines
                .replace(/\\r/g, '\r')    // unescape carriage returns
                .replace(/\\t/g, '\t');   // unescape tabs

            // Then escape properly again
            const reescaped = escapeJsonString(unescaped);
            return `"${key}": "${reescaped}"`;
        }
        return match;
    });

    // Final parse attempt after sanitization
    return sanitized;
}




        async function callLLMAPI(prompt, userRequest = '', description = 'API Request', appId = null) {
            // If appId is provided, append the ID prefixing prompt add-on
            if (appId) {
                
                // Record the prompt in the app's history
                const promptType = description.includes('Edit') ? 'edit' : 'creation';
                recordPromptInHistory(appId, prompt, promptType, userRequest);
            }
            
            // Check if provider is properly configured
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' && (!CONFIG.OPENROUTER_API_KEY || CONFIG.OPENROUTER_API_KEY === 'sk-...')) {
                throw new Error('OpenRouter API key not configured');
            }
            
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openai' && (!CONFIG.OPENROUTER_API_KEY || CONFIG.OPENROUTER_API_KEY === 'sk-proj-...')) {
                throw new Error('OpenAI API key not configured');
            }
            
            if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio' && (!CONFIG.OPENROUTER_URL || CONFIG.OPENROUTER_URL === 'https://openrouter.ai/api/v1/chat/completions')) {
                throw new Error('LMStudio URL not configured');
            }
            
            // Prepare headers based on current provider
            let headers = {
                'Content-Type': 'application/json'
            };
            
            // Add provider-specific headers
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter') {
                headers['Authorization'] = `Bearer ${CONFIG.OPENROUTER_API_KEY}`;
                headers['HTTP-Referer'] = window.location.origin;
                headers['X-Title'] = 'Self-Evolving OS';
            } else if (CONFIG.CURRENT_LLM_PROVIDER === 'openai') {
                headers['Authorization'] = `Bearer ${CONFIG.OPENROUTER_API_KEY}`; // Reused config key
            } else if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio') {
                // LMStudio typically doesn't require authorization header
                // headers['Authorization'] is not needed
            }
            
            const requestBody = {
                model: CONFIG.MODEL,
                messages: [{ role: 'user', content: prompt }]
            };
            
            // Use the correct parameters based on provider
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openai') {
                requestBody.max_completion_tokens = 16000;
                // OpenAI models may not support custom temperature, use default (1)
                requestBody.temperature = 1;
            } else {
                requestBody.max_tokens = 32000;
                requestBody.temperature = 0.7;
            }
            
            // Debug logging for LMStudio
            if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio') {
                console.log('LMStudio API Request:', {
                    url: CONFIG.OPENROUTER_URL,
                    headers: headers,
                    body: requestBody,
                    bodyString: JSON.stringify(requestBody)
                });
            }
            
            const response = await fetch(CONFIG.OPENROUTER_URL, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`API request failed for ${CONFIG.CURRENT_LLM_PROVIDER}:`, {
                    status: response.status,
                    statusText: response.statusText,
                    errorText: errorText,
                    url: CONFIG.OPENROUTER_URL,
                    requestBody: requestBody
                });
                throw new Error(`API request failed: ${response.status} - ${response.statusText}: ${errorText}`);
            }

            const data = await response.json();
            
            // Extract cost information from response
            updateCostDisplay(data, description, userRequest);
            
            content = data.choices[0].message.content;
            
            content = content.replace(/^```json\s*/, '').replace(/\s*```$/, '');
            content = sanitizeJsonCodeFields(content);

            // Try full parse
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (!jsonMatch) throw new Error("Invalid response format - no JSON found");

            try {
                return JSON.parse(jsonMatch[0]);
            } catch (initialError) {
                console.log(content);
                console.warn('First JSON parse attempt failed:', initialError.message);
                
                // Try multiple nested-looking JSON objects
                const jsonBlocks = content.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
                if (jsonBlocks) {
                    for (const block of jsonBlocks) {
                        try {
                            const parsed = JSON.parse(block);
                            if (parsed.title && parsed.html) {
                                return parsed;
                            }
                        } catch {}
                    }
                }

                // No auto-cleaning step here: better to surface the real error
                throw new Error(`JSON parsing failed: ${initialError.message}`);
            }
        }

        async function callLLMAPIWithImages(prompt, userRequest = '', images = [], description = 'API Request with Images', appId = null) {
            // If appId is provided, record the prompt in the app's history
            if (appId) {
                const promptType = description.includes('Edit') ? 'edit' : 'creation';
                recordPromptInHistory(appId, prompt, promptType, userRequest);
            }
            
            // Check if provider is properly configured
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' && (!CONFIG.OPENROUTER_API_KEY || CONFIG.OPENROUTER_API_KEY === 'sk-...')) {
                throw new Error('OpenRouter API key not configured');
            }
            
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openai' && (!CONFIG.OPENROUTER_API_KEY || CONFIG.OPENROUTER_API_KEY === 'sk-proj-...')) {
                throw new Error('OpenAI API key not configured');
            }
            
            if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio' && (!CONFIG.OPENROUTER_URL || CONFIG.OPENROUTER_URL === 'https://openrouter.ai/api/v1/chat/completions')) {
                throw new Error('LMStudio URL not configured');
            }
            
            // Prepare headers based on current provider
            let headers = {
                'Content-Type': 'application/json'
            };
            
            // Add provider-specific headers
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter') {
                headers['Authorization'] = `Bearer ${CONFIG.OPENROUTER_API_KEY}`;
                headers['HTTP-Referer'] = window.location.origin;
                headers['X-Title'] = 'Self-Evolving OS';
            } else if (CONFIG.CURRENT_LLM_PROVIDER === 'openai') {
                headers['Authorization'] = `Bearer ${CONFIG.OPENROUTER_API_KEY}`; // Reused config key
            } else if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio') {
                // LMStudio typically doesn't require authorization header
                // headers['Authorization'] is not needed
            }
            
            // Prepare messages with images
            const messages = [];
            
            // Add the main prompt
            const messageContent = [
                {
                    type: "text",
                    text: prompt
                }
            ];
            
            // Add images if provided
            if (images && images.length > 0) {
                console.log(`Adding ${images.length} images to the request`);
                images.forEach((imageData, index) => {
                    messageContent.push({
                        type: "image_url",
                        image_url: {
                            url: imageData.base64,
                            detail: "high"
                        }
                    });
                    console.log(`Added image ${index + 1}: ${imageData.name}`);
                });
            }
            
            messages.push({
                role: 'user',
                content: messageContent
            });
            
            const requestBody = {
                model: CONFIG.MODEL,
                messages: messages
            };
            
            // Use the correct parameters based on provider
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openai') {
                requestBody.max_completion_tokens = 16000;
                requestBody.temperature = 1;
            } else {
                requestBody.max_tokens = 32000;
                requestBody.temperature = 0.7;
            }
            
            console.log('Sending request with images to LLM:', {
                provider: CONFIG.CURRENT_LLM_PROVIDER,
                model: CONFIG.MODEL,
                imageCount: images.length,
                promptLength: prompt.length
            });
            
            const response = await fetch(CONFIG.OPENROUTER_URL, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`API request with images failed for ${CONFIG.CURRENT_LLM_PROVIDER}:`, {
                    status: response.status,
                    statusText: response.statusText,
                    errorText: errorText,
                    url: CONFIG.OPENROUTER_URL,
                    imageCount: images.length
                });
                throw new Error(`API request failed: ${response.status} - ${response.statusText}: ${errorText}`);
            }

            const data = await response.json();
            
            // Extract cost information from response
            updateCostDisplay(data, description, userRequest);
            
            let content = data.choices[0].message.content;
            
            content = content.replace(/^```json\s*/, '').replace(/\s*```$/, '');
            content = sanitizeJsonCodeFields(content);

            // Try full parse
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (!jsonMatch) throw new Error("Invalid response format - no JSON found");

            try {
                return JSON.parse(jsonMatch[0]);
            } catch (initialError) {
                console.log(content);
                console.warn('First JSON parse attempt failed:', initialError.message);
                
                // Try multiple nested-looking JSON objects
                const jsonBlocks = content.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
                if (jsonBlocks) {
                    for (const block of jsonBlocks) {
                        try {
                            const parsed = JSON.parse(block);
                            if (parsed.title && parsed.html) {
                                return parsed;
                            }
                        } catch {}
                    }
                }

                // No auto-cleaning step here: better to surface the real error
                throw new Error(`JSON parsing failed: ${initialError.message}`);
            }
        }

        // Global cost tracking
        let totalCost = 0;

        function updateCostDisplay(responseData, description = 'API Request', prompt = '') {
            try {
                // OpenRouter includes usage information in the response
                if (responseData.usage) {
                    const usage = responseData.usage;
                    
                    // Calculate cost based on token usage
                    // These are approximate rates - OpenRouter may provide exact costs in headers
                    const promptTokens = usage.prompt_tokens || 0;
                    const completionTokens = usage.completion_tokens || 0;
                    
                    // Approximate cost calculation (Claude 3.5 Sonnet rates)
                    const promptCost = (promptTokens / 1000000) * 3.00; // $3 per 1M input tokens
                    const completionCost = (completionTokens / 1000000) * 15.00; // $15 per 1M output tokens
                    const requestCost = promptCost + completionCost;
                    
                    totalCost += requestCost;
                    
                    // Add to cost tracking history
                    addCostEntry(requestCost, description, prompt);
                    
                    // Update display
                    const costElement = document.getElementById('api-cost');
                    if (costElement) {
                        costElement.textContent = totalCost.toFixed(4);
                    }
                    
                    console.log(`Request cost: $${requestCost.toFixed(4)}, Total cost: $${totalCost.toFixed(4)}`);
                }
            } catch (error) {
                console.warn('Could not calculate API cost:', error);
            }
        }

        // Helper function to update cost without response data
        function updateCost(cost, description = 'Manual Update', prompt = '') {
            totalCost += cost;
            
            // Add to cost tracking history
            addCostEntry(cost, description, prompt);
            
            // Update display
            const costElement = document.getElementById('api-cost');
            if (costElement) {
                costElement.textContent = totalCost.toFixed(4);
            }
        }


        function addAppCSS(css, appId) {
            // Remove existing style element if it exists
            const existingStyle = document.getElementById(`style-${appId}`);
            if (existingStyle) {
                existingStyle.remove();
            }
            
            const styleElement = document.createElement('style');
            styleElement.id = `style-${appId}`;
            
            // Check if CSS is already namespaced (contains #content_appId)
            const containerSelector = `#content_${appId}`;
            const isAlreadyNamespaced = css.includes(containerSelector);
            
            let finalCSS;
            let originalCSS;
            
            if (isAlreadyNamespaced) {
                console.log(`CSS for app ${appId} is already namespaced, using as-is`);
                finalCSS = css;
                // Try to extract original CSS by removing namespacing (best effort)
                originalCSS = css;
            } else {
                console.log(`CSS for app ${appId} needs namespacing`);
                originalCSS = css; // Store the original CSS
                // Apply namespace isolation to CSS
                finalCSS = namespaceCSS(css, appId);
            }
            
            // Store the original CSS in a data attribute for later retrieval
            styleElement.setAttribute('data-original-css', originalCSS);
            styleElement.textContent = finalCSS;
            document.head.appendChild(styleElement);
        }

        function namespaceCSS(css, appId) {
            // Scope all CSS rules to the app container with theme inheritance
            const containerSelector = `#content_${appId}`;
            
            // Add theme-aware base styles for the app container
            const themeBaseStyles = `
/* Theme-aware base styles for app ${appId} */
${containerSelector} {
    color: inherit;
    background: inherit;
}

/* Light theme styles */
.app-light-theme ${containerSelector} {
    background: #ffffff;
    color: #212529;
}

.app-light-theme ${containerSelector} input,
.app-light-theme ${containerSelector} textarea,
.app-light-theme ${containerSelector} select {
    background: #ffffff;
    color: #212529;
    border: 1px solid #ced4da;
}

.app-light-theme ${containerSelector} button {
    background: #007bff;
    color: #ffffff;
    border: 1px solid #007bff;
}

.app-light-theme ${containerSelector} button:hover {
    background: #0056b3;
    border-color: #0056b3;
}

/* Dark theme styles */
.app-dark-theme ${containerSelector} {
    background: #2c3e50;
    color: #f8f9fa;
}

.app-dark-theme ${containerSelector} input,
.app-dark-theme ${containerSelector} textarea,
.app-dark-theme ${containerSelector} select {
    background: #495057;
    color: #f8f9fa;
    border: 1px solid #6c757d;
}

.app-dark-theme ${containerSelector} button {
    background: #0d6efd;
    color: #ffffff;
    border: 1px solid #0d6efd;
}

.app-dark-theme ${containerSelector} button:hover {
    background: #0b5ed7;
    border-color: #0b5ed7;
}
            `;
            
            // Split CSS into rules and namespace each one
            const rules = css.split('}').filter(rule => rule.trim());
            const namespacedRules = rules.map(rule => {
                if (!rule.trim()) return '';
                
                const [selectors, declarations] = rule.split('{');
                if (!selectors || !declarations) return rule + '}';
                
                // Process each selector
                const processedSelectors = selectors.split(',').map(selector => {
                    const trimmedSelector = selector.trim();
                    if (!trimmedSelector) return selector;
                    
                    // Skip @media, @keyframes, and other @ rules
                    if (trimmedSelector.startsWith('@')) return selector;
                    
                    // Add container scope to each selector
                    return `${containerSelector} ${trimmedSelector}`;
                }).join(', ');
                
                return `${processedSelectors} {${declarations}}`;
            });
            
            // Combine theme base styles with namespaced app styles
            return themeBaseStyles + '\n' + namespacedRules.join('\n');
        }

        function executeAppJavaScript(javascript, appId) {
            let namespacedJS = '';
            try {
                // Verify that the app container exists before executing JavaScript
                const contentContainer = document.getElementById(`content_${appId}`);
                if (!contentContainer) {
                    throw new Error(`App content container not found: content_${appId}`);
                }
                
                // Store the JavaScript in a script element for later retrieval
                const scriptElement = document.createElement('script');
                scriptElement.id = `script-${appId}`;
                scriptElement.type = 'text/plain'; // Don't execute it as a script
                scriptElement.textContent = javascript;
                document.head.appendChild(scriptElement);
                
                // Apply namespace isolation to JavaScript
                const helperFunctions = createAppHelperFunctions(appId);
                namespacedJS = namespaceJavaScript(javascript, appId, helperFunctions);
                
                console.log(`Executing JavaScript for app ${appId}`);
                console.log('Original JavaScript:', javascript);
                console.log('Namespaced JavaScript:', namespacedJS);
                
                // Execute JavaScript in global scope so it can access document and DOM
                eval(namespacedJS);
                
                console.log(`JavaScript executed successfully for app ${appId}`);
                
                // Call app init function if it exists (after JavaScript has been executed)
                setTimeout(() => {
                    try {
                        // Ensure data registry is available before calling init
                        if (!window.dataRegistry) {
                            console.error(`Data registry not available for app ${appId}, skipping init`);
                            return;
                        }
                        
                        const appNamespace = 'app_' + appId.replace(/-/g, '_');
                        if (window[appNamespace] && typeof window[appNamespace].init === 'function') {
                            console.log(`Calling init function for app ${appId}`);
                            // Wrap init call in try-catch to handle any data registry errors
                            try {
                                window[appNamespace].init();
                            } catch (initError) {
                                console.error(`Error in init function for app ${appId}:`, initError);
                                // Show user-friendly error message
                                const contentElement = document.getElementById(`content_${appId}`);
                                if (contentElement) {
                                    contentElement.innerHTML = `
                                        <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                            <h3 style="margin: 0 0 15px 0; color: #dc3545;">‚ö†Ô∏è App Initialization Error</h3>
                                            <p style="color: #666; margin: 0 0 10px 0;">The app encountered an error during startup.</p>
                                            <p style="color: #999; font-size: 14px; margin: 0;">${initError.message}</p>
                                            <button onclick="location.reload()" style="margin-top: 15px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Reload Page</button>
                                        </div>
                                    `;
                                }
                                throw initError;
                            }
                        } else {
                            console.warn(`No init function found for app ${appId} - creating fallback initialization`);
                            // Create fallback init function that sets up basic event listeners
                            if (window[appNamespace]) {
                                window[appNamespace].init = function() {
                                    console.log(`Fallback init function called for app ${appId}`);
                                    // Try to set up basic event listeners for common elements
                                    const appContent = document.getElementById(`content_${appId}`);
                                    if (appContent) {
                                        const buttons = appContent.querySelectorAll('button');
                                        const inputs = appContent.querySelectorAll('input');
                                        console.log(`Found ${buttons.length} buttons and ${inputs.length} inputs in app ${appId}`);
                                    }
                                };
                                // Call the fallback init function
                                window[appNamespace].init();
                            }
                        }
                    } catch (initError) {
                        console.warn(`Error calling init function for app ${appId}:`, initError);
                    }
                }, 50); // Small delay to ensure everything is ready
                
            } catch (error) {
                console.error(`JavaScript execution failed for app ${appId}:`, error);
                console.log('Original JavaScript:', javascript);
                console.log('Namespaced JavaScript:', namespacedJS);
                
                // Don't throw the error, just log it and continue
                // This prevents the entire app loading process from failing
                console.warn(`App ${appId} loaded but JavaScript functionality may be limited`);
            }
        }

        function namespaceJavaScript(javascript, appId, helperFunctions = '') {
            // Wrap JavaScript in an IIFE with app namespace
            const namespacedJS = `
(function(appId) {
    // Create app-specific namespace
    const appNamespace = 'app_' + appId.replace(/-/g, '_');
    window[appNamespace] = window[appNamespace] || {};
    
    ${helperFunctions}
    
    // Legacy helper functions for backward compatibility
    const getElementById = (id) => document.getElementById(appId + '_' + id);
    const querySelector = (selector) => document.querySelector('#content_' + appId + ' ' + selector);
    const querySelectorAll = (selector) => document.querySelectorAll('#content_' + appId + ' ' + selector);
    
    // Custom event helpers with namespace
    const dispatchAppEvent = (eventName, detail) => {
        document.dispatchEvent(new CustomEvent(appId + ':' + eventName, { detail }));
    };
    
    const addAppEventListener = (eventName, handler) => {
        document.addEventListener(appId + ':' + eventName, handler);
    };
    
    // Execute the app's JavaScript code
    ${javascript}
    
})('${appId}');
            `;
            
            return namespacedJS;
        }

        function updateAppTitle(appId, newTitle) {
            const app = apps.find(a => a.id === appId);
            if (app) {
                // Don't change titles for system apps
                if (app.isSystemApp) {
                    console.log(`Skipping title update for system app: ${app.title}`);
                    return;
                }
                app.title = newTitle;
                
                // Update window title text
                const windowTitleTextElement = document.querySelector(`#window_${appId} .window-title-text`);
                if (windowTitleTextElement) {
                    windowTitleTextElement.textContent = newTitle;
                }
                
                // Update taskbar icon tooltip
                const iconElement = document.getElementById(`icon_${appId}`);
                if (iconElement) {
                    iconElement.title = newTitle;
                }
            }
        }

        function updateAppIcon(appId, newIcon) {
            const app = apps.find(a => a.id === appId);
            if (app) {
                app.icon = newIcon;
                
                // Update window header icon
                const windowIconElement = document.querySelector(`#window_${appId} .window-icon`);
                if (windowIconElement) {
                    windowIconElement.textContent = newIcon;
                }
                
                // Update taskbar icon
                const taskbarIconElement = document.querySelector(`#icon_${appId} .taskbar-icon`);
                if (taskbarIconElement) {
                    taskbarIconElement.textContent = newIcon;
                }
                
                // Update apps submenu if it's currently visible
                const submenu = document.getElementById('apps-submenu');
                if (submenu && submenu.classList.contains('show')) {
                    updateAppsSubmenuContent();
                }
                
                console.log(`Updated app ${appId} icon to: ${newIcon}`);
            }
        }

        function autoSizeAndCenterWindow(appId) {
            const windowElement = document.getElementById(`window_${appId}`);
            const contentElement = document.getElementById(`content_${appId}`);
            
            if (!windowElement || !contentElement) return;
            
            // Temporarily make content visible and remove size constraints to measure it properly
            const originalDisplay = contentElement.style.display;
            const originalVisibility = contentElement.style.visibility;
            const originalWindowWidth = windowElement.style.width;
            const originalWindowHeight = windowElement.style.height;
            
            // Set content to be fully visible for measurement
            contentElement.style.display = 'block';
            contentElement.style.visibility = 'visible';
            
            // Temporarily set window to auto size to get natural content dimensions
            windowElement.style.width = 'auto';
            windowElement.style.height = 'auto';
            
            // Force a reflow to get accurate measurements
            windowElement.offsetHeight;
            
            // Get the natural size of the content after it's fully rendered
            const contentRect = contentElement.getBoundingClientRect();
            const windowHeaderHeight = 50; // Window header height
            const padding = 40; // Extra padding for better appearance
            const osHeaderHeight = 50; // OS header height
            
            // Calculate optimal window size with generous limits
            const maxAvailableWidth = window.innerWidth - 100; // Leave 50px margin on each side
            const maxAvailableHeight = window.innerHeight - osHeaderHeight - 100; // Leave space for OS header and margins
            
            let optimalWidth = Math.max(350, Math.min(maxAvailableWidth, contentRect.width + padding));
            let optimalHeight = Math.max(250, Math.min(maxAvailableHeight, contentRect.height + windowHeaderHeight + padding));
            
            // Update window size
            windowElement.style.width = optimalWidth + 'px';
            windowElement.style.height = optimalHeight + 'px';
            
            // Center the window in the desktop area
            const desktop = document.getElementById('desktop');
            const desktopRect = desktop.getBoundingClientRect();
            const availableWidth = desktopRect.width;
            const availableHeight = desktopRect.height;
            
            const centerX = Math.max(10, (availableWidth - optimalWidth) / 2);
            const centerY = Math.max(10, (availableHeight - optimalHeight) / 2);
            
            windowElement.style.left = centerX + 'px';
            windowElement.style.top = centerY + 'px';
            
            // Restore original content state
            contentElement.style.display = originalDisplay;
            contentElement.style.visibility = originalVisibility;
        }

        function regenerateApp(appId) {
            const app = apps.find(a => a.id === appId);
            if (app && app.customRequest) {
                processAppWithLLM(app.customRequest, appId);
            }
        }

        function modifyApp(appId, modificationRequest) {
            console.log(`Modifying app ${appId} with request: ${modificationRequest}`);
            
            const app = apps.find(a => a.id === appId);
            if (!app) {
                console.error(`App ${appId} not found`);
                return;
            }
            
            // Create snapshot before modification
            if (window.versionManager) {
                const snapshotDescription = `Before: ${modificationRequest.substring(0, 50)}${modificationRequest.length > 50 ? '...' : ''}`;
                window.versionManager.createSnapshot(appId, snapshotDescription);
            }
            
            // Extract current app code
            const appContentElement = document.getElementById(`content_${appId}`);
            const currentHTML = appContentElement ? appContentElement.innerHTML : '';
            
            // Extract current CSS for this app
            const currentStyleElement = document.getElementById(`style-${appId}`);
            const currentCSS = currentStyleElement ? currentStyleElement.textContent : '';
            
            // Extract current JavaScript for this app
            const currentScriptElement = document.getElementById(`script-${appId}`);
            const currentJavaScript = currentScriptElement ? currentScriptElement.textContent : '';
            
            console.log(`üìÑ Current HTML length: ${currentHTML.length}`);
            console.log(`üé® Current CSS length: ${currentCSS.length}`);
            console.log(`‚öôÔ∏è Current JavaScript length: ${currentJavaScript.length}`);
            
            let thisAppPromptHistory = ''
            app.promptHistory.slice(1).forEach((entry, index) => {
                thisAppPromptHistory += `\n\nPrompt #${index + 1} (${entry.type}):\n${entry.userRequest}`;
            });

            // Get available data objects from registry
            let availableDataObjects = 'None currently registered';
            if (window.dataRegistry && typeof window.dataRegistry.getAllData === 'function') {
                const allData = window.dataRegistry.getAllData();
                if (Object.keys(allData).length > 0) {
                    availableDataObjects = Object.keys(allData).map(key => {
                        const info = window.dataRegistry.getDataInfo ? window.dataRegistry.getDataInfo(key) : {};
                        const data = allData[key];
                        
                        // Analyze structure if not provided
                        let structure = info.structure;
                        if (!structure || structure === 'Unknown structure') {
                            structure = analyzeDataStructure(data);
                        }
                        
                        return `- ${key}: ${info.description || 'No description'} (${structure})`;
                    }).join('\n');
                }
            }

            // Create a modification prompt that includes the current app code
            // Use string concatenation to avoid template literal issues
            const modificationPrompt = ROLE_PROMPT +
                APPMODIFY_PROMPT.replace(/{appId}/g, appId)
                    .replace(/{appTitle}/g, app.title)
                    .replace(/{modificationRequest}/g, modificationRequest)
                    .replace(/{promptHistory}/g, thisAppPromptHistory)
                    .replace(/{availableDataObjects}/g, availableDataObjects)
                    .replace(/{currentHTML}/g, currentHTML)
                    .replace(/{currentCSS}/g, currentCSS)
                    .replace(/{currentJavaScript}/g, currentJavaScript) +
                LIBRARIES_GUIDELINES.replace(/{appId}/g, appId);

            // Show loading state
            const contentElement = document.getElementById(`content_${appId}`);
            if (contentElement) {
                contentElement.innerHTML = SPINNER_ANIMATION;
            }
            
            // Process the modification with LLM
            processAppModificationWithLLM(modificationPrompt, appId, modificationRequest);
        }

        function modifyAppWithImages(appId, modificationData) {
            console.log(`Modifying app ${appId} with request: ${modificationData.text}`);
            console.log(`Including ${modificationData.images.length} images`);
            
            const app = apps.find(a => a.id === appId);
            if (!app) {
                console.error(`App ${appId} not found`);
                return;
            }
            
            // Extract current app code
            const appContentElement = document.getElementById(`content_${appId}`);
            const currentHTML = appContentElement ? appContentElement.innerHTML : '';
            
            // Extract current CSS for this app
            const currentStyleElement = document.getElementById(`style-${appId}`);
            const currentCSS = currentStyleElement ? currentStyleElement.textContent : '';
            
            // Extract current JavaScript for this app
            const currentScriptElement = document.getElementById(`script-${appId}`);
            const currentJavaScript = currentScriptElement ? currentScriptElement.textContent : '';
            
            console.log(`üìÑ Current HTML length: ${currentHTML.length}`);
            console.log(`üé® Current CSS length: ${currentCSS.length}`);
            console.log(`‚öôÔ∏è Current JavaScript length: ${currentJavaScript.length}`);
            
            let thisAppPromptHistory = ''
            if (app.promptHistory && app.promptHistory.length > 1) {
                app.promptHistory.slice(1).forEach((entry, index) => {
                    thisAppPromptHistory += `\n\nPrompt #${index + 1} (${entry.type}):\n${entry.userRequest}`;
                });
            }

            // Get available data objects from registry
            let availableDataObjects = 'None currently registered';
            if (window.dataRegistry && typeof window.dataRegistry.getAllData === 'function') {
                const allData = window.dataRegistry.getAllData();
                if (Object.keys(allData).length > 0) {
                    availableDataObjects = Object.keys(allData).map(key => {
                        const info = window.dataRegistry.getDataInfo ? window.dataRegistry.getDataInfo(key) : {};
                        const data = allData[key];
                        
                        // Analyze structure if not provided
                        let structure = info.structure;
                        if (!structure || structure === 'Unknown structure') {
                            structure = analyzeDataStructure(data);
                        }
                        
                        return `- ${key}: ${info.description || 'No description'} (${structure})`;
                    }).join('\n');
                }
            }

            // Create a modification prompt that includes the current app code
            let modificationPrompt = ROLE_PROMPT +
                APPMODIFY_PROMPT.replace(/{appId}/g, appId)
                    .replace(/{appTitle}/g, app.title)
                    .replace(/{modificationRequest}/g, modificationData.text)
                    .replace(/{promptHistory}/g, thisAppPromptHistory)
                    .replace(/{availableDataObjects}/g, availableDataObjects)
                    .replace(/{currentHTML}/g, currentHTML)
                    .replace(/{currentCSS}/g, currentCSS)
                    .replace(/{currentJavaScript}/g, currentJavaScript) +
                LIBRARIES_GUIDELINES.replace(/{appId}/g, appId);

            // Add image context if images are provided
            if (modificationData.images && modificationData.images.length > 0) {
                modificationPrompt += `\n\nIMAGE CONTEXT:\nThe user has provided ${modificationData.images.length} screenshot(s) to help with the modification. Please analyze the provided images and incorporate any relevant visual information, UI elements, or design patterns shown in the screenshots into your modification of the app.`;
            }

            // Show loading state
            const contentElement = document.getElementById(`content_${appId}`);
            if (contentElement) {
                contentElement.innerHTML = SPINNER_ANIMATION;
            }
            
            // Process the modification with LLM, including images
            processAppModificationWithLLMAndImages(modificationPrompt, appId, modificationData.text, modificationData.images);
        }

        async function processAppModificationWithLLM(prompt, appId, modificationRequest, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`üîÑ Processing app modification (attempt ${retryCount + 1}/${maxRetries}) for app ${appId}`);
                
                // Call LLM API with the modification prompt
                const response = await callLLMAPI(prompt, modificationRequest, 'App Edit Request', appId);
                console.log('Modification response:', response);
                
                if (response && response.html) {
                    console.log(`‚úÖ App modification successful on attempt ${retryCount + 1}`);
                    
                    // Update the app content
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Mark app as dirty after modification
                        if (window.versionManager) {
                            window.versionManager.markAppDirty(appId);
                        }
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Keep the original request but add modification history
                        const app = apps.find(a => a.id === appId);
                        if (app) {
                            if (!app.modificationHistory) {
                                app.modificationHistory = [];
                            }
                            app.modificationHistory.push({
                                request: modificationRequest,
                                timestamp: new Date().toISOString()
                            });
                            // Update the current state to reflect the latest modification
                            app.lastModification = modificationRequest;
                        }
                        
                        // Note: App title and icon are preserved during editing
                        
                        console.log(`App ${appId} successfully modified`);
                        
                        // Save modified app to persistence
                        setTimeout(async () => {
                            try {
                                const app = apps.find(a => a.id === appId);
                                if (app) {
                                    const appData = {
                                        title: app.title || 'Modified App',
                                        icon: app.icon || 'üì±',
                                        html: response.html,
                                        css: response.css || '',
                                        javascript: response.javascript || '',
                                        customRequest: app.customRequest || '',
                                        modificationHistory: app.modificationHistory || [],
                                        lastModification: modificationRequest,
                                        timestamp: new Date().toISOString()
                                    };
                                    
                                    const saveResult = await saveAppToPersistence(appId, appData, {
                                        description: `Modified app: ${appData.title}`,
                                        savePrompt: false
                                    });
                                    
                                    if (saveResult.success) {
                                        console.log(`‚úÖ Modified app ${appId} saved to persistence`);
                                    } else {
                                        console.warn(`‚ö†Ô∏è Failed to save modified app ${appId} to persistence:`, saveResult.error);
                                    }
                                }
                            } catch (error) {
                                console.error(`‚ùå Error saving modified app ${appId} to persistence:`, error);
                            }
                        }, 500);
                    }
                } else {
                    throw new Error('Invalid modification response - missing HTML content');
                }
                
            } catch (error) {
                console.error(`‚ùå App modification failed (attempt ${retryCount + 1}):`, error);
                
                // Don't retry if it's a configuration error
                const isConfigError = error.message.includes('not configured') ||
                                    error.message.includes('API key') ||
                                    error.message.includes('URL not configured');
                
                // Check if we should retry
                if (retryCount < maxRetries - 1 && !isConfigError) {
                    console.log(`üîÑ Retrying modification in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">üîÑ Retrying Modification...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppModificationWithLLM(prompt, appId, modificationRequest, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`üí• All ${maxRetries} modification attempts failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">‚ùå Modification Failed</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        async function processAppModificationWithLLMAndImages(prompt, appId, modificationRequest, images, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`üîÑ Processing app modification with images (attempt ${retryCount + 1}/${maxRetries}) for app ${appId}`);
                
                // Call LLM API with the modification prompt and images
                const response = await callLLMAPIWithImages(prompt, modificationRequest, images, 'App Edit Request with Images', appId);
                console.log('Modification response:', response);
                
                if (response && response.html) {
                    console.log(`‚úÖ App modification with images successful on attempt ${retryCount + 1}`);
                    
                    // Update the app content
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Mark app as dirty after modification
                        if (window.versionManager) {
                            window.versionManager.markAppDirty(appId);
                        }
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Keep the original request but add modification history
                        const app = apps.find(a => a.id === appId);
                        if (app) {
                            if (!app.modificationHistory) {
                                app.modificationHistory = [];
                            }
                            app.modificationHistory.push({
                                request: modificationRequest,
                                timestamp: new Date().toISOString(),
                                hasImages: true,
                                imageCount: images.length
                            });
                            // Update the current state to reflect the latest modification
                            app.lastModification = modificationRequest;
                        }
                        
                        // Note: App title and icon are preserved during editing
                        
                        console.log(`App ${appId} successfully modified with ${images.length} images`);
                        
                        // Save modified app to persistence
                        setTimeout(async () => {
                            try {
                                const app = apps.find(a => a.id === appId);
                                if (app) {
                                    const appData = {
                                        title: app.title || 'Modified App',
                                        icon: app.icon || 'üì±',
                                        html: response.html,
                                        css: response.css || '',
                                        javascript: response.javascript || '',
                                        customRequest: app.customRequest || '',
                                        modificationHistory: app.modificationHistory || [],
                                        lastModification: modificationRequest,
                                        hasImages: true,
                                        imageCount: images.length,
                                        timestamp: new Date().toISOString()
                                    };
                                    
                                    const saveResult = await saveAppToPersistence(appId, appData, {
                                        description: `Modified app with images: ${appData.title}`,
                                        savePrompt: false
                                    });
                                    
                                    if (saveResult.success) {
                                        console.log(`‚úÖ Modified app ${appId} (with images) saved to persistence`);
                                    } else {
                                        console.warn(`‚ö†Ô∏è Failed to save modified app ${appId} to persistence:`, saveResult.error);
                                    }
                                }
                            } catch (error) {
                                console.error(`‚ùå Error saving modified app ${appId} to persistence:`, error);
                            }
                        }, 500);
                    }
                } else {
                    throw new Error('Invalid modification response - missing HTML content');
                }
                
            } catch (error) {
                console.error(`‚ùå App modification with images failed (attempt ${retryCount + 1}):`, error);
                
                // Don't retry if it's a configuration error
                const isConfigError = error.message.includes('not configured') ||
                                    error.message.includes('API key') ||
                                    error.message.includes('URL not configured');
                
                // Check if we should retry
                if (retryCount < maxRetries - 1 && !isConfigError) {
                    console.log(`üîÑ Retrying modification with images in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">üîÑ Retrying Modification...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppModificationWithLLMAndImages(prompt, appId, modificationRequest, images, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`üí• All ${maxRetries} modification attempts with images failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">‚ùå Modification Failed</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        function updateAppCSS(css, appId) {
            // Remove existing app-specific CSS
            const existingStyle = document.getElementById(`style-${appId}`);
            if (existingStyle) {
                existingStyle.remove();
            }
            
            // Add new CSS
            if (css) {
                addAppCSS(css, appId);
            }
        }

        function updateAppJavaScript(javascript, appId) {
            // Remove existing app-specific JavaScript
            const existingScript = document.getElementById(`script-${appId}`);
            if (existingScript) {
                existingScript.remove();
            }
            
            // Add new JavaScript
            if (javascript) {
                const scriptElement = document.createElement('script');
                scriptElement.id = `script-${appId}`;
                scriptElement.textContent = javascript;
                document.head.appendChild(scriptElement);
            }
        }

        function showSettings() {
            const settingsContent = `
                <div class="settings-container">
                    <h2 id="settings-main-title" style="margin: 0 0 20px 0; color: #333; border-bottom: 2px solid #0078d4; padding-bottom: 10px;">‚öôÔ∏è Settings</h2>
                    
                    <div class="settings-categories">
                        <div class="settings-nav">
                            <button class="settings-nav-btn active" data-category="general">üîß General</button>
                            <button class="settings-nav-btn" data-category="appearance">üé® Appearance</button>
                            <button class="settings-nav-btn" data-category="voice">üé§ Voice & Audio</button>
                            <button class="settings-nav-btn" data-category="ai">ü§ñ AI Models</button>
                            <button class="settings-nav-btn" data-category="system">üíª System</button>
                            <button class="settings-nav-btn" data-category="about">‚ÑπÔ∏è About</button>
                        </div>
                        
                        <div class="settings-content">
                            <!-- General Settings -->
                            <div class="settings-panel active" id="general-panel">
                                <h3>General Settings</h3>
                                <div class="setting-item">
                                    <label for="clock-format">Clock Format</label>
                                    <select id="clock-format">
                                        <option value="24" selected>24-hour (HH:MM:SS)</option>
                                        <option value="12">12-hour (h:MM:SS AM/PM)</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Appearance Settings -->
                            <div class="settings-panel" id="appearance-panel">
                                <h3>Appearance Settings</h3>
                                <div class="setting-item">
                                    <label for="theme">Theme</label>
                                    <select id="theme">
                                        <option value="light" selected>Light Mode</option>
                                        <option value="dark">Dark Mode</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Voice & Audio Settings -->
                            <div class="settings-panel" id="voice-panel">
                                <h3>Voice & Audio Settings</h3>
                                <div class="setting-item">
                                    <label for="voice-recognition-type">Voice recognition engine</label>
                                    <select id="voice-recognition-type">
                                        <option value="whisper" selected>OpenAI Whisper (Recommended)</option>
                                        <option value="web">Web Speech API (Browser)</option>
                                    </select>
                                </div>
                                <div class="setting-item">
                                    <label for="web-speech-language">Web Speech API language</label>
                                    <select id="web-speech-language">
                                        <option value="en-US" selected>English (United States)</option>
                                        <option value="en-GB">English (United Kingdom)</option>
                                        <option value="en-AU">English (Australia)</option>
                                        <option value="en-CA">English (Canada)</option>
                                        <option value="en-IN">English (India)</option>
                                        <option value="es-ES">Spanish (Spain)</option>
                                        <option value="es-MX">Spanish (Mexico)</option>
                                        <option value="es-AR">Spanish (Argentina)</option>
                                        <option value="fr-FR">French (France)</option>
                                        <option value="fr-CA">French (Canada)</option>
                                        <option value="de-DE">German (Germany)</option>
                                        <option value="it-IT">Italian (Italy)</option>
                                        <option value="pt-BR">Portuguese (Brazil)</option>
                                        <option value="pt-PT">Portuguese (Portugal)</option>
                                        <option value="ru-RU">Russian (Russia)</option>
                                        <option value="ja-JP">Japanese (Japan)</option>
                                        <option value="ko-KR">Korean (South Korea)</option>
                                        <option value="zh-CN">Chinese (Mandarin, Simplified)</option>
                                        <option value="zh-TW">Chinese (Traditional, Taiwan)</option>
                                        <option value="zh-HK">Chinese (Cantonese, Hong Kong)</option>
                                        <option value="ar-SA">Arabic (Saudi Arabia)</option>
                                        <option value="hi-IN">Hindi (India)</option>
                                        <option value="th-TH">Thai (Thailand)</option>
                                        <option value="vi-VN">Vietnamese (Vietnam)</option>
                                        <option value="nl-NL">Dutch (Netherlands)</option>
                                        <option value="sv-SE">Swedish (Sweden)</option>
                                        <option value="da-DK">Danish (Denmark)</option>
                                        <option value="no-NO">Norwegian (Norway)</option>
                                        <option value="fi-FI">Finnish (Finland)</option>
                                        <option value="pl-PL">Polish (Poland)</option>
                                        <option value="cs-CZ">Czech (Czech Republic)</option>
                                        <option value="hu-HU">Hungarian (Hungary)</option>
                                        <option value="tr-TR">Turkish (Turkey)</option>
                                        <option value="he-IL">Hebrew (Israel)</option>
                                        <option value="id-ID">Indonesian (Indonesia)</option>
                                        <option value="ms-MY">Malay (Malaysia)</option>
                                        <option value="uk-UA">Ukrainian (Ukraine)</option>
                                        <option value="bg-BG">Bulgarian (Bulgaria)</option>
                                        <option value="hr-HR">Croatian (Croatia)</option>
                                        <option value="sk-SK">Slovak (Slovakia)</option>
                                        <option value="sl-SI">Slovenian (Slovenia)</option>
                                        <option value="et-EE">Estonian (Estonia)</option>
                                        <option value="lv-LV">Latvian (Latvia)</option>
                                        <option value="lt-LT">Lithuanian (Lithuania)</option>
                                        <option value="ro-RO">Romanian (Romania)</option>
                                        <option value="el-GR">Greek (Greece)</option>
                                        <option value="ca-ES">Catalan (Spain)</option>
                                        <option value="eu-ES">Basque (Spain)</option>
                                        <option value="gl-ES">Galician (Spain)</option>
                                    </select>
                                </div>
                                <div class="setting-item">
                                    <button id="test-microphone" class="settings-btn">üé§ Test Microphone</button>
                                </div>
                                <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                                    <p style="font-size: 12px; color: #666; margin: 5px 0;">
                                        <strong>OpenAI Whisper:</strong> More accurate, supports multiple languages, requires API key<br>
                                        <strong>Web Speech API:</strong> Free, works offline, limited language support
                                    </p>
                                </div>
                            </div>
                            
                            <!-- AI Models Settings -->
                            <div class="settings-panel" id="ai-panel">
                                <h3>AI Model Settings</h3>
                                
                                <!-- Voice Recognition Section -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">üé§ Voice Recognition</h4>
                                    <div class="setting-item">
                                        <label for="openai-whisper-key">OpenAI Whisper API Key</label>
                                        <input type="password" id="openai-whisper-key" placeholder="sk-proj-...">
                                    </div>
                                    <div class="setting-item">
                                        <label for="openai-whisper-url">OpenAI Whisper API URL</label>
                                        <input type="url" id="openai-whisper-url" value="https://api.openai.com/v1/audio/transcriptions" placeholder="https://api.openai.com/v1/audio/transcriptions">
                                    </div>
                                </div>
                                
                                <!-- Code Generation Section -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">üíª Code Generation</h4>
                                    
                                    <!-- Provider Selection -->
                                    <div class="setting-item">
                                        <label for="llm-provider">LLM Provider</label>
                                        <select id="llm-provider">
                                            <option value="openrouter">OpenRouter</option>
                                            <option value="openai">OpenAI API</option>
                                            <option value="lmstudio">LMStudio</option>
                                        </select>
                                    </div>
                                    
                                    <!-- OpenRouter Configuration -->
                                    <div id="openrouter-config" class="provider-config">
                                        <div class="setting-item">
                                            <label for="openrouter-api-key">OpenRouter API Key</label>
                                            <input type="password" id="openrouter-api-key" placeholder="sk-or-v1-...">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-url">OpenRouter API URL</label>
                                            <input type="url" id="openrouter-url" value="https://openrouter.ai/api/v1/chat/completions" placeholder="https://openrouter.ai/api/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-simple-model">Simple Model Name</label>
                                            <input type="text" id="openrouter-simple-model" value="google/gemini-2.5-flash-lite-preview-06-17" placeholder="google/gemini-2.5-flash-lite-preview-06-17">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-tough-model">Tough Model Name</label>
                                            <input type="text" id="openrouter-tough-model" value="anthropic/claude-sonnet-4" placeholder="anthropic/claude-sonnet-4">
                                        </div>
                                    </div>
                                    
                                    <!-- OpenAI Configuration -->
                                    <div id="openai-config" class="provider-config" style="display: none;">
                                        <div class="setting-item">
                                            <label for="openai-api-key">OpenAI API Key</label>
                                            <input type="password" id="openai-api-key" placeholder="sk-...">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-url">OpenAI API URL</label>
                                            <input type="url" id="openai-url" value="https://api.openai.com/v1/chat/completions" placeholder="https://api.openai.com/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-simple-model">Simple Model Name</label>
                                            <input type="text" id="openai-simple-model" value="gpt-4o-mini" placeholder="gpt-4o-mini">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-tough-model">Tough Model Name</label>
                                            <input type="text" id="openai-tough-model" value="gpt-4o" placeholder="gpt-4o">
                                        </div>
                                    </div>
                                    
                                    <!-- LMStudio Configuration -->
                                    <div id="lmstudio-config" class="provider-config" style="display: none;">
                                        <div class="setting-item">
                                            <label for="lmstudio-url">LMStudio API URL</label>
                                            <input type="url" id="lmstudio-url" value="http://localhost:1234/v1/chat/completions" placeholder="http://localhost:1234/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="lmstudio-simple-model">Simple Model Name</label>
                                            <input type="text" id="lmstudio-simple-model" value="llama-3.2-3b-instruct" placeholder="llama-3.2-3b-instruct">
                                        </div>
                                        <div class="setting-item">
                                            <label for="lmstudio-tough-model">Tough Model Name</label>
                                            <input type="text" id="lmstudio-tough-model" value="llama-3.1-8b-instruct" placeholder="llama-3.1-8b-instruct">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- General Settings -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">‚öôÔ∏è General</h4>
                                    <div class="setting-item">
                                        <label for="api-timeout">API Timeout (seconds)</label>
                                        <input type="number" id="api-timeout" value="30" min="10" max="120">
                                    </div>
                                    <div class="setting-item">
                                        <label for="max-retries">Max Retries</label>
                                        <input type="number" id="max-retries" value="3" min="1" max="10">
                                    </div>
                                    <div class="setting-item">
                                        <label for="cost-tracking">Enable cost tracking</label>
                                        <input type="checkbox" id="cost-tracking" checked>
                                    </div>
                                    <div class="setting-item">
                                        <button id="reset-cost" class="settings-btn">üí∞ Reset Cost Counter</button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- System Settings -->
                            <div class="settings-panel" id="system-panel">
                                <h3>System Settings</h3>
                                <div class="setting-item">
                                    <label for="debug-mode">Debug mode</label>
                                    <input type="checkbox" id="debug-mode">
                                </div>
                                <div class="setting-item">
                                    <button id="clear-cache" class="settings-btn">üóëÔ∏è Clear Cache</button>
                                </div>
                                <div class="setting-item">
                                    <button id="export-settings" class="settings-btn">üì§ Export Settings</button>
                                </div>
                                <div class="setting-item">
                                    <button id="import-settings" class="settings-btn">üì• Import Settings</button>
                                    <input type="file" id="settings-file-input" accept=".json" style="display: none;">
                                </div>
                                <div class="setting-item">
                                    <button id="reset-settings" class="settings-btn">üîÑ Reset All Settings</button>
                                </div>
                            </div>
                            
                            <!-- About Settings -->
                            <div class="settings-panel" id="about-panel">
                                <h3>About Self-Evolving OS</h3>
                                <div class="about-info">
                                    <p><strong>Version:</strong> 2.0.0</p>
                                    <p><strong>Build:</strong> 2025.01.20</p>
                                    <p><strong>Platform:</strong> Web-based OS</p>
                                    <p><strong>AI Models:</strong> OpenAI GPT & Claude</p>
                                    <p><strong>Features:</strong> Voice commands, AI app generation, Dynamic UI</p>
                                    <br>
                                    <p><strong>Total Apps Created:</strong> <span id="total-apps-created">0</span></p>
                                    <p><strong>Current Session Apps:</strong> <span id="current-session-apps">0</span></p>
                                    <p><strong>Total API Cost:</strong> $<span id="total-api-cost">0.00</span></p>
                                    <br>
                                    <p style="font-size: 12px; color: #666;">
                                        Self-Evolving OS is an experimental AI-powered operating system interface
                                        that can create and modify applications on demand using natural language commands.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                </div>
            `;
            
            // Create Settings app directly
            const settingsId = generateAppId();
            const settingsApp = {
                id: settingsId,
                type: 'system',
                title: 'Settings',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System Settings'
            };

            apps.push(settingsApp);
            updateSharedAppsRegistry();
            createWindow(settingsId, 'Settings', settingsContent, 700, 500);
            createTaskbarIcon(settingsId, 'Settings', '‚öôÔ∏è');
            updateAppCount();
            
            // Add settings-specific CSS
            addSettingsCSS(settingsId);
            
            // Add event listeners for settings functionality
            setTimeout(() => {
                initializeSettingsEventListeners(settingsId);
            }, 100);
            
            document.getElementById('start-menu').classList.remove('show');
        }

        function addSettingsCSS(appId) {
            const settingsCSS = `
                .settings-container {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                }
                
                .settings-categories {
                    display: flex;
                    flex: 1;
                    gap: 0;
                }
                
                .settings-nav {
                    width: 200px;
                    background: #f8f9fa;
                    border-right: 1px solid #dee2e6;
                    padding: 10px 0;
                    display: flex;
                    flex-direction: column;
                }
                
                .settings-nav-btn {
                    background: none;
                    border: none;
                    padding: 12px 20px;
                    text-align: left;
                    cursor: pointer;
                    font-size: 14px;
                    color: #495057;
                    transition: all 0.2s ease;
                    border-left: 3px solid transparent;
                }
                
                .settings-nav-btn:hover {
                    background: #e9ecef;
                    color: #0078d4;
                }
                
                .settings-nav-btn.active {
                    background: #e3f2fd;
                    color: #0078d4;
                    border-left-color: #0078d4;
                    font-weight: 600;
                }
                
                .settings-content {
                    flex: 1;
                    padding: 20px;
                    overflow-y: auto;
                }
                
                .settings-panel {
                    display: none;
                }
                
                .settings-panel.active {
                    display: block;
                }
                
                .settings-panel h3 {
                    margin: 0 0 20px 0;
                    color: #333;
                    font-size: 18px;
                    font-weight: 600;
                }
                
                .setting-item {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    padding: 12px 0;
                    border-bottom: 1px solid #f0f0f0;
                }
                
                .setting-item:last-child {
                    border-bottom: none;
                }
                
                .setting-item label {
                    font-weight: 500;
                    color: #333;
                    flex: 1;
                }
                
                .setting-item input, .setting-item select {
                    padding: 6px 10px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 14px;
                }
                
                .setting-item input[type="checkbox"] {
                    width: 18px;
                    height: 18px;
                }
                
                .setting-item input[type="range"] {
                    width: 120px;
                    margin-right: 10px;
                }
                
                .settings-btn {
                    background: #6c757d;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                    transition: background 0.2s ease;
                }
                
                .settings-btn:hover {
                    background: #5a6268;
                }
                
                .settings-btn.primary {
                    background: #0078d4;
                }
                
                .settings-btn.primary:hover {
                    background: #106ebe;
                }
                
                .settings-footer {
                    padding: 15px 20px;
                    border-top: 1px solid #dee2e6;
                    background: #f8f9fa;
                    display: flex;
                    gap: 10px;
                    justify-content: flex-end;
                }
                
                .about-info {
                    line-height: 1.6;
                }
                
                .about-info p {
                    margin: 5px 0;
                }
            `;
            
            addAppCSS(settingsCSS, appId);
        }

        function initializeSettingsEventListeners(settingsId) {
            // Navigation between settings categories
            const navButtons = document.querySelectorAll('.settings-nav-btn');
            const panels = document.querySelectorAll('.settings-panel');
            
            navButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.dataset.category;
                    
                    // Update active nav button
                    navButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Update active panel
                    panels.forEach(p => p.classList.remove('active'));
                    document.getElementById(category + '-panel').classList.add('active');
                });
            });
            
            // Transparency slider
            const transparencySlider = document.getElementById('transparency');
            const transparencyValue = document.getElementById('transparency-value');
            if (transparencySlider && transparencyValue) {
                transparencySlider.addEventListener('input', (e) => {
                    const value = Math.round(e.target.value * 100);
                    transparencyValue.textContent = value + '%';
                });
            }
            
            // Microphone sensitivity slider
            const sensitivitySlider = document.getElementById('microphone-sensitivity');
            const sensitivityValue = document.getElementById('sensitivity-value');
            if (sensitivitySlider && sensitivityValue) {
                sensitivitySlider.addEventListener('input', (e) => {
                    const value = Math.round(e.target.value * 100);
                    sensitivityValue.textContent = value + '%';
                });
            }
            
            // Test microphone button
            const testMicBtn = document.getElementById('test-microphone');
            if (testMicBtn) {
                testMicBtn.addEventListener('click', () => {
                    testMicrophone();
                });
            }
            
            // Reset cost button
            const resetCostBtn = document.getElementById('reset-cost');
            if (resetCostBtn) {
                resetCostBtn.addEventListener('click', () => {
                    showCustomConfirm('Reset the API cost counter to $0.00?', 'Reset Counter').then(confirmed => {
                        if (confirmed) {
                            totalCost = 0;
                            document.getElementById('api-cost').textContent = '0.00';
                            showCustomAlert('Cost counter reset successfully!', 'Success');
                        }
                    });
                });
            }
            
            // Clear cache button
            const clearCacheBtn = document.getElementById('clear-cache');
            if (clearCacheBtn) {
                clearCacheBtn.addEventListener('click', () => {
                    showCustomConfirm('Clear all cached data? This will not affect your current apps.', 'Clear Cache').then(confirmed => {
                        if (confirmed) {
                            // Could implement cache clearing here
                            showCustomAlert('Cache cleared successfully!', 'Success');
                        }
                    });
                });
            }
            
            // Export settings button
            const exportBtn = document.getElementById('export-settings');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    const settings = {
                        version: '2.0.0',
                        exportDate: new Date().toISOString(),
                        settings: {
                            autoSave: document.getElementById('auto-save')?.checked,
                            startupApps: document.getElementById('startup-apps')?.checked,
                            maxApps: document.getElementById('max-apps')?.value,
                            theme: document.getElementById('theme')?.value,
                            transparency: document.getElementById('transparency')?.value,
                            animations: document.getElementById('animations')?.checked,
                            voiceEnabled: document.getElementById('voice-enabled')?.checked,
                            pushToTalk: document.getElementById('push-to-talk')?.checked,
                            debugMode: document.getElementById('debug-mode')?.checked,
                            performanceMode: document.getElementById('performance-mode')?.checked
                        }
                    };
                    
                    const dataStr = JSON.stringify(settings, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = 'self_evolving_os_settings.json';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                });
            }
            
            // Import settings button
            const importBtn = document.getElementById('import-settings');
            const fileInput = document.getElementById('settings-file-input');
            if (importBtn && fileInput) {
                importBtn.addEventListener('click', () => {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const settings = JSON.parse(e.target.result);
                                if (settings.settings) {
                                    // Apply imported settings
                                    Object.keys(settings.settings).forEach(key => {
                                        const element = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());
                                        if (element) {
                                            if (element.type === 'checkbox') {
                                                element.checked = settings.settings[key];
                                            } else {
                                                element.value = settings.settings[key];
                                            }
                                        }
                                    });
                                    showCustomAlert('Settings imported successfully!', 'Success');
                                }
                            } catch (error) {
                                showCustomAlert('Failed to import settings: Invalid file format', 'Error');
                            }
                        };
                        reader.readAsText(file);
                    }
                });
            }
            
            // Reset settings button
            const resetBtn = document.getElementById('reset-settings');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    showCustomConfirm('Reset all settings and restart the setup assistant? This will delete all your current configuration and close all apps.', 'Reset Settings').then(confirmed => {
                        if (confirmed) {
                        // Delete the settings cookie
                        document.cookie = 'selfEvolvingOS_settings=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
                        
                        // Clear any localStorage data
                        localStorage.removeItem('costHistory');
                        
                        // Reset global variables to defaults
                        voiceRecognitionType = 'whisper';
                        CONFIG.OPENAI_API_KEY = 'sk-proj-...';
                        CONFIG.OPENROUTER_API_KEY = 'sk-...';
                        CONFIG.CURRENT_LLM_PROVIDER = 'openrouter';
                        totalCost = 0;
                        costHistory = [];
                        window.costHistory = costHistory;
                        
                        // Update cost display
                        const costElement = document.getElementById('api-cost');
                        if (costElement) {
                            costElement.textContent = '0.00';
                        }
                        
                        // Close all apps
                        [...apps].forEach(app => closeWindow(app.id));
                        
                        // Show confirmation and reload
                        showCustomAlert('Settings reset successfully! The page will reload and the setup assistant will start.', 'Success');
                        
                        // Reload the page to restart with fresh state
                        window.location.reload();
                        }
                    });
                });
            }
            
            // Voice recognition type change handler
            const voiceTypeSelect = document.getElementById('voice-recognition-type');
            if (voiceTypeSelect) {
                voiceTypeSelect.addEventListener('change', async (e) => {
                    const newType = e.target.value;
                    console.log(`Switching voice recognition from ${voiceRecognitionType} to ${newType}`);
                    
                    // Stop current voice session if active
                    if (isListening) {
                        stopVoiceSession();
                    }
                    
                    // Update the global setting
                    voiceRecognitionType = newType;
                    
                    // Re-initialize voice system with new type
                    try {
                        await initializeVoice();
                        console.log(`Voice system re-initialized with ${newType}`);
                        
                        // Show confirmation
                        const statusMsg = newType === 'web' ?
                            'Switched to Web Speech API (Browser-based)' :
                            'Switched to OpenAI Whisper (Cloud-based)';
                        
                        // Temporarily show status
                        updateVoiceStatus(statusMsg, 'ready');
                        setTimeout(() => {
                            updateVoiceStatus(`Voice Ready (${newType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
                        }, 3000);
                        
                    } catch (error) {
                        console.error('Failed to re-initialize voice system:', error);
                        updateVoiceStatus('Voice Error', 'error');
                        
                        // Revert the selection if initialization failed
                        voiceTypeSelect.value = voiceRecognitionType === 'web' ? 'whisper' : 'web';
                        voiceRecognitionType = voiceTypeSelect.value;
                    }
                });
            }
            
            // Web Speech API language change handler
            const webSpeechLanguageSelect = document.getElementById('web-speech-language');
            if (webSpeechLanguageSelect) {
                webSpeechLanguageSelect.addEventListener('change', async (e) => {
                    const newLanguage = e.target.value;
                    console.log(`Changing Web Speech API language to: ${newLanguage}`);
                    
                    // If currently using Web Speech API, re-initialize with new language
                    if (voiceRecognitionType === 'web') {
                        // Stop current voice session if active
                        if (isListening) {
                            stopVoiceSession();
                        }
                        
                        try {
                            await initializeVoice();
                            console.log(`Web Speech API re-initialized with language: ${newLanguage}`);
                            
                            // Show confirmation
                            const languageText = e.target.options[e.target.selectedIndex].text;
                            updateVoiceStatus(`Language changed to ${languageText}`, 'ready');
                            setTimeout(() => {
                                updateVoiceStatus('Voice Ready (Web)', 'ready');
                            }, 3000);
                            
                        } catch (error) {
                            console.error('Failed to re-initialize Web Speech API with new language:', error);
                            updateVoiceStatus('Language Change Error', 'error');
                            setTimeout(() => {
                                updateVoiceStatus('Voice Ready (Web)', 'ready');
                            }, 2000);
                        }
                    }
                });
            }
            
            // Update about info
            const totalAppsElement = document.getElementById('total-apps-created');
            const currentAppsElement = document.getElementById('current-session-apps');
            const totalCostElement = document.getElementById('total-api-cost');
            
            if (totalAppsElement) totalAppsElement.textContent = nextAppId - 1;
            if (currentAppsElement) currentAppsElement.textContent = apps.length;
            if (totalCostElement) totalCostElement.textContent = totalCost.toFixed(4);
            
            // Auto-save settings when any input changes
            const settingsInputs = document.querySelectorAll('.settings-panel input, .settings-panel select');
            settingsInputs.forEach(input => {
                input.addEventListener('change', () => {
                    const settings = saveSettingsToCookie();
                    applySettingsToSystem(settings);
                    console.log('Settings auto-saved and applied');
                });
            });
            
            // Theme change handler for immediate application
            const themeSelect = document.getElementById('theme');
            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    const newTheme = e.target.value;
                    applyTheme(newTheme);
                });
            }
            
            // Clock format change handler for immediate application
            const clockFormatSelect = document.getElementById('clock-format');
            if (clockFormatSelect) {
                clockFormatSelect.addEventListener('change', (e) => {
                    // Immediately update the clock display when format changes
                    updateClock();
                    console.log(`Theme changed to: ${newTheme}`);
                });
            }
            
            // API Settings change handlers for immediate application
            const apiSettingsInputs = [
                'openai-whisper-key',
                'openai-whisper-url',
                'openrouter-api-key',
                'openrouter-url',
                'openrouter-simple-model',
                'openrouter-tough-model',
                'openai-api-key',
                'openai-url',
                'openai-simple-model',
                'openai-tough-model',
                'lmstudio-url',
                'lmstudio-simple-model',
                'lmstudio-tough-model'
            ];
            
            apiSettingsInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', () => {
                        const settings = saveSettingsToCookie();
                        applySettingsToSystem(settings);
                        console.log(`API setting ${inputId} updated and applied`);
                    });
                }
            });
            
            // Load and apply saved settings
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                applySettingsToUI(savedSettings);
                applySettingsToSystem(savedSettings);
            }
    
            // LLM Provider switching functionality
            function initializeLLMProviderSwitching() {
                const providerSelect = document.getElementById('llm-provider');
                if (!providerSelect) return;
                
                // Show/hide provider configurations based on selection
                function showProviderConfig(provider) {
                    // Hide all provider configs
                    document.querySelectorAll('.provider-config').forEach(config => {
                        config.style.display = 'none';
                    });
                    
                    // Show selected provider config
                    const selectedConfig = document.getElementById(`${provider}-config`);
                    if (selectedConfig) {
                        selectedConfig.style.display = 'block';
                    }
                    
                    // Update current provider display in header
                    updateCurrentProviderDisplay(provider);
                }
                
                // Handle provider selection change
                providerSelect.addEventListener('change', (e) => {
                    const selectedProvider = e.target.value;
                    showProviderConfig(selectedProvider);
                    
                    // Save settings when provider changes
                    const settings = saveSettingsToCookie();
                    
                    // Apply settings immediately to CONFIG object
                    applySettingsToSystem(settings);
                    
                    // Update provider display to show new provider and current model
                    updateCurrentProviderDisplay(selectedProvider);
                    
                    debugLog(`LLM Provider changed to: ${selectedProvider}`);
                });
                
                // Initialize with current selection
                showProviderConfig(providerSelect.value);
            }
    
            // Update the current provider display in the header
            function updateCurrentProviderDisplay(provider) {
                const providerDisplay = document.getElementById('current-provider-display');
                if (providerDisplay) {
                    const providerNames = {
                        'openrouter': 'OpenRouter',
                        'openai': 'OpenAI',
                        'lmstudio': 'LMStudio'
                    };
                    const displayName = providerNames[provider] || provider;
                    
                    // Add current model in brackets
                    const currentModel = CONFIG.MODEL || 'Unknown';
                    providerDisplay.textContent = `${displayName} (${currentModel})`;
                }
            }
            
            // Initialize cost tracking
            loadCostHistory();
            
            // Initialize LLM provider switching
            initializeLLMProviderSwitching();
            
            // Load and display current LLM provider from settings
            const providerSettings = loadSettingsFromCookie();
            if (providerSettings && providerSettings.llmProvider) {
                updateCurrentProviderDisplay(providerSettings.llmProvider);
            } else {
                updateCurrentProviderDisplay('openrouter'); // Default
            }
            
        }

        // Initialize the system when page loads
        window.addEventListener('load', init);

        // Handle Enter key in app request input
        document.addEventListener('keypress', function(e) {
            if (e.target.id === 'app-request' && e.key === 'Enter') {
                requestApp();
            }
        });

        // Initialize voice recognition on page load
        // Voice system will be initialized by DOMContentLoaded event handler above
    </script>
</body>
</html>