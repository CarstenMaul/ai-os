<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Evolving OS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .desktop {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .taskbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
        }

        .start-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            margin-right: 20px;
            min-height: 44px;
            transition: all 0.2s ease;
        }

        .start-button:hover {
            background: #106ebe;
        }

        .model-toggle-container {
            margin-right: 20px;
        }

        .model-toggle-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            min-height: 36px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .model-toggle-button:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .model-toggle-button.tough-mode {
            background: #dc3545;
        }

        .model-toggle-button.tough-mode:hover {
            background: #c82333;
        }

        .app-icons {
            display: flex;
            gap: 10px;
            flex: 1;
        }

        .app-icon {
            min-width: 60px;
            max-width: 120px;
            height: 35px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 11px;
            text-align: center;
            transition: background 0.2s;
            padding: 0 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .app-icon:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .app-icon.active {
            background: rgba(255, 255, 255, 0.4);
        }

        .window {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-width: 300px;
            min-height: 200px;
            z-index: 9999;
            overflow: hidden;
        }

        .window.maximized {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: calc(100% - 50px) !important;
            border-radius: 0;
        }

        .window.minimized {
            display: none;
        }

        .window-header {
            background: #f0f0f0;
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            -webkit-user-select: none;
            user-select: none;
            min-height: 50px;
        }

        .window-title {
            font-weight: bold;
            color: #333;
        }

        .window-controls {
            display: flex;
            gap: 8px;
        }

        .window-control {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .minimize { background: #ffc107; }
        .maximize { background: #28a745; }
        .close { background: #dc3545; color: white; }

        .window-control:hover {
            opacity: 0.8;
        }

        .window-voice-button {
            width: 40px;
            height: 40px;
            border: none;
            background: #007bff;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .window-voice-button:hover {
            background: #0056b3;
        }

        .window-voice-button.recording {
            background: #dc3545;
            animation: pulse 1s infinite;
        }

        .window-text-button {
            width: 40px;
            height: 40px;
            border: none;
            background: #28a745;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .window-text-button:hover {
            background: #218838;
        }

        .window-download-button {
            width: 40px;
            height: 40px;
            border: none;
            background: #6f42c1;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .window-download-button:hover {
            background: #5a32a3;
        }

        .window-content {
            padding: 20px;
            height: calc(100% - 81px);
            overflow: auto;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: se-resize;
            background: linear-gradient(-45deg, transparent 0%, transparent 40%, #ccc 40%, #ccc 60%, transparent 60%);
        }

        .start-menu {
            position: fixed;
            bottom: 50px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 20px;
            display: none;
            z-index: 1001;
        }

        .start-menu.show {
            display: block;
        }

        .menu-section {
            margin-bottom: 20px;
        }

        .menu-title {
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .menu-item {
            padding: 15px 20px;
            color: white;
            cursor: pointer;
            border-radius: 6px;
            margin-bottom: 8px;
            transition: background 0.2s;
            font-size: 16px;
            min-height: 44px;
            display: flex;
            align-items: center;
        }

        .menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .request-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .request-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        .request-button:hover {
            background: #106ebe;
        }

        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            font-size: 12px;
            z-index: 1000;
        }

        .voice-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .voice-button {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }

        .voice-button:hover {
            background: #c82333;
        }

        .voice-button.listening {
            background: #28a745;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .voice-status {
            font-size: 11px;
            color: #ccc;
        }

        /* Voice Command Popup */
        .voice-command-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            font-size: 18px;
            font-weight: 500;
            text-align: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
            max-width: 80%;
            word-wrap: break-word;
        }

        .voice-command-popup.show {
            opacity: 1;
        }

        .voice-command-popup.fade-out {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        .voice-command-popup::before {
            content: '🎤';
            display: block;
            font-size: 24px;
            margin-bottom: 10px;
        }

        /* Theme Styles */
        body.dark-theme {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
        }

        body.dark-theme .taskbar {
            background: rgba(0, 0, 0, 0.9);
            color: #f8f9fa;
        }

        body.dark-theme .start-menu {
            background: rgba(0, 0, 0, 0.95);
            color: #f8f9fa;
        }

        body.dark-theme .window {
            background: #2c3e50;
            color: #f8f9fa;
        }

        body.dark-theme .window-header {
            background: #34495e;
            border-bottom: 1px solid #4a5f7a;
            color: #f8f9fa;
        }

        body.dark-theme .window-content {
            background: #2c3e50;
            color: #f8f9fa;
        }

        body.dark-theme .status-bar {
            background: rgba(0, 0, 0, 0.9);
            color: #f8f9fa;
        }

        body.dark-theme .settings-container {
            background: #2c3e50;
            color: #f8f9fa;
        }

        body.dark-theme .settings-nav {
            background: #34495e;
            border-right: 1px solid #4a5f7a;
        }

        body.dark-theme .settings-nav-btn {
            color: #e9ecef !important;
            font-weight: 500;
        }

        body.dark-theme .settings-nav-btn:hover {
            background: #4a5f7a;
            color: #ffffff !important;
        }

        body.dark-theme .settings-nav-btn.active {
            background: #3498db;
            color: #ffffff !important;
            border-left-color: #3498db;
        }

        body.dark-theme .setting-item {
            border-bottom: 1px solid #4a5f7a;
        }

        body.dark-theme .setting-item label {
            color: #f8f9fa !important;
            font-weight: 500;
        }

        body.dark-theme .setting-item input,
        body.dark-theme .setting-item select {
            background: #34495e;
            border: 1px solid #4a5f7a;
            color: #f8f9fa;
        }

        body.dark-theme .settings-footer {
            background: #34495e;
            border-top: 1px solid #4a5f7a;
        }

        /* Enhanced Dark Mode text contrast */
        body.dark-theme h1,
        body.dark-theme h2,
        body.dark-theme h3,
        body.dark-theme h4,
        body.dark-theme h5,
        body.dark-theme h6 {
            color: #ffffff !important;
            font-weight: 600;
        }

        body.dark-theme .settings-header h1,
        body.dark-theme .settings-header h2,
        body.dark-theme .settings-title {
            color: #ffffff !important;
            font-weight: 700;
        }

        body.dark-theme .settings-content h3 {
            color: #ffffff !important;
            font-weight: 600;
        }

        body.dark-theme p {
            color: #e9ecef !important;
        }

        body.dark-theme .menu-title {
            color: #ffffff !important;
            font-weight: 600;
        }

        body.dark-theme .menu-item {
            color: #f8f9fa !important;
            font-weight: 500;
        }

        body.dark-theme .menu-item:hover {
            background: rgba(52, 152, 219, 0.2) !important;
            color: #ffffff !important;
        }

        body.dark-theme .start-button {
            color: #f8f9fa !important;
            font-weight: 600;
        }

        body.dark-theme .model-toggle-button {
            color: #f8f9fa !important;
            border: 1px solid #4a5f7a !important;
        }

        /* Specific fix for Settings header with inline style override */
        body.dark-theme #settings-main-title {
            color: #ffffff !important;
            font-weight: 700;
            text-shadow: none;
        }

        body.dark-theme .settings-container h1,
        body.dark-theme .settings-container h2,
        body.dark-theme .settings-container .settings-title,
        body.dark-theme .settings-panel h3 {
            color: #ffffff !important;
            font-weight: 700;
            text-shadow: none;
        }

        /* Fix for any remaining dim text */
        body.dark-theme * {
            color: inherit;
        }

        body.dark-theme .settings-content {
            color: #f8f9fa !important;
        }

        body.light-theme {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        body.light-theme .taskbar {
            background: rgba(255, 255, 255, 0.95);
            color: #212529;
        }

        body.light-theme .start-menu {
            background: rgba(255, 255, 255, 0.98);
            color: #212529;
            border: 1px solid #dee2e6;
        }

        body.light-theme .window {
            background: white;
            color: #212529;
        }

        body.light-theme .window-header {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            color: #333;
        }

        body.light-theme .window-content {
            background: white;
            color: #333;
        }

        body.light-theme .status-bar {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        body.light-theme .settings-container {
            background: white;
            color: #333;
        }

        body.light-theme .settings-nav {
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
        }

        body.light-theme .settings-nav-btn {
            color: #495057;
        }

        body.light-theme .settings-nav-btn:hover {
            background: #e9ecef;
            color: #0078d4;
        }

        body.light-theme .settings-nav-btn.active {
            background: #e3f2fd;
            color: #0078d4;
            border-left-color: #0078d4;
        }

        body.light-theme .setting-item {
            border-bottom: 1px solid #f0f0f0;
        }

        body.light-theme .setting-item label {
            color: #212529;
            font-weight: 500;
        }

        body.light-theme .setting-item input,
        body.light-theme .setting-item select {
            background: white;
            border: 1px solid #ced4da;
            color: #212529;
        }

        body.light-theme .settings-footer {
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
        }

        /* Enhanced Start Menu contrast for Light Theme */
        body.light-theme .menu-title {
            color: #495057 !important;
            font-weight: 600;
        }

        body.light-theme .menu-item {
            color: #212529 !important;
            font-weight: 500;
        }

        body.light-theme .menu-item:hover {
            background: rgba(0, 123, 255, 0.1) !important;
            color: #0056b3 !important;
        }

        body.light-theme .request-input {
            color: #212529 !important;
            border: 1px solid #ced4da !important;
        }

        body.light-theme .request-input::placeholder {
            color: #6c757d !important;
        }

        body.light-theme .request-button {
            background: #007bff !important;
            color: white !important;
            border: none !important;
        }

        body.light-theme .request-button:hover {
            background: #0056b3 !important;
        }

        body.light-theme .start-button {
            color: #212529 !important;
            font-weight: 600;
        }

        body.light-theme .model-toggle-button {
            color: #212529 !important;
            border: 1px solid #ced4da !important;
        }
    </style>
</head>
<body>
    <div class="desktop" id="desktop">
        <!-- Windows will be dynamically created here -->
    </div>

    <div class="status-bar">
        <div class="status-info">
            <span id="clock"></span> | Apps: <span id="app-count">0</span> | Cost: $<span id="api-cost">0.00</span> | LLM: <span id="current-provider-display">OpenRouter</span>
        </div>
        <div class="voice-controls">
            <span class="voice-status" id="voice-status">Voice Ready</span>
            <button class="voice-button" id="voice-button" title="Click or Hold to Talk">🎤</button>
        </div>
    </div>

    <!-- Voice Command Popup -->
    <div class="voice-command-popup" id="voice-command-popup"></div>

    <div class="taskbar">
        <button class="start-button" onclick="toggleStartMenu()">Start</button>
        <div class="model-toggle-container">
            <button class="model-toggle-button" id="model-toggle" onclick="toggleModelMode()">
                <span id="model-mode-text">Simple</span>
            </button>
        </div>
        <div class="app-icons" id="app-icons">
            <!-- App icons will be dynamically created here -->
        </div>
    </div>

    <div class="start-menu" id="start-menu">
        <div class="menu-section">
            <div class="menu-title">Request New App</div>
            <input type="text" class="request-input" id="app-request" placeholder="Describe the app you want (e.g., calculator, calendar, quiz app, weather app, etc.)">
            <button class="request-button" onclick="requestApp()">Create App with AI</button>
        </div>
        
        <div class="menu-section">
            <div class="menu-title">Voice Commands</div>
            <p style="color: #ccc; font-size: 12px; margin: 0;">Click the microphone button in the top-right corner and say:</p>
            <p style="color: #ccc; font-size: 11px; margin: 5px 0 0 0;">"Create a calculator app" or "Make me a todo list"</p>
        </div>

        <div class="menu-section">
            <div class="menu-title">System</div>
            <div class="menu-item" onclick="showSettings()">⚙️ Settings</div>
            <div class="menu-item" onclick="showAppList()">📋 App Manager</div>
            <div class="menu-item" onclick="triggerLoadApp()">📁 Load App</div>
            <div class="menu-item" onclick="closeAllApps()">❌ Close All Apps</div>
        </div>
    </div>

    <script>
        // Global app management system
        let apps = [];
        let nextAppId = 1;
        let activeWindow = null;
        let dragData = null;
        let resizeData = null;

        // Initialize the system
        function init() {
            updateClock();
            setInterval(updateClock, 1000);
            updateAppCount();
            
            // Load and apply saved settings on startup BEFORE voice initialization
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                applySettingsToSystem(savedSettings);
                console.log('Loaded settings from cookie on startup');
            } else {
                // No settings found - start setup assistant
                console.log('No settings found, starting setup assistant');
                setTimeout(() => startSetupAssistant(), 500);
            }
            
            // Close start menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.start-menu') && !e.target.closest('.start-button')) {
                    document.getElementById('start-menu').classList.remove('show');
                }
            });
        }

        function updateClock() {
            const now = new Date();
            document.getElementById('clock').textContent = now.toLocaleTimeString();
        }

        function updateAppCount() {
            document.getElementById('app-count').textContent = apps.length;
        }

        function toggleStartMenu() {
            const menu = document.getElementById('start-menu');
            menu.classList.toggle('show');
        }

        function toggleModelMode() {
            const toggleButton = document.getElementById('model-toggle');
            const modeText = document.getElementById('model-mode-text');
            
            if (currentModelMode === 'Simple') {
                // Switch to Tough mode
                currentModelMode = 'Tough';
                CONFIG.MODEL = CONFIG.MODEL_TOUGH;
                modeText.textContent = 'Tough';
                toggleButton.classList.add('tough-mode');
            } else {
                // Switch to Simple mode
                currentModelMode = 'Simple';
                CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                modeText.textContent = 'Simple';
                toggleButton.classList.remove('tough-mode');
            }
            
            console.log(`Model mode switched to: ${currentModelMode} (${CONFIG.MODEL})`);
        }

        function generateAppId() {
            return `app_${nextAppId++}`;
        }

        function createWindow(appId, title, content, width = 400, height = 300) {
            const desktop = document.getElementById('desktop');
            const window = document.createElement('div');
            window.className = 'window';
            window.id = `window_${appId}`;
            window.style.width = width + 'px';
            window.style.height = height + 'px';
            
            // Center the window in the desktop area (below header)
            const headerHeight = 50;
            const desktopRect = desktop.getBoundingClientRect();
            const availableWidth = desktopRect.width;
            const availableHeight = desktopRect.height;
            
            window.style.left = Math.max(0, (availableWidth - width) / 2) + 'px';
            window.style.top = Math.max(10, (availableHeight - height) / 2) + 'px';
            
            // Z-index is now handled by CSS class (9999)

            window.innerHTML = `
                <div class="window-header" onmousedown="startDrag(event, '${appId}')">
                    <div class="window-title" ontouchstart="startDrag(event, '${appId}')">${title}</div>
                    <div class="window-controls">
                        <button class="window-voice-button" id="voice-button-${appId}" title="Hold to talk - Modify this app with voice">🎤</button>
                        <button class="window-text-button" id="text-button-${appId}" title="Edit this app with text prompt">✏️</button>
                        <button class="window-download-button" id="download-button-${appId}" title="Download this app">💾</button>
                        <button class="window-control minimize" onclick="minimizeWindow('${appId}')">−</button>
                        <button class="window-control maximize" onclick="toggleMaximize('${appId}')">□</button>
                        <button class="window-control close" onclick="closeWindow('${appId}')">×</button>
                    </div>
                </div>
                <div class="window-content" id="content_${appId}">
                    ${content}
                </div>
                <div class="resize-handle" onmousedown="startResize(event, '${appId}')"></div>
            `;

            desktop.appendChild(window);
            
            // Apply current theme to the app content
            applyThemeToApp(appId);
            
            // Dispatch app shown event for newly created apps
            setTimeout(() => dispatchAppShownEvent(appId), 100); // Small delay to ensure app is fully rendered
            
            // Add push-to-talk event handlers to the app voice button
            const appVoiceButton = document.getElementById(`voice-button-${appId}`);
            if (appVoiceButton) {
                // Mouse events for push-to-talk
                appVoiceButton.addEventListener('mousedown', function(e) {
                    if (e.button === 0) { // Left mouse button
                        e.preventDefault();
                        startAppVoiceCommand(appId);
                    }
                });

                appVoiceButton.addEventListener('mouseup', function(e) {
                    if (e.button === 0) { // Left mouse button
                        e.preventDefault();
                        stopAppVoiceCommand(appId);
                    }
                });

                // Touch events for mobile push-to-talk
                appVoiceButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startAppVoiceCommand(appId);
                });

                appVoiceButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    stopAppVoiceCommand(appId);
                });

                // Click event as fallback (toggle behavior)
                appVoiceButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (!isListening || currentModifyingAppId !== appId) {
                        startAppVoiceCommand(appId);
                    } else {
                        stopAppVoiceCommand(appId);
                    }
                });
            }
            
            // Add event listener to the app text button
            const appTextButton = document.getElementById(`text-button-${appId}`);
            if (appTextButton) {
                appTextButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    showTextPromptDialog(appId);
                });
            }
            
            // Add event listener to the app download button
            const appDownloadButton = document.getElementById(`download-button-${appId}`);
            if (appDownloadButton) {
                appDownloadButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    downloadApp(appId);
                });
            }
            
            bringToFront(appId);
            return window;
        }

        function createApp(customRequest) {
            const appId = generateAppId();
            const title = 'New App';
            const content = createAIGeneratedAppContent(customRequest, appId);

            const app = {
                id: appId,
                type: 'ai-generated',
                title: title,
                isMinimized: false,
                isMaximized: false,
                customRequest: customRequest
            };

            apps.push(app);
            createWindow(appId, title, content);
            createTaskbarIcon(appId, title);
            updateAppCount();

            return appId;
        }

        function createTaskbarIcon(appId, title) {
            const iconsContainer = document.getElementById('app-icons');
            const icon = document.createElement('div');
            icon.className = 'app-icon';
            icon.id = `icon_${appId}`;
            icon.onclick = () => toggleWindow(appId);
            icon.textContent = title.substring(0, 3);
            icon.title = title;
            iconsContainer.appendChild(icon);
        }

        function requestApp() {
            const request = document.getElementById('app-request').value.trim();
            if (request) {
                createApp(request);
                document.getElementById('app-request').value = '';
                document.getElementById('start-menu').classList.remove('show');
            }
        }

        // Voice Recognition System using OpenAI Realtime API
        let isListening = false;

        // Initialize voice system on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up voice system...');
            
            // Voice button event handlers for Whisper API - attach immediately
            const voiceButton = document.getElementById('voice-button');
            console.log('Voice button element:', voiceButton);
            
            if (voiceButton) {
                voiceButton.addEventListener('click', function() {
                    console.log('Voice button clicked!'); // Debug log
                    if (!isListening) {
                        startVoiceSession();
                    } else {
                        stopVoiceSession();
                    }
                });
                console.log('Voice button click handler attached');
            } else {
                console.error('Voice button element not found!');
            }
            
            // Load saved settings first, then initialize voice system
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                if (savedSettings.voiceRecognitionType) {
                    voiceRecognitionType = savedSettings.voiceRecognitionType;
                    console.log(`Loaded voice recognition type from settings: ${voiceRecognitionType}`);
                }
                
                // Also apply the Web Speech API language if it's saved
                if (savedSettings.webSpeechLanguage && voiceRecognitionType === 'web') {
                    console.log(`Loaded Web Speech API language from settings: ${savedSettings.webSpeechLanguage}`);
                }
            }
            
            // Initialize voice in background (non-blocking) with correct settings
            initializeVoice().then(() => {
                console.log('Voice system initialized successfully');
            }).catch((error) => {
                console.warn('Voice initialization failed:', error);
                updateVoiceStatus('Voice Error', 'error');
            });

            // Also support mousedown/mouseup for push-to-talk
            document.getElementById('voice-button').addEventListener('mousedown', function(e) {
                if (e.button === 0 && !isListening) { // Left mouse button
                    startVoiceSession();
                }
            });

            document.getElementById('voice-button').addEventListener('mouseup', function(e) {
                if (e.button === 0 && isListening) { // Left mouse button
                    stopVoiceSession();
                }
            });

            // Touch events for mobile
            document.getElementById('voice-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (!isListening) {
                    startVoiceSession();
                }
            });

            document.getElementById('voice-button').addEventListener('touchend', function(e) {
                e.preventDefault();
                if (isListening) {
                    stopVoiceSession();
                }
            });

            // Initialize model mode to Simple (default)
            CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
            console.log(`Model initialized to: ${currentModelMode} mode (${CONFIG.MODEL})`);
        });

        // Voice Handler supporting both Whisper and Web Speech API
        async function initializeVoice() {
            try {
                // Check Web Speech API support
                isWebSpeechSupported = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
                
                if (voiceRecognitionType === 'web' && isWebSpeechSupported) {
                    // Initialize Web Speech API
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    webSpeechRecognition = new SpeechRecognition();
                    webSpeechRecognition.continuous = false;
                    webSpeechRecognition.interimResults = false;
                    
                    // Get selected language from settings or saved settings or default to en-US
                    let selectedLanguage = 'en-US';
                    
                    // First try to get from UI element
                    const languageSelect = document.getElementById('web-speech-language');
                    if (languageSelect && languageSelect.value) {
                        selectedLanguage = languageSelect.value;
                    } else {
                        // If UI element not available, try to get from saved settings
                        const savedSettings = loadSettingsFromCookie();
                        if (savedSettings && savedSettings.webSpeechLanguage) {
                            selectedLanguage = savedSettings.webSpeechLanguage;
                        }
                    }
                    
                    webSpeechRecognition.lang = selectedLanguage;
                    console.log(`Web Speech API initialized with language: ${selectedLanguage}`);
                    
                    webSpeechRecognition.onresult = function(event) {
                        const transcript = event.results[0][0].transcript;
                        console.log('Web Speech transcript:', transcript);
                        handleVoiceTranscription(transcript);
                    };
                    
                    webSpeechRecognition.onerror = function(event) {
                        console.error('Web Speech error:', event.error);
                        updateVoiceStatus('Voice Error', 'error');
                        isListening = false;
                    };
                    
                    webSpeechRecognition.onend = function() {
                        console.log('Web Speech ended');
                        isListening = false;
                        updateVoiceStatus('Voice Ready', 'ready');
                    };
                    
                    updateVoiceStatus('Voice Ready (Web)', 'ready');
                    return true;
                } else {
                    // Initialize Whisper API (requires microphone access)
                    mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                    
                    updateVoiceStatus('Voice Ready (Whisper)', 'ready');
                    return true;
                }
            } catch (error) {
                console.error('Voice initialization failed:', error);
                updateVoiceStatus('Voice Error', 'error');
                return false;
            }
        }

        async function startVoiceSession() {
            console.log(`🎙️ startVoiceSession() called with type: ${voiceRecognitionType}`);
            console.log(`🔍 isListening: ${isListening}`);
            
            if (isListening) {
                console.log(`❌ Already listening, returning early`);
                return;
            }
            
            try {
                isListening = true;
                updateVoiceStatus('Recording...', 'listening');
                console.log('✅ Voice session starting...');
                
                if (voiceRecognitionType === 'web' && isWebSpeechSupported && webSpeechRecognition) {
                    // Use Web Speech API
                    console.log('🌐 Starting Web Speech Recognition...');
                    webSpeechRecognition.start();
                } else {
                    // Use Whisper API
                    console.log('🎤 Starting Whisper recording...');
                    
                    if (!mediaStream) {
                        console.log(`❌ No mediaStream available, initializing...`);
                        try {
                            await initializeVoice();
                            console.log(`✅ Voice system re-initialized`);
                        } catch (error) {
                            console.error(`❌ Failed to re-initialize voice system:`, error);
                            updateVoiceStatus('Voice Error', 'error');
                            isListening = false;
                            return;
                        }
                    }
                    
                    // Start recording audio for Whisper
                    mediaRecorder = new MediaRecorder(mediaStream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    // Clear and initialize audio chunks array
                    audioChunks = [];
                    console.log(`🧹 Initialized fresh audioChunks array, length: ${audioChunks.length}`);
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        console.log('Recording stopped, processing audio...');
                        updateVoiceStatus('Processing...', 'processing');
                        
                        // Create audio blob
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        
                        // Send to Whisper API
                        await transcribeAudio(audioBlob);
                    };
                    
                    mediaRecorder.start();
                }
                
            } catch (error) {
                console.error('Failed to start voice session:', error);
                stopVoiceSession();
                updateVoiceStatus('Voice Error', 'error');
            }
        }

        function handleVoiceTranscription(transcription) {
            console.log('Voice transcription received:', transcription);
            
            if (transcription.trim()) {
                // Show voice command popup
                showVoiceCommandPopup(transcription.trim());
                
                // Check if we're modifying an existing app or creating a new one
                if (currentModifyingAppId) {
                    // Modify existing app
                    modifyApp(currentModifyingAppId, transcription.trim());
                    
                    // Reset the voice button appearance
                    const voiceButton = document.querySelector(`#window_${currentModifyingAppId} .window-voice-button`);
                    if (voiceButton) {
                        voiceButton.classList.remove('recording');
                    }
                    
                    // Clear the modifying app ID
                    currentModifyingAppId = null;
                } else {
                    // Create new app based on voice command
                    createApp(transcription.trim());
                }
                
                updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
            } else {
                updateVoiceStatus('No speech detected', 'error');
                setTimeout(() => updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready'), 2000);
            }
        }

        async function transcribeAudio(audioBlob) {
            try {
                // Convert to FormData for Whisper API
                const formData = new FormData();
                formData.append('file', audioBlob, 'audio.webm');
                formData.append('model', 'whisper-1');
                formData.append('response_format', 'text');
                
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${CONFIG.OPENAI_API_KEY}`
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Whisper API error: ${response.status}`);
                }
                
                const transcription = await response.text();
                console.log('Whisper transcription:', transcription);
                
                // Use the common transcription handler
                handleVoiceTranscription(transcription);
                
            } catch (error) {
                console.error('Whisper transcription failed:', error);
                updateVoiceStatus('Transcription Error', 'error');
                setTimeout(() => updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready'), 2000);
            }
        }

        function stopVoiceSession() {
            console.log(`🛑 Stopping voice session (type: ${voiceRecognitionType})...`);
            isListening = false;
            
            if (voiceRecognitionType === 'web' && webSpeechRecognition) {
                // Stop Web Speech API
                try {
                    webSpeechRecognition.stop();
                    console.log(`🛑 Stopped Web Speech Recognition`);
                } catch (error) {
                    console.warn('Error stopping Web Speech Recognition:', error);
                }
            } else {
                // Stop Whisper recording
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    console.log(`🛑 Stopping mediaRecorder...`);
                    mediaRecorder.stop();
                }
                
                // Clear audio chunks to prevent accumulation
                audioChunks = [];
                console.log(`🧹 Cleared audioChunks array`);
            }
            
            updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
        }

        // Removed old Realtime API functions - now using simple Whisper approach
        
        function processVoiceCommand(command) {
            const lowerCommand = command.toLowerCase();
            
            // Extract app creation requests
            if (lowerCommand.includes('create') || lowerCommand.includes('make') || lowerCommand.includes('build')) {
                // Remove command words and extract the app description
                let appRequest = command
                    .replace(/create|make|build|me|a|an/gi, '')
                    .replace(/app|application/gi, '')
                    .trim();
                
                if (appRequest) {
                    createApp(appRequest);
                    updateVoiceStatus(`Creating: ${appRequest}`, 'ready');
                }
            } else if (lowerCommand.includes('close all')) {
                closeAllApps();
                updateVoiceStatus('Closing all apps', 'ready');
            } else if (lowerCommand.includes('show apps') || lowerCommand.includes('app manager')) {
                showAppList();
                updateVoiceStatus('Opening App Manager', 'ready');
            } else {
                // Treat the entire command as an app request
                createApp(command);
                updateVoiceStatus(`Creating: ${command}`, 'ready');
            }
        }

        function updateVoiceStatus(text, state) {
            const voiceStatusElement = document.getElementById('voice-status');
            if (voiceStatusElement) {
                voiceStatusElement.textContent = text;
            }
            
            const voiceButton = document.getElementById('voice-button');
            if (voiceButton) {
                voiceButton.className = state;
            }
        }

        function showVoiceCommandPopup(command) {
            const popup = document.getElementById('voice-command-popup');
            if (!popup) return;
            
            // Set the command text
            popup.textContent = command;
            
            // Show the popup with fade-in
            popup.classList.add('show');
            
            // Fade out after 2 seconds
            setTimeout(() => {
                popup.classList.add('fade-out');
                
                // Remove classes after fade-out completes
                setTimeout(() => {
                    popup.classList.remove('show', 'fade-out');
                }, 500);
            }, 2000);
        }

        // Global variable to track which app is being modified
        let currentModifyingAppId = null;

        function startAppVoiceCommand(appId) {
            console.log(`🎤 Starting voice command for app: ${appId}`);
            console.log(`🔍 Current isListening state: ${isListening}`);
            console.log(`🔍 Current mediaStream:`, mediaStream);
            console.log(`🔍 Current mediaRecorder:`, mediaRecorder);
            
            // Set the app being modified
            currentModifyingAppId = appId;
            console.log(`✅ Set currentModifyingAppId to: ${currentModifyingAppId}`);
            
            // Visual feedback - make the voice button red and pulsing
            const voiceButton = document.querySelector(`#window_${appId} .window-voice-button`);
            if (voiceButton) {
                voiceButton.classList.add('recording');
                console.log(`✅ Added 'recording' class to voice button for app ${appId}`);
            } else {
                console.error(`❌ Could not find voice button for app ${appId}`);
            }
            
            // Handle voice session for app modification
            if (isListening) {
                console.log(`🔄 Already listening - stopping current session and starting app-specific session`);
                // Stop current session and start new one for app
                stopVoiceSession();
                // Wait a moment then start new session
                setTimeout(() => {
                    console.log(`🎙️ Starting new voice session for app ${appId}...`);
                    startVoiceSession();
                }, 100);
            } else {
                console.log(`🎙️ Starting new voice session for app modification...`);
                try {
                    startVoiceSession();
                    console.log(`✅ startVoiceSession() called successfully`);
                } catch (error) {
                    console.error(`❌ Error calling startVoiceSession():`, error);
                }
            }
            
            // Update voice status to show app-specific recording
            updateVoiceStatus(`Recording for ${appId}`, 'listening');
        }

        function stopAppVoiceCommand(appId) {
            console.log(`🛑 Stopping voice command for app: ${appId}`);
            
            // Stop the voice session
            stopVoiceSession();
            
            // Reset the voice button appearance
            const voiceButton = document.querySelector(`#window_${appId} .window-voice-button`);
            if (voiceButton) {
                voiceButton.classList.remove('recording');
                console.log(`✅ Removed 'recording' class from voice button for app ${appId}`);
            }
            
            // DON'T clear currentModifyingAppId here - let transcribeAudio() handle it
            // The transcription process needs currentModifyingAppId to know which app to modify
            console.log(`✅ Keeping currentModifyingAppId (${currentModifyingAppId}) for transcription processing`);
        }

        function showTextPromptDialog(appId) {
            const app = apps.find(a => a.id === appId);
            if (!app) {
                alert('App not found!');
                return;
            }

            const prompt = window.prompt(
                `Enter modification instructions for "${app.title}":`,
                'Add a new feature or modify the existing functionality...'
            );

            if (prompt && prompt.trim()) {
                console.log(`Text modification request for app ${appId}: ${prompt.trim()}`);
                modifyApp(appId, prompt.trim());
            }
        }

        function closeWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const icon = document.getElementById(`icon_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (app && app.isSystemApp) {
                // For system apps, hide instead of remove
                if (window) {
                    window.style.display = 'none';
                    app.isHidden = true;
                }
                if (icon) {
                    icon.style.display = 'none';
                }
                console.log(`System app ${appId} hidden`);
            } else {
                // For user apps, remove completely as before
                if (window) window.remove();
                if (icon) icon.remove();
                apps = apps.filter(app => app.id !== appId);
                console.log(`User app ${appId} removed`);
            }
            
            updateAppCount();
        }

        function minimizeWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                window.classList.add('minimized');
                app.isMinimized = true;
                updateIconState(appId);
            }
        }

        function toggleMaximize(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                window.classList.toggle('maximized');
                app.isMaximized = !app.isMaximized;
                bringToFront(appId);
            }
        }

        function toggleWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                if (app.isMinimized) {
                    window.classList.remove('minimized');
                    app.isMinimized = false;
                    bringToFront(appId);
                } else {
                    minimizeWindow(appId);
                }
                updateIconState(appId);
            }
        }

        function updateIconState(appId) {
            const icon = document.getElementById(`icon_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (icon && app) {
                icon.classList.toggle('active', !app.isMinimized);
            }
        }

        function bringToFront(appId) {
            const window = document.getElementById(`window_${appId}`);
            if (window) {
                const maxZ = Math.max(...Array.from(document.querySelectorAll('.window')).map(w => parseInt(w.style.zIndex) || 0));
                window.style.zIndex = maxZ + 1;
                activeWindow = appId;
            }
        }

        function startDrag(event, appId) {
            event.preventDefault();
            const window = document.getElementById(`window_${appId}`);
            if (window.classList.contains('maximized')) return;
            
            bringToFront(appId);
            
            // Handle both mouse and touch events
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            
            dragData = {
                appId: appId,
                startX: clientX,
                startY: clientY,
                startLeft: parseInt(window.style.left),
                startTop: parseInt(window.style.top)
            };
            
            // Add both mouse and touch event listeners
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }

        function drag(event) {
            if (!dragData) return;
            event.preventDefault(); // Prevent scrolling on touch
            
            // Handle both mouse and touch events
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            
            const window = document.getElementById(`window_${dragData.appId}`);
            const deltaX = clientX - dragData.startX;
            const deltaY = clientY - dragData.startY;
            
            window.style.left = (dragData.startLeft + deltaX) + 'px';
            window.style.top = (dragData.startTop + deltaY) + 'px';
        }

        function stopDrag() {
            dragData = null;
            // Remove both mouse and touch event listeners
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', stopDrag);
        }

        function startResize(event, appId) {
            event.preventDefault();
            event.stopPropagation();
            
            const window = document.getElementById(`window_${appId}`);
            if (window.classList.contains('maximized')) return;
            
            bringToFront(appId);
            
            resizeData = {
                appId: appId,
                startX: event.clientX,
                startY: event.clientY,
                startWidth: parseInt(window.style.width),
                startHeight: parseInt(window.style.height)
            };
            
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }

        function resize(event) {
            if (!resizeData) return;
            
            const window = document.getElementById(`window_${resizeData.appId}`);
            const deltaX = event.clientX - resizeData.startX;
            const deltaY = event.clientY - resizeData.startY;
            
            const newWidth = Math.max(300, resizeData.startWidth + deltaX);
            const newHeight = Math.max(200, resizeData.startHeight + deltaY);
            
            window.style.width = newWidth + 'px';
            window.style.height = newHeight + 'px';
        }

        function stopResize() {
            resizeData = null;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', stopResize);
        }

        function showAppList() {
            const appListContent = `
                <h3>App Manager</h3>
                <div style="margin-bottom: 15px;">
                    <button id="load-app-btn" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px;">📁 Load App</button>
                    <input type="file" id="app-file-input" accept=".json" style="display: none;">
                </div>
                <div style="max-height: 300px; overflow-y: auto;">
                    ${apps.map(app => `
                        <div style="padding: 10px; border: 1px solid #ddd; margin: 5px 0; border-radius: 4px;">
                            <strong>ID:</strong> ${app.id}<br>
                            <strong>Title:</strong> ${app.title}<br>
                            <strong>Type:</strong> ${app.type}<br>
                            ${app.customRequest ? `<strong>Request:</strong> ${app.customRequest}<br>` : ''}
                            <strong>Status:</strong> ${app.isMinimized ? 'Minimized' : 'Active'}
                            <div style="margin-top: 8px;">
                                <button onclick="downloadApp('${app.id}')" style="background: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 12px;">💾 Download</button>
                                <button onclick="closeWindow('${app.id}')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">❌ Close</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Total apps: ${apps.length} | Next ID: app_${nextAppId}
                </p>
            `;
            
            // Create App Manager directly without AI generation
            const managerId = generateAppId();
            const managerApp = {
                id: managerId,
                type: 'system',
                title: 'App Manager',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System App Manager'
            };

            apps.push(managerApp);
            createWindow(managerId, 'App Manager', appListContent);
            createTaskbarIcon(managerId, 'App Manager');
            updateAppCount();
            
            const contentElement = document.getElementById(`content_${managerId}`);
            
            // Add event listeners for the new buttons
            setTimeout(() => {
                const loadBtn = document.getElementById('load-app-btn');
                const fileInput = document.getElementById('app-file-input');
                
                if (loadBtn && fileInput) {
                    loadBtn.addEventListener('click', () => {
                        fileInput.click();
                    });
                    
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            loadAppFromFile(file);
                        }
                    });
                }
            }, 100);
            
            document.getElementById('start-menu').classList.remove('show');
        }

        function closeAllApps() {
            if (confirm('Close all applications?')) {
                [...apps].forEach(app => closeWindow(app.id));
            }
            document.getElementById('start-menu').classList.remove('show');
        }

        function downloadApp(appId) {
            const app = apps.find(a => a.id === appId);
            if (!app) {
                alert('App not found!');
                return;
            }

            // Get the current app content
            const contentElement = document.getElementById(`content_${appId}`);
            const currentHTML = contentElement ? contentElement.innerHTML : '';
            
            // Get the current CSS for this app
            const styleElement = document.getElementById(`style-${appId}`);
            const currentCSS = styleElement ? styleElement.textContent : '';
            
            // Get the current JavaScript for this app (if any)
            const scriptElement = document.getElementById(`script-${appId}`);
            const currentJavaScript = scriptElement ? scriptElement.textContent : '';

            // Create app data object
            const appData = {
                id: app.id,
                title: app.title,
                type: app.type,
                customRequest: app.customRequest,
                html: currentHTML,
                css: currentCSS,
                javascript: currentJavaScript,
                isMinimized: app.isMinimized,
                isMaximized: app.isMaximized,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };

            // Create and download the file
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `${app.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${app.id}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log(`Downloaded app: ${app.title} (${app.id})`);
        }

        function loadAppFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const appData = JSON.parse(e.target.result);
                    
                    // Validate the app data structure
                    if (!appData.title || !appData.html) {
                        throw new Error('Invalid app file format - missing required fields');
                    }
                    
                    // Generate a new app ID to avoid conflicts
                    const newAppId = generateAppId();
                    
                    // Create the app object
                    const newApp = {
                        id: newAppId,
                        type: appData.type || 'imported',
                        title: appData.title,
                        isMinimized: false,
                        isMaximized: false,
                        customRequest: appData.customRequest || 'Imported app'
                    };
                    
                    // Add to apps array
                    apps.push(newApp);
                    
                    // Create the window with the imported content
                    createWindow(newAppId, appData.title, appData.html);
                    createTaskbarIcon(newAppId, appData.title);
                    
                    // Add CSS if present
                    if (appData.css) {
                        addAppCSS(appData.css, newAppId);
                    }
                    
                    updateAppCount();
                    
                    // Execute JavaScript and auto-size after content is fully rendered
                    setTimeout(() => {
                        // Execute JavaScript if present
                        if (appData.javascript) {
                            executeAppJavaScript(appData.javascript, newAppId);
                        }
                        
                        // Auto-size and center the window based on content
                        autoSizeAndCenterWindow(newAppId);
                    }, 200);
                    
                    console.log(`Loaded app: ${appData.title} as ${newAppId}`);
                    
                } catch (error) {
                    console.error('Failed to load app:', error);
                    alert(`Failed to load app: ${error.message}`);
                }
            };
            
            reader.onerror = function() {
                alert('Failed to read the file');
            };
            
            reader.readAsText(file);
        }

        function triggerLoadApp() {
            // Create a hidden file input and trigger it
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            fileInput.style.display = 'none';
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadAppFromFile(file);
                }
                // Clean up
                document.body.removeChild(fileInput);
            });
            
            document.body.appendChild(fileInput);
            fileInput.click();
            
            // Close the start menu
            document.getElementById('start-menu').classList.remove('show');
        }

        // Configuration for LLM integration
        const CONFIG = {
            OPENAI_API_KEY: 'sk-proj-...', // Replace with your actual OpenAI API key
            OPENROUTER_API_KEY: 'sk-...', // Replace with your actual OpenRouter API key
            OPENROUTER_URL: 'https://openrouter.ai/api/v1/chat/completions',
            MODEL_SIMPLE: 'google/gemini-2.5-flash-lite-preview-06-17',
            MODEL_TOUGH: 'anthropic/claude-sonnet-4',
            MODEL: 'google/gemini-2.5-flash-lite-preview-06-17', // Will be updated based on mode selection
            CURRENT_LLM_PROVIDER: 'openrouter' // Current LLM provider: 'openrouter', 'openai', or 'lmstudio'
        };

        // Model selection state
        let currentModelMode = 'Simple'; // Default to Simple mode

        // Global voice recognition settings
        let voiceRecognitionType = 'whisper'; // 'whisper' or 'web'
        
        // Global voice state for Whisper API
        let mediaRecorder = null;
        let audioChunks = [];
        let mediaStream = null;
        
        // Global voice state for Web Speech API
        let webSpeechRecognition = null;
        let isWebSpeechSupported = false;

        // Global cost tracking
        let costTrackingEnabled = true;
        let costHistory = [];
        
        // Make costHistory globally accessible for generated apps
        window.costHistory = costHistory;

        // Global debug mode
        let debugMode = false;

        // Debug logging function
        function debugLog(...args) {
            if (debugMode) {
                console.log(...args);
            }
        }

        // Debug warn function
        function debugWarn(...args) {
            if (debugMode) {
                console.warn(...args);
            }
        }

        // Debug error function
        function debugError(...args) {
            if (debugMode) {
                console.error(...args);
            }
        }

        // Setup Assistant Functions
        function startSetupAssistant() {
            const setupContent = `
                <div class="setup-assistant">
                    <div class="setup-header">
                        <h2>🚀 Welcome to Self-Evolving OS</h2>
                        <p>Let's set up your AI-powered operating system in just a few steps.</p>
                        <div class="setup-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="setup-progress-fill"></div>
                            </div>
                            <span class="progress-text" id="setup-progress-text">Step 1 of 4</span>
                        </div>
                    </div>
                    
                    <div class="setup-content" id="setup-content">
                        <!-- Step content will be dynamically loaded here -->
                    </div>
                    
                    <div class="setup-footer">
                        <button class="setup-btn secondary" id="setup-back" style="display: none;">← Back</button>
                        <div class="setup-footer-right">
                            <button class="setup-btn secondary" id="setup-skip">Skip Setup</button>
                            <button class="setup-btn primary" id="setup-next">Next →</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Create Setup Assistant app
            const setupId = generateAppId();
            const setupApp = {
                id: setupId,
                type: 'system',
                title: 'Setup Assistant',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System Setup Assistant'
            };

            apps.push(setupApp);
            createWindow(setupId, 'Setup Assistant', setupContent, 600, 500);
            createTaskbarIcon(setupId, 'Setup Assistant');
            updateAppCount();
            
            // Add setup-specific CSS
            addSetupAssistantCSS(setupId);
            
            // Initialize setup assistant
            setTimeout(() => {
                initializeSetupAssistant(setupId);
            }, 100);
        }

        function addSetupAssistantCSS(appId) {
            const setupCSS = `
                .setup-assistant {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                }
                
                .setup-header {
                    padding: 30px 30px 20px 30px;
                    text-align: center;
                    background: white;
                    border-bottom: 1px solid #dee2e6;
                }
                
                .setup-header h2 {
                    margin: 0 0 10px 0;
                    color: #0078d4;
                    font-size: 24px;
                    font-weight: 600;
                }
                
                .setup-header p {
                    margin: 0 0 20px 0;
                    color: #6c757d;
                    font-size: 16px;
                }
                
                .setup-progress {
                    display: flex;
                    align-items: center;
                    gap: 15px;
                }
                
                .progress-bar {
                    flex: 1;
                    height: 8px;
                    background: #e9ecef;
                    border-radius: 4px;
                    overflow: hidden;
                }
                
                .progress-fill {
                    height: 100%;
                    background: linear-gradient(90deg, #0078d4, #106ebe);
                    border-radius: 4px;
                    transition: width 0.3s ease;
                    width: 25%;
                }
                
                .progress-text {
                    font-size: 14px;
                    color: #6c757d;
                    font-weight: 500;
                    min-width: 80px;
                }
                
                .setup-content {
                    flex: 1;
                    padding: 30px;
                    overflow-y: auto;
                }
                
                .setup-step {
                    max-width: 500px;
                    margin: 0 auto;
                }
                
                .setup-step h3 {
                    margin: 0 0 20px 0;
                    color: #333;
                    font-size: 20px;
                    font-weight: 600;
                }
                
                .setup-step p {
                    margin: 0 0 20px 0;
                    color: #6c757d;
                    line-height: 1.6;
                }
                
                .setup-form-group {
                    margin-bottom: 20px;
                }
                
                .setup-form-group label {
                    display: block;
                    margin-bottom: 8px;
                    color: #333;
                    font-weight: 500;
                }
                
                .setup-form-group input,
                .setup-form-group select {
                    width: 100%;
                    padding: 12px;
                    border: 2px solid #e9ecef;
                    border-radius: 6px;
                    font-size: 14px;
                    transition: border-color 0.2s ease;
                }
                
                .setup-form-group input:focus,
                .setup-form-group select:focus {
                    outline: none;
                    border-color: #0078d4;
                }
                
                .setup-form-group .help-text {
                    margin-top: 5px;
                    font-size: 12px;
                    color: #6c757d;
                }
                
                .setup-option-card {
                    border: 2px solid #e9ecef;
                    border-radius: 8px;
                    padding: 20px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
                
                .setup-option-card:hover {
                    border-color: #0078d4;
                    background: #f8f9ff;
                }
                
                .setup-option-card.selected {
                    border-color: #0078d4;
                    background: #e3f2fd;
                }
                
                .setup-option-card h4 {
                    margin: 0 0 8px 0;
                    color: #333;
                    font-size: 16px;
                    font-weight: 600;
                }
                
                .setup-option-card p {
                    margin: 0;
                    color: #6c757d;
                    font-size: 14px;
                }
                
                .setup-test-result {
                    margin-top: 15px;
                    padding: 15px;
                    border-radius: 6px;
                    font-size: 14px;
                }
                
                .setup-test-result.success {
                    background: #d4edda;
                    color: #155724;
                    border: 1px solid #c3e6cb;
                }
                
                .setup-test-result.error {
                    background: #f8d7da;
                    color: #721c24;
                    border: 1px solid #f5c6cb;
                }
                
                .setup-test-result.warning {
                    background: #fff3cd;
                    color: #856404;
                    border: 1px solid #ffeaa7;
                }
                
                .setup-footer {
                    padding: 20px 30px;
                    background: white;
                    border-top: 1px solid #dee2e6;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                
                .setup-footer-right {
                    display: flex;
                    gap: 10px;
                }
                
                .setup-btn {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
                
                .setup-btn.primary {
                    background: #0078d4;
                    color: white;
                }
                
                .setup-btn.primary:hover {
                    background: #106ebe;
                }
                
                .setup-btn.secondary {
                    background: #6c757d;
                    color: white;
                }
                
                .setup-btn.secondary:hover {
                    background: #5a6268;
                }
                
                .setup-btn:disabled {
                    opacity: 0.6;
                    cursor: not-allowed;
                }
            `;
            
            addAppCSS(setupCSS, appId);
        }

        function initializeSetupAssistant(setupId) {
            let currentStep = 1;
            const totalSteps = 4;
            
            const steps = {
                1: createWelcomeStep,
                2: createAIModelStep,
                3: createVoiceAudioStep,
                4: createCompletionStep
            };
            
            function updateProgress() {
                const progressFill = document.getElementById('setup-progress-fill');
                const progressText = document.getElementById('setup-progress-text');
                
                if (progressFill) {
                    progressFill.style.width = `${(currentStep / totalSteps) * 100}%`;
                }
                if (progressText) {
                    progressText.textContent = `Step ${currentStep} of ${totalSteps}`;
                }
            }
            
            function showStep(stepNumber) {
                const content = document.getElementById('setup-content');
                const backBtn = document.getElementById('setup-back');
                const nextBtn = document.getElementById('setup-next');
                const skipBtn = document.getElementById('setup-skip');
                
                if (content && steps[stepNumber]) {
                    content.innerHTML = steps[stepNumber]();
                }
                
                // Update button visibility
                if (backBtn) {
                    backBtn.style.display = stepNumber > 1 ? 'block' : 'none';
                }
                
                if (nextBtn) {
                    nextBtn.textContent = stepNumber === totalSteps ? 'Finish' : 'Next →';
                }
                
                if (skipBtn) {
                    skipBtn.style.display = stepNumber === totalSteps ? 'none' : 'block';
                }
                
                updateProgress();
                
                // Add step-specific event listeners
                setTimeout(() => {
                    addStepEventListeners(stepNumber);
                }, 100);
            }
            
            function addStepEventListeners(stepNumber) {
                if (stepNumber === 2) {
                    // AI Model step listeners
                    const providerCards = document.querySelectorAll('.setup-option-card[data-provider]');
                    providerCards.forEach(card => {
                        card.addEventListener('click', () => {
                            providerCards.forEach(c => c.classList.remove('selected'));
                            card.classList.add('selected');
                            
                            const provider = card.dataset.provider;
                            showProviderConfig(provider);
                        });
                    });
                    
                    const testBtn = document.getElementById('test-ai-connection');
                    if (testBtn) {
                        testBtn.addEventListener('click', testAIConnection);
                    }
                } else if (stepNumber === 3) {
                    // Voice & Audio step listeners
                    const voiceCards = document.querySelectorAll('.setup-option-card[data-voice]');
                    voiceCards.forEach(card => {
                        card.addEventListener('click', () => {
                            voiceCards.forEach(c => c.classList.remove('selected'));
                            card.classList.add('selected');
                            
                            const voiceType = card.dataset.voice;
                            showVoiceConfig(voiceType);
                        });
                    });
                    
                    const testMicBtn = document.getElementById('test-microphone-setup');
                    if (testMicBtn) {
                        testMicBtn.addEventListener('click', testMicrophone);
                    }
                    
                    const testVoiceBtn = document.getElementById('test-voice-recognition');
                    if (testVoiceBtn) {
                        testVoiceBtn.addEventListener('click', testVoiceRecognition);
                    }
                }
            }
            
            // Navigation event listeners
            const backBtn = document.getElementById('setup-back');
            const nextBtn = document.getElementById('setup-next');
            const skipBtn = document.getElementById('setup-skip');
            
            if (backBtn) {
                backBtn.addEventListener('click', () => {
                    if (currentStep > 1) {
                        currentStep--;
                        showStep(currentStep);
                    }
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentStep < totalSteps) {
                        if (validateCurrentStep(currentStep)) {
                            saveCurrentStepSettings(currentStep);
                            currentStep++;
                            showStep(currentStep);
                        }
                    } else {
                        // Finish setup
                        finishSetup(setupId);
                    }
                });
            }
            
            if (skipBtn) {
                skipBtn.addEventListener('click', () => {
                    if (confirm('Skip setup? You can configure these settings later in the Settings app.')) {
                        finishSetup(setupId);
                    }
                });
            }
            
            // Start with first step
            showStep(1);
        }

        function createWelcomeStep() {
            return `
                <div class="setup-step">
                    <h3>🎉 Welcome to Self-Evolving OS</h3>
                    <p>This AI-powered operating system can create and modify applications using natural language commands. Let's configure it for your needs.</p>
                    
                    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="margin: 0 0 15px 0; color: #0078d4;">✨ What you can do:</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #6c757d;">
                            <li>Create apps by voice: "Create a calculator app"</li>
                            <li>Modify existing apps: "Add a dark mode to this app"</li>
                            <li>Use text commands in the Start menu</li>
                            <li>Download and share your created apps</li>
                        </ul>
                    </div>
                    
                    <div style="background: #fff3cd; padding: 15px; border-radius: 6px; border: 1px solid #ffeaa7;">
                        <strong style="color: #856404;">📝 Note:</strong>
                        <span style="color: #856404;">You'll need API keys for AI services. Don't worry - we'll help you set this up!</span>
                    </div>
                </div>
            `;
        }

        function createAIModelStep() {
            return `
                <div class="setup-step">
                    <h3>🤖 AI Model Configuration</h3>
                    <p>Choose your AI provider for app generation. Each has different features and pricing.</p>
                    
                    <div class="setup-option-card" data-provider="openrouter">
                        <h4>🌐 OpenRouter (Recommended)</h4>
                        <p>Access to multiple AI models including Claude, GPT-4, and Gemini. Best balance of quality and cost.</p>
                    </div>
                    
                    <div class="setup-option-card" data-provider="openai">
                        <h4>🧠 OpenAI API</h4>
                        <p>Direct access to GPT models. Higher quality but more expensive.</p>
                    </div>
                    
                    <div class="setup-option-card" data-provider="lmstudio">
                        <h4>💻 LMStudio (Local)</h4>
                        <p>Run AI models locally on your computer. Free but requires powerful hardware.</p>
                    </div>
                    
                    <div id="provider-config" style="margin-top: 20px;">
                        <!-- Provider-specific configuration will appear here -->
                    </div>
                    
                    <button id="test-ai-connection" class="setup-btn secondary" style="margin-top: 15px;">🧪 Test Connection</button>
                    <div id="ai-test-result"></div>
                </div>
            `;
        }

        function createVoiceAudioStep() {
            return `
                <div class="setup-step">
                    <h3>🎤 Voice & Audio Setup</h3>
                    <p>Configure voice recognition for hands-free app creation and modification.</p>
                    
                    <div class="setup-option-card selected" data-voice="whisper">
                        <h4>🎯 OpenAI Whisper (Recommended)</h4>
                        <p>High-accuracy speech recognition supporting 50+ languages. Requires internet connection.</p>
                    </div>
                    
                    <div class="setup-option-card" data-voice="web">
                        <h4>🌐 Web Speech API</h4>
                        <p>Browser-based speech recognition. Free but limited language support and accuracy.</p>
                    </div>
                    
                    <div id="voice-config" style="margin-top: 20px;">
                        <!-- Voice-specific configuration will appear here -->
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="test-microphone-setup" class="setup-btn secondary">🎤 Test Microphone</button>
                        <button id="test-voice-recognition" class="setup-btn secondary">🗣️ Test Voice Recognition</button>
                    </div>
                    <div id="voice-test-result"></div>
                </div>
            `;
        }

        function createCompletionStep() {
            return `
                <div class="setup-step">
                    <h3>🎉 Setup Complete!</h3>
                    <p>Your Self-Evolving OS is ready to use. Here's what you can do next:</p>
                    
                    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="margin: 0 0 15px 0; color: #0078d4;">🚀 Quick Start:</h4>
                        <ol style="margin: 0; padding-left: 20px; color: #6c757d;">
                            <li>Click the microphone button and say "Create a calculator app"</li>
                            <li>Or use the Start menu to type your app request</li>
                            <li>Try modifying apps with the voice button in each window</li>
                            <li>Access Settings anytime from the Start menu</li>
                        </ol>
                    </div>
                    
                    <div style="background: #d4edda; padding: 15px; border-radius: 6px; border: 1px solid #c3e6cb;">
                        <strong style="color: #155724;">✅ Configuration Summary:</strong>
                        <div id="setup-summary" style="color: #155724; margin-top: 10px;">
                            <!-- Summary will be populated here -->
                        </div>
                    </div>
                </div>
            `;
        }

        function showProviderConfig(provider) {
            const configDiv = document.getElementById('provider-config');
            if (!configDiv) return;
            
            let configHTML = '';
            
            if (provider === 'openrouter') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-openrouter-key">OpenRouter API Key</label>
                        <input type="password" id="setup-openrouter-key" placeholder="sk-or-v1-...">
                        <div class="help-text">Get your API key from <a href="https://openrouter.ai/keys" target="_blank">openrouter.ai/keys</a></div>
                    </div>
                `;
            } else if (provider === 'openai') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-openai-key">OpenAI API Key</label>
                        <input type="password" id="setup-openai-key" placeholder="sk-...">
                        <div class="help-text">Get your API key from <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com/api-keys</a></div>
                    </div>
                `;
            } else if (provider === 'lmstudio') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-lmstudio-url">LMStudio Server URL</label>
                        <input type="url" id="setup-lmstudio-url" value="http://localhost:1234/v1/chat/completions">
                        <div class="help-text">Make sure LMStudio is running with a loaded model and server enabled</div>
                    </div>
                `;
            }
            
            configDiv.innerHTML = configHTML;
        }

        function showVoiceConfig(voiceType) {
            const configDiv = document.getElementById('voice-config');
            if (!configDiv) return;
            
            let configHTML = '';
            
            if (voiceType === 'whisper') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-whisper-key">OpenAI API Key (for Whisper)</label>
                        <input type="password" id="setup-whisper-key" placeholder="sk-proj-...">
                        <div class="help-text">Same as OpenAI API key. Get it from <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com/api-keys</a></div>
                    </div>
                `;
            } else if (voiceType === 'web') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-web-speech-lang">Language</label>
                        <select id="setup-web-speech-lang">
                            <option value="en-US">English (United States)</option>
                            <option value="en-GB">English (United Kingdom)</option>
                            <option value="es-ES">Spanish (Spain)</option>
                            <option value="fr-FR">French (France)</option>
                            <option value="de-DE">German (Germany)</option>
                            <option value="it-IT">Italian (Italy)</option>
                            <option value="pt-BR">Portuguese (Brazil)</option>
                            <option value="ru-RU">Russian (Russia)</option>
                            <option value="ja-JP">Japanese (Japan)</option>
                            <option value="zh-CN">Chinese (Mandarin)</option>
                        </select>
                        <div class="help-text">Choose your preferred language for voice recognition</div>
                    </div>
                `;
            }
            
            configDiv.innerHTML = configHTML;
        }

        async function testAIConnection() {
            const resultDiv = document.getElementById('ai-test-result');
            if (!resultDiv) return;
            
            const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
            if (!selectedProvider) {
                resultDiv.innerHTML = '<div class="setup-test-result error">Please select an AI provider first.</div>';
                return;
            }
            
            const provider = selectedProvider.dataset.provider;
            resultDiv.innerHTML = '<div class="setup-test-result warning">Testing connection...</div>';
            
            try {
                let apiKey = '';
                let apiUrl = '';
                
                if (provider === 'openrouter') {
                    apiKey = document.getElementById('setup-openrouter-key')?.value;
                    apiUrl = 'https://openrouter.ai/api/v1/chat/completions';
                } else if (provider === 'openai') {
                    apiKey = document.getElementById('setup-openai-key')?.value;
                    apiUrl = 'https://api.openai.com/v1/chat/completions';
                } else if (provider === 'lmstudio') {
                    apiUrl = document.getElementById('setup-lmstudio-url')?.value || 'http://localhost:1234/v1/chat/completions';
                    apiKey = 'not-needed';
                }
                
                if (!apiKey && provider !== 'lmstudio') {
                    resultDiv.innerHTML = '<div class="setup-test-result error">Please enter your API key.</div>';
                    return;
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        ...(provider === 'openrouter' && {
                            'HTTP-Referer': window.location.origin,
                            'X-Title': 'Self-Evolving OS Setup'
                        })
                    },
                    body: JSON.stringify({
                        model: provider === 'openrouter' ? 'google/gemini-2.5-flash-lite-preview-06-17' :
                               provider === 'openai' ? 'gpt-4o-mini' : 'llama-3.2-3b-instruct',
                        messages: [{ role: 'user', content: 'Hello! This is a test message.' }],
                        max_tokens: 50
                    })
                });
                
                if (response.ok) {
                    resultDiv.innerHTML = '<div class="setup-test-result success">✅ Connection successful! AI provider is working correctly.</div>';
                } else {
                    const errorText = await response.text();
                    resultDiv.innerHTML = `<div class="setup-test-result error">❌ Connection failed: ${response.status} - ${errorText}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="setup-test-result error">❌ Connection failed: ${error.message}</div>`;
            }
        }

        async function testVoiceRecognition() {
            const resultDiv = document.getElementById('voice-test-result');
            if (!resultDiv) return;
            
            const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
            if (!selectedVoice) {
                resultDiv.innerHTML = '<div class="setup-test-result error">Please select a voice recognition method first.</div>';
                return;
            }
            
            const voiceType = selectedVoice.dataset.voice;
            resultDiv.innerHTML = '<div class="setup-test-result warning">🎤 Say something to test voice recognition...</div>';
            
            try {
                if (voiceType === 'web') {
                    // Test Web Speech API
                    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">❌ Web Speech API not supported in this browser.</div>';
                        return;
                    }
                    
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognition = new SpeechRecognition();
                    recognition.continuous = false;
                    recognition.interimResults = false;
                    recognition.lang = document.getElementById('setup-web-speech-lang')?.value || 'en-US';
                    
                    recognition.onresult = function(event) {
                        const transcript = event.results[0][0].transcript;
                        resultDiv.innerHTML = `<div class="setup-test-result success">✅ Voice recognition working! You said: "${transcript}"</div>`;
                    };
                    
                    recognition.onerror = function(event) {
                        resultDiv.innerHTML = `<div class="setup-test-result error">❌ Voice recognition error: ${event.error}</div>`;
                    };
                    
                    recognition.start();
                    
                } else if (voiceType === 'whisper') {
                    // Test Whisper API
                    const apiKey = document.getElementById('setup-whisper-key')?.value;
                    if (!apiKey) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">Please enter your OpenAI API key first.</div>';
                        return;
                    }
                    
                    // Request microphone access for Whisper test
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        resultDiv.innerHTML = '<div class="setup-test-result success">✅ Microphone access granted! Whisper API key will be tested when you create your first app.</div>';
                        stream.getTracks().forEach(track => track.stop());
                    } catch (error) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">❌ Microphone access denied. Please allow microphone access for voice recognition.</div>';
                    }
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="setup-test-result error">❌ Voice test failed: ${error.message}</div>`;
            }
        }

        function validateCurrentStep(stepNumber) {
            if (stepNumber === 2) {
                // Validate AI Model step
                const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
                if (!selectedProvider) {
                    alert('Please select an AI provider.');
                    return false;
                }
                
                const provider = selectedProvider.dataset.provider;
                if (provider === 'openrouter') {
                    const apiKey = document.getElementById('setup-openrouter-key')?.value;
                    if (!apiKey) {
                        alert('Please enter your OpenRouter API key.');
                        return false;
                    }
                } else if (provider === 'openai') {
                    const apiKey = document.getElementById('setup-openai-key')?.value;
                    if (!apiKey) {
                        alert('Please enter your OpenAI API key.');
                        return false;
                    }
                }
            } else if (stepNumber === 3) {
                // Validate Voice & Audio step
                const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
                if (!selectedVoice) {
                    alert('Please select a voice recognition method.');
                    return false;
                }
                
                const voiceType = selectedVoice.dataset.voice;
                if (voiceType === 'whisper') {
                    const apiKey = document.getElementById('setup-whisper-key')?.value;
                    if (!apiKey) {
                        alert('Please enter your OpenAI API key for Whisper.');
                        return false;
                    }
                }
            }
            return true;
        }

        function saveCurrentStepSettings(stepNumber) {
            if (stepNumber === 2) {
                // Save AI Model settings
                const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
                if (selectedProvider) {
                    const provider = selectedProvider.dataset.provider;
                    
                    if (provider === 'openrouter') {
                        const apiKey = document.getElementById('setup-openrouter-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENROUTER_API_KEY = apiKey;
                            CONFIG.CURRENT_LLM_PROVIDER = 'openrouter';
                        }
                    } else if (provider === 'openai') {
                        const apiKey = document.getElementById('setup-openai-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENROUTER_API_KEY = apiKey; // Reuse same config key
                            CONFIG.OPENROUTER_URL = 'https://api.openai.com/v1/chat/completions';
                            CONFIG.CURRENT_LLM_PROVIDER = 'openai';
                        }
                    } else if (provider === 'lmstudio') {
                        const url = document.getElementById('setup-lmstudio-url')?.value;
                        if (url) {
                            CONFIG.OPENROUTER_API_KEY = 'not-needed';
                            CONFIG.OPENROUTER_URL = url;
                            CONFIG.CURRENT_LLM_PROVIDER = 'lmstudio';
                        }
                    }
                }
            } else if (stepNumber === 3) {
                // Save Voice & Audio settings
                const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
                if (selectedVoice) {
                    const voiceType = selectedVoice.dataset.voice;
                    voiceRecognitionType = voiceType;
                    
                    if (voiceType === 'whisper') {
                        const apiKey = document.getElementById('setup-whisper-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENAI_API_KEY = apiKey;
                        }
                    }
                }
            }
        }

        function finishSetup(setupId) {
            // Create final settings object and save to cookie
            const settings = {
                // Appearance Settings
                theme: 'light',
                
                // Voice & Audio Settings
                voiceRecognitionType: voiceRecognitionType,
                webSpeechLanguage: document.getElementById('setup-web-speech-lang')?.value || 'en-US',
                
                // AI Model Settings - Voice Recognition
                openaiWhisperKey: CONFIG.OPENAI_API_KEY || '',
                openaiWhisperUrl: 'https://api.openai.com/v1/audio/transcriptions',
                
                // AI Model Settings - Code Generation
                llmProvider: CONFIG.CURRENT_LLM_PROVIDER || 'openrouter',
                
                // Provider-specific settings
                openrouterApiKey: CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' ? CONFIG.OPENROUTER_API_KEY : '',
                openrouterUrl: CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' ? CONFIG.OPENROUTER_URL : 'https://openrouter.ai/api/v1/chat/completions',
                openrouterSimpleModel: 'google/gemini-2.5-flash-lite-preview-06-17',
                openrouterToughModel: 'anthropic/claude-sonnet-4',
                
                openaiApiKey: CONFIG.CURRENT_LLM_PROVIDER === 'openai' ? CONFIG.OPENROUTER_API_KEY : '',
                openaiUrl: CONFIG.CURRENT_LLM_PROVIDER === 'openai' ? CONFIG.OPENROUTER_URL : 'https://api.openai.com/v1/chat/completions',
                openaiSimpleModel: 'gpt-4o-mini',
                openaiToughModel: 'gpt-4o',
                
                lmstudioUrl: CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio' ? CONFIG.OPENROUTER_URL : 'http://localhost:1234/v1/chat/completions',
                lmstudioSimpleModel: 'llama-3.2-3b-instruct',
                lmstudioToughModel: 'llama-3.1-8b-instruct',
                
                // AI Model Settings - General
                apiTimeout: 30,
                maxRetries: 3,
                costTracking: true,
                
                // System Settings
                debugMode: false,
                performanceMode: false,
                autoCleanup: true,
                
                // Metadata
                version: '2.0.0',
                lastSaved: new Date().toISOString()
            };
            
            // Save settings to cookie
            const expires = new Date();
            expires.setFullYear(expires.getFullYear() + 1);
            document.cookie = `selfEvolvingOS_settings=${encodeURIComponent(JSON.stringify(settings))}; expires=${expires.toUTCString()}; path=/`;
            
            // Apply settings to system
            applySettingsToSystem(settings);
            
            // Update summary in completion step
            const summaryDiv = document.getElementById('setup-summary');
            if (summaryDiv) {
                summaryDiv.innerHTML = `
                    <div>🤖 AI Provider: ${CONFIG.CURRENT_LLM_PROVIDER || 'OpenRouter'}</div>
                    <div>🎤 Voice Recognition: ${voiceRecognitionType === 'web' ? 'Web Speech API' : 'OpenAI Whisper'}</div>
                    <div>🎨 Theme: Light Mode</div>
                `;
            }
            
            // Initialize voice system with new settings
            setTimeout(async () => {
                try {
                    await initializeVoice();
                    console.log('Voice system initialized with setup settings');
                } catch (error) {
                    console.warn('Voice initialization failed during setup:', error);
                }
            }, 1000);
            
            console.log('Setup completed successfully!', settings);
            
            // Show completion message and close setup after delay
            setTimeout(() => {
                alert('🎉 Setup completed! Your Self-Evolving OS is ready to use. Try saying "Create a calculator app" or use the Start menu.');
                closeWindow(setupId);
            }, 2000);
        }

        // Settings persistence functions
        function saveSettingsToCookie() {
            const settings = {
                // Appearance Settings
                theme: document.getElementById('theme')?.value ?? 'light',
                
                // Voice & Audio Settings
                voiceRecognitionType: document.getElementById('voice-recognition-type')?.value ?? 'whisper',
                webSpeechLanguage: document.getElementById('web-speech-language')?.value ?? 'en-US',
                
                // AI Model Settings - Voice Recognition
                openaiWhisperKey: document.getElementById('openai-whisper-key')?.value ?? '',
                openaiWhisperUrl: document.getElementById('openai-whisper-url')?.value ?? 'https://api.openai.com/v1/audio/transcriptions',
                
                // AI Model Settings - Code Generation
                llmProvider: document.getElementById('llm-provider')?.value ?? 'openrouter',
                
                // OpenRouter settings
                openrouterApiKey: document.getElementById('openrouter-api-key')?.value ?? '',
                openrouterUrl: document.getElementById('openrouter-url')?.value ?? 'https://openrouter.ai/api/v1/chat/completions',
                openrouterSimpleModel: document.getElementById('openrouter-simple-model')?.value ?? 'google/gemini-2.5-flash-lite-preview-06-17',
                openrouterToughModel: document.getElementById('openrouter-tough-model')?.value ?? 'anthropic/claude-sonnet-4',
                
                // OpenAI settings
                openaiApiKey: document.getElementById('openai-api-key')?.value ?? '',
                openaiUrl: document.getElementById('openai-url')?.value ?? 'https://api.openai.com/v1/chat/completions',
                openaiSimpleModel: document.getElementById('openai-simple-model')?.value ?? 'gpt-4o-mini',
                openaiToughModel: document.getElementById('openai-tough-model')?.value ?? 'gpt-4o',
                
                // LMStudio settings
                lmstudioUrl: document.getElementById('lmstudio-url')?.value ?? 'http://localhost:1234/v1/chat/completions',
                lmstudioSimpleModel: document.getElementById('lmstudio-simple-model')?.value ?? 'llama-3.2-3b-instruct',
                lmstudioToughModel: document.getElementById('lmstudio-tough-model')?.value ?? 'llama-3.1-8b-instruct',
                
                // AI Model Settings - General
                apiTimeout: parseInt(document.getElementById('api-timeout')?.value) ?? 30,
                maxRetries: parseInt(document.getElementById('max-retries')?.value) ?? 3,
                costTracking: document.getElementById('cost-tracking')?.checked ?? true,
                
                // System Settings
                debugMode: document.getElementById('debug-mode')?.checked ?? false,
                performanceMode: document.getElementById('performance-mode')?.checked ?? false,
                autoCleanup: document.getElementById('auto-cleanup')?.checked ?? true,
                
                // Metadata
                version: '2.0.0',
                lastSaved: new Date().toISOString()
            };
            
            // Save to cookie (expires in 1 year)
            const expires = new Date();
            expires.setFullYear(expires.getFullYear() + 1);
            document.cookie = `selfEvolvingOS_settings=${encodeURIComponent(JSON.stringify(settings))}; expires=${expires.toUTCString()}; path=/`;
            
            console.log('Settings saved to cookie:', settings);
            return settings;
        }

        function loadSettingsFromCookie() {
            try {
                const cookies = document.cookie.split(';');
                const settingsCookie = cookies.find(cookie => cookie.trim().startsWith('selfEvolvingOS_settings='));
                
                if (settingsCookie) {
                    const settingsJson = decodeURIComponent(settingsCookie.split('=')[1]);
                    const settings = JSON.parse(settingsJson);
                    console.log('Settings loaded from cookie:', settings);
                    return settings;
                }
            } catch (error) {
                console.warn('Failed to load settings from cookie:', error);
            }
            
            return null;
        }

        function applySettingsToUI(settings) {
            if (!settings) return;
            
            try {
                // Appearance Settings
                const theme = document.getElementById('theme');
                if (theme) theme.value = settings.theme ?? 'light';
                
                // Voice & Audio Settings
                const voiceRecognitionTypeEl = document.getElementById('voice-recognition-type');
                if (voiceRecognitionTypeEl) {
                    voiceRecognitionTypeEl.value = settings.voiceRecognitionType ?? 'whisper';
                    // Update global variable
                    voiceRecognitionType = settings.voiceRecognitionType ?? 'whisper';
                }
                
                const webSpeechLanguage = document.getElementById('web-speech-language');
                if (webSpeechLanguage) webSpeechLanguage.value = settings.webSpeechLanguage ?? 'en-US';
                
                // AI Model Settings - Voice Recognition
                const openaiWhisperKey = document.getElementById('openai-whisper-key');
                if (openaiWhisperKey) openaiWhisperKey.value = settings.openaiWhisperKey ?? '';
                
                const openaiWhisperUrl = document.getElementById('openai-whisper-url');
                if (openaiWhisperUrl) openaiWhisperUrl.value = settings.openaiWhisperUrl ?? 'https://api.openai.com/v1/audio/transcriptions';
                
                // AI Model Settings - Code Generation
                const llmProvider = document.getElementById('llm-provider');
                if (llmProvider) llmProvider.value = settings.llmProvider ?? 'openrouter';
                
                // OpenRouter settings
                const openrouterApiKey = document.getElementById('openrouter-api-key');
                if (openrouterApiKey) openrouterApiKey.value = settings.openrouterApiKey ?? '';
                
                const openrouterUrl = document.getElementById('openrouter-url');
                if (openrouterUrl) openrouterUrl.value = settings.openrouterUrl ?? 'https://openrouter.ai/api/v1/chat/completions';
                
                const openrouterSimpleModel = document.getElementById('openrouter-simple-model');
                if (openrouterSimpleModel) openrouterSimpleModel.value = settings.openrouterSimpleModel ?? 'google/gemini-2.5-flash-lite-preview-06-17';
                
                const openrouterToughModel = document.getElementById('openrouter-tough-model');
                if (openrouterToughModel) openrouterToughModel.value = settings.openrouterToughModel ?? 'anthropic/claude-sonnet-4';
                
                // OpenAI settings
                const openaiApiKey = document.getElementById('openai-api-key');
                if (openaiApiKey) openaiApiKey.value = settings.openaiApiKey ?? '';
                
                const openaiUrl = document.getElementById('openai-url');
                if (openaiUrl) openaiUrl.value = settings.openaiUrl ?? 'https://api.openai.com/v1/chat/completions';
                
                const openaiSimpleModel = document.getElementById('openai-simple-model');
                if (openaiSimpleModel) openaiSimpleModel.value = settings.openaiSimpleModel ?? 'gpt-4o-mini';
                
                const openaiToughModel = document.getElementById('openai-tough-model');
                if (openaiToughModel) openaiToughModel.value = settings.openaiToughModel ?? 'gpt-4o';
                
                // LMStudio settings
                const lmstudioUrl = document.getElementById('lmstudio-url');
                if (lmstudioUrl) lmstudioUrl.value = settings.lmstudioUrl ?? 'http://localhost:1234/v1/chat/completions';
                
                const lmstudioSimpleModel = document.getElementById('lmstudio-simple-model');
                if (lmstudioSimpleModel) lmstudioSimpleModel.value = settings.lmstudioSimpleModel ?? 'llama-3.2-3b-instruct';
                
                const lmstudioToughModel = document.getElementById('lmstudio-tough-model');
                if (lmstudioToughModel) lmstudioToughModel.value = settings.lmstudioToughModel ?? 'llama-3.1-8b-instruct';
                
                // AI Model Settings - General
                const apiTimeout = document.getElementById('api-timeout');
                if (apiTimeout) apiTimeout.value = settings.apiTimeout ?? 30;
                
                const maxRetries = document.getElementById('max-retries');
                if (maxRetries) maxRetries.value = settings.maxRetries ?? 3;
                
                const costTracking = document.getElementById('cost-tracking');
                if (costTracking) costTracking.checked = settings.costTracking ?? true;
                
                // System Settings
                const debugMode = document.getElementById('debug-mode');
                if (debugMode) debugMode.checked = settings.debugMode ?? false;
                
                const performanceMode = document.getElementById('performance-mode');
                if (performanceMode) performanceMode.checked = settings.performanceMode ?? false;
                
                const autoCleanup = document.getElementById('auto-cleanup');
                if (autoCleanup) autoCleanup.checked = settings.autoCleanup ?? true;
                
                console.log('Settings applied to UI successfully');
                
            } catch (error) {
                console.error('Error applying settings to UI:', error);
            }
        }

        function applyTheme(theme) {
            // Remove existing theme classes
            document.body.classList.remove('light-theme', 'dark-theme');
            
            // Apply new theme class
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
            } else {
                document.body.classList.add('light-theme');
            }
            
            // Apply theme to all existing apps
            applyThemeToAllApps(theme);
            
            console.log(`Theme applied: ${theme}`);
        }

        function applyThemeToApp(appId) {
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            const contentElement = document.getElementById(`content_${appId}`);
            
            if (contentElement) {
                // Remove existing theme classes
                contentElement.classList.remove('app-light-theme', 'app-dark-theme');
                
                // Apply current theme class
                if (currentTheme === 'dark') {
                    contentElement.classList.add('app-dark-theme');
                } else {
                    contentElement.classList.add('app-light-theme');
                }
                
                console.log(`Theme ${currentTheme} applied to app ${appId}`);
            }
        }

        function applyThemeToAllApps(theme) {
            // Apply theme to all existing app content areas
            const allAppContents = document.querySelectorAll('[id^="content_"]');
            
            allAppContents.forEach(contentElement => {
                // Remove existing theme classes
                contentElement.classList.remove('app-light-theme', 'app-dark-theme');
                
                // Apply new theme class
                if (theme === 'dark') {
                    contentElement.classList.add('app-dark-theme');
                } else {
                    contentElement.classList.add('app-light-theme');
                }
            });
            
            console.log(`Theme ${theme} applied to ${allAppContents.length} existing apps`);
        }

        // App visibility event system
        function dispatchAppShownEvent(appId) {
            const event = new CustomEvent('appShown', {
                detail: { appId: appId }
            });
            document.dispatchEvent(event);
            debugLog(`App shown event dispatched for app: ${appId}`);
        }

        function applySettingsToSystem(settings) {
            if (!settings) return;
            
            try {
                // Apply theme
                if (settings.theme) {
                    applyTheme(settings.theme);
                }
                
                // Apply voice recognition type to global variable
                if (settings.voiceRecognitionType) {
                    voiceRecognitionType = settings.voiceRecognitionType;
                }
                
                // Apply API settings to CONFIG
                if (settings.openaiWhisperKey) {
                    CONFIG.OPENAI_API_KEY = settings.openaiWhisperKey;
                }
                
                // Apply LLM provider settings based on selected provider
                const currentProvider = settings.llmProvider || 'openrouter';
                
                if (currentProvider === 'openrouter') {
                    if (settings.openrouterApiKey) CONFIG.OPENROUTER_API_KEY = settings.openrouterApiKey;
                    if (settings.openrouterUrl) CONFIG.OPENROUTER_URL = settings.openrouterUrl;
                    if (settings.openrouterSimpleModel) CONFIG.MODEL_SIMPLE = settings.openrouterSimpleModel;
                    if (settings.openrouterToughModel) CONFIG.MODEL_TOUGH = settings.openrouterToughModel;
                } else if (currentProvider === 'openai') {
                    if (settings.openaiApiKey) CONFIG.OPENROUTER_API_KEY = settings.openaiApiKey; // Reuse the same config key
                    if (settings.openaiUrl) CONFIG.OPENROUTER_URL = settings.openaiUrl; // Reuse the same config key
                    if (settings.openaiSimpleModel) CONFIG.MODEL_SIMPLE = settings.openaiSimpleModel;
                    if (settings.openaiToughModel) CONFIG.MODEL_TOUGH = settings.openaiToughModel;
                } else if (currentProvider === 'lmstudio') {
                    CONFIG.OPENROUTER_API_KEY = 'not-needed'; // LMStudio doesn't need API key
                    if (settings.lmstudioUrl) CONFIG.OPENROUTER_URL = settings.lmstudioUrl; // Reuse the same config key
                    if (settings.lmstudioSimpleModel) CONFIG.MODEL_SIMPLE = settings.lmstudioSimpleModel;
                    if (settings.lmstudioToughModel) CONFIG.MODEL_TOUGH = settings.lmstudioToughModel;
                }
                
                // Store current provider in CONFIG
                CONFIG.CURRENT_LLM_PROVIDER = currentProvider;
                
                // Apply cost tracking setting
                if (settings.costTracking !== undefined) {
                    costTrackingEnabled = settings.costTracking;
                    
                    // Show/hide cost tracking app in start menu based on setting
                    updateCostTrackingAppVisibility();
                }
                
                // Apply API timeout and max retries to CONFIG
                if (settings.apiTimeout) {
                    CONFIG.API_TIMEOUT = settings.apiTimeout * 1000; // Convert to milliseconds
                }
                
                if (settings.maxRetries) {
                    CONFIG.MAX_RETRIES = settings.maxRetries;
                }
                
                // Apply debug mode setting
                if (settings.debugMode !== undefined) {
                    debugMode = settings.debugMode;
                }
                
                if (debugMode) {
                    console.log('Settings applied to system successfully');
                    console.log('Updated CONFIG:', CONFIG);
                    console.log('Debug mode:', debugMode);
                }
                
            } catch (error) {
                console.error('Error applying settings to system:', error);
            }
        }

        // Cost tracking functions
        function addCostEntry(cost, description, prompt = '') {
            if (!costTrackingEnabled) return;
            
            const entry = {
                timestamp: new Date().toISOString(),
                cost: parseFloat(cost),
                description: description,
                prompt: prompt.substring(0, 200) + (prompt.length > 200 ? '...' : '') // Limit prompt length
            };
            
            costHistory.push(entry);
            
            // Update global window reference
            window.costHistory = costHistory;
            
            // Save to localStorage for persistence
            localStorage.setItem('costHistory', JSON.stringify(costHistory));
            
            debugLog('Cost entry added:', entry);
        }

        function loadCostHistory() {
            try {
                const saved = localStorage.getItem('costHistory');
                if (saved) {
                    costHistory = JSON.parse(saved);
                    // Update global window reference
                    window.costHistory = costHistory;
                }
            } catch (error) {
                debugWarn('Failed to load cost history:', error);
                costHistory = [];
                window.costHistory = costHistory;
            }
        }

        function updateCostTrackingAppVisibility() {
            const startMenu = document.getElementById('start-menu');
            let costTrackingSection = document.getElementById('cost-tracking-section');
            
            if (costTrackingEnabled) {
                // Add cost tracking app to start menu if not exists
                if (!costTrackingSection) {
                    costTrackingSection = document.createElement('div');
                    costTrackingSection.id = 'cost-tracking-section';
                    costTrackingSection.className = 'menu-section';
                    costTrackingSection.innerHTML = `
                        <div class="menu-title">Cost Tracking</div>
                        <div class="menu-item" onclick="openCostTrackingApp()">💰 Cost Tracking</div>
                    `;
                    
                    // Insert before the last section (Quick Actions)
                    const quickActionsSection = startMenu.querySelector('.menu-section:last-child');
                    startMenu.insertBefore(costTrackingSection, quickActionsSection);
                }
            } else {
                // Remove cost tracking app from start menu
                if (costTrackingSection) {
                    costTrackingSection.remove();
                }
            }
        }

        function openCostTrackingApp() {
            // Check if Cost Tracking app already exists
            const existingApp = apps.find(app => app.title === 'Cost Tracking' || app.title === '💰 Cost Tracking');
            
            if (existingApp) {
                // If app exists, show/focus the existing window
                const windowElement = document.getElementById(`window_${existingApp.id}`);
                const iconElement = document.getElementById(`icon_${existingApp.id}`);
                
                if (windowElement) {
                    // Show if hidden
                    if (existingApp.isHidden) {
                        windowElement.style.display = 'block';
                        if (iconElement) iconElement.style.display = 'block';
                        existingApp.isHidden = false;
                    }
                    
                    // Unminimize if minimized
                    if (existingApp.isMinimized) {
                        toggleMinimize(existingApp.id);
                    }
                    
                    // Bring to front
                    windowElement.style.zIndex = getHighestZIndex() + 1;
                    
                    // Dispatch app shown event to notify the app it's visible
                    dispatchAppShownEvent(existingApp.id);
                    
                    debugLog('Opened existing Cost Tracking app');
                } else {
                    // Window doesn't exist but app is in array, remove from array and create new
                    const index = apps.indexOf(existingApp);
                    apps.splice(index, 1);
                    createCostTrackingApp();
                }
            } else {
                // Create new AI-generated cost tracking app
                createCostTrackingApp();
            }
            
            // Close start menu
            document.getElementById('start-menu').classList.remove('show');
        }

        function createCostTrackingApp() {
            const costTrackingRequest = createCostTrackingPrompt();
            const appId = createApp(costTrackingRequest);
            
            // Mark as system app
            const app = apps.find(a => a.id === appId);
            if (app) {
                app.isSystemApp = true;
                app.title = '💰 Cost Tracking'; // Ensure consistent title
            }
            
            debugLog('Created new Cost Tracking system app');
            return appId;
        }

        function getHighestZIndex() {
            const windows = document.querySelectorAll('.window');
            let highest = 0;
            windows.forEach(window => {
                const zIndex = parseInt(window.style.zIndex) || 0;
                if (zIndex > highest) {
                    highest = zIndex;
                }
            });
            return highest;
        }

        function createCostTrackingPrompt() {
            return `Create a Cost Tracking app that displays API usage costs. The app must access the global 'costHistory' array which contains cost entries with the following structure:
            
            costHistory = [
                {
                    timestamp: "2024-01-01T12:00:00.000Z",
                    cost: 0.0025,
                    description: "App Creation Request",
                    prompt: "Create a calculator app..."
                }
            ]

            SPECIFIC REQUIREMENTS:
            1. Title: "💰 Cost Tracking"
            2. Display total cost at the top in a highlighted summary box
            3. Show number of API calls made
            4. Display cost history in a table with columns: Date/Time, Cost, Description, Prompt
            5. Sort entries by newest first (reverse chronological order)
            6. Include a "Clear History" button that calls clearCostHistory() function
            7. Include a "Load Costs" button that refreshes the data from the global costHistory
            8. Handle empty history with a "No cost entries recorded yet" message
            9. Use proper currency formatting ($X.XXXX)
            10. Make the table scrollable if there are many entries
            11. Truncate long prompts to fit in the table (max 100 characters)

            STYLING REQUIREMENTS:
            - Use a clean, professional layout
            - Summary box should be prominent with blue accent color (#0078d4)
            - Table should have borders and alternating row colors
            - Cost values should be highlighted in red/pink color (#dc3545)
            - Responsive design that works in a 400-600px window
            - Include proper spacing and padding
            - Buttons should be styled consistently

            TECHNICAL REQUIREMENTS:
            - CRITICAL: Access costHistory using window.costHistory (this is the global array with all cost data)
            - ALWAYS use: const costs = window.costHistory || []; to safely access the data
            - Calculate total cost: const total = costs.reduce((sum, entry) => sum + entry.cost, 0);
            - Format dates using new Date(entry.timestamp).toLocaleDateString() and toLocaleTimeString()
            - Clear History button MUST call: window.clearCostHistory()
            - Load Costs button MUST call your local loadCostData() function
            - MANDATORY: Create loadCostData() function that refreshes display from window.costHistory
            - MANDATORY: Call loadCostData() immediately when app loads AND when 'appShown' event fires
            - MANDATORY: Listen for 'appShown' event: document.addEventListener('appShown', loadCostData);
            - Handle empty data gracefully with "No cost entries recorded yet" message
            - DEBUGGING: Add console.log('Loading cost data:', window.costHistory); in loadCostData()

            APP VISIBILITY EVENT:
            - The system will dispatch a custom 'appShown' event when the app becomes visible
            - Listen for this event: document.addEventListener('appShown', function(event) { if(event.detail.appId === 'your-app-id') loadCostData(); });
            - This allows the app to refresh its data when reopened from hidden state
            - Always refresh cost data when this event is received

            EXAMPLE STRUCTURE:
            - Summary section with total cost and call count
            - Button row with "Load Costs" and "Clear History" buttons
            - Scrollable table with cost entries
            - Proper error handling for missing or invalid data

            EXAMPLE CODE SNIPPET:
            function loadCostData() {
                console.log('Loading cost data:', window.costHistory);
                const costs = window.costHistory || [];
                const total = costs.reduce((sum, entry) => sum + entry.cost, 0);
                
                console.log('Found', costs.length, 'cost entries, total:', total);
                
                // Update summary
                const totalElement = document.getElementById('total-cost');
                const countElement = document.getElementById('call-count');
                if (totalElement) totalElement.textContent = '$' + total.toFixed(4);
                if (countElement) countElement.textContent = costs.length;
                
                // Update table
                const tbody = document.getElementById('cost-table-body');
                if (tbody) {
                    tbody.innerHTML = '';
                    if (costs.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px;">No cost entries recorded yet.</td></tr>';
                    } else {
                        costs.slice().reverse().forEach(entry => {
                            const row = tbody.insertRow();
                            const date = new Date(entry.timestamp);
                            row.innerHTML = '<td>' + date.toLocaleDateString() + ' ' + date.toLocaleTimeString() + '</td><td style="color: #dc3545; font-weight: bold;">$' + entry.cost.toFixed(4) + '</td><td>' + entry.description + '</td><td>' + (entry.prompt || 'N/A').substring(0, 100) + '</td>';
                        });
                    }
                }
            }
            
            // MANDATORY: Call loadCostData when app loads and on appShown event
            loadCostData();
            document.addEventListener('appShown', function(event) {
                console.log('App shown event received for:', event.detail.appId);
                loadCostData();
            });`;
        }

        function clearCostHistory() {
            if (confirm('Are you sure you want to clear all cost history? This action cannot be undone.')) {
                costHistory = [];
                window.costHistory = costHistory;
                localStorage.removeItem('costHistory');
                
                // Update status bar
                const costElement = document.getElementById('api-cost');
                if (costElement) {
                    costElement.textContent = '0.00';
                }
                
                // Reset total cost
                totalCost = 0;
                
                alert('Cost history cleared successfully! Please refresh any open Cost Tracking apps to see the changes.');
            }
        }
        
        // Make clearCostHistory globally accessible for generated apps
        window.clearCostHistory = clearCostHistory;

        // Global function for apps to load cost data
        function loadCostData() {
            // This function can be called by generated apps to get fresh cost data
            // Return the current cost history and total
            const totalCost = costHistory.reduce((sum, entry) => sum + entry.cost, 0);
            return {
                costHistory: costHistory,
                totalCost: totalCost,
                callCount: costHistory.length
            };
        }
        
        // Make loadCostData globally accessible for generated apps
        window.loadCostData = loadCostData;

        // Debug function to check cost data state
        function debugCostData() {
            console.log('=== COST DATA DEBUG ===');
            console.log('costTrackingEnabled:', costTrackingEnabled);
            console.log('costHistory length:', costHistory.length);
            console.log('costHistory:', costHistory);
            console.log('window.costHistory:', window.costHistory);
            console.log('totalCost:', totalCost);
            console.log('localStorage costHistory:', localStorage.getItem('costHistory'));
            console.log('======================');
        }
        
        // Make debug function globally accessible
        window.debugCostData = debugCostData;

        // Test function to add a sample cost entry for debugging
        function addTestCostEntry() {
            addCostEntry(0.0025, 'Test Entry', 'This is a test cost entry for debugging');
            console.log('Test cost entry added. Total entries:', costHistory.length);
            debugCostData();
        }
        
        // Make test function globally accessible
        window.addTestCostEntry = addTestCostEntry;

        // Microphone test function
        async function testMicrophone() {
            let testStream = null;
            let audioContext = null;
            let analyser = null;
            let microphone = null;
            let dataArray = null;
            let animationId = null;
            
            try {
                // Create a modal dialog for the microphone test
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const testDialog = document.createElement('div');
                testDialog.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 10px;
                    text-align: center;
                    max-width: 400px;
                    width: 90%;
                `;
                
                testDialog.innerHTML = `
                    <h3 style="margin: 0 0 20px 0; color: #333;">🎤 Microphone Test</h3>
                    <p style="margin: 0 0 20px 0; color: #666;">Speak into your microphone to test audio levels</p>
                    <div style="margin: 20px 0;">
                        <div id="mic-level-bar" style="
                            width: 100%;
                            height: 20px;
                            background: #f0f0f0;
                            border-radius: 10px;
                            overflow: hidden;
                            position: relative;
                        ">
                            <div id="mic-level-fill" style="
                                height: 100%;
                                background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
                                width: 0%;
                                transition: width 0.1s ease;
                            "></div>
                        </div>
                        <p id="mic-level-text" style="margin: 10px 0 0 0; font-size: 14px; color: #666;">Audio Level: 0%</p>
                    </div>
                    <div id="mic-status" style="margin: 20px 0; font-size: 14px; color: #666;">Requesting microphone access...</div>
                    <button id="close-mic-test" style="
                        background: #dc3545;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                    ">Close Test</button>
                `;
                
                modal.appendChild(testDialog);
                document.body.appendChild(modal);
                
                const levelBar = document.getElementById('mic-level-fill');
                const levelText = document.getElementById('mic-level-text');
                const statusText = document.getElementById('mic-status');
                const closeBtn = document.getElementById('close-mic-test');
                
                // Close button handler
                closeBtn.addEventListener('click', () => {
                    cleanup();
                });
                
                // Click outside to close
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        cleanup();
                    }
                });
                
                function cleanup() {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    if (testStream) {
                        testStream.getTracks().forEach(track => track.stop());
                    }
                    if (audioContext) {
                        audioContext.close();
                    }
                    if (modal && modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                }
                
                // Request microphone access
                try {
                    testStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                    
                    statusText.textContent = 'Microphone access granted! Speak to see audio levels.';
                    statusText.style.color = '#28a745';
                    
                    // Set up audio analysis
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    microphone = audioContext.createMediaStreamSource(testStream);
                    
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    
                    microphone.connect(analyser);
                    
                    // Start monitoring audio levels
                    function updateAudioLevel() {
                        analyser.getByteFrequencyData(dataArray);
                        
                        // Calculate average volume
                        let sum = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            sum += dataArray[i];
                        }
                        const average = sum / bufferLength;
                        const percentage = Math.round((average / 255) * 100);
                        
                        // Update visual indicators
                        levelBar.style.width = percentage + '%';
                        levelText.textContent = `Audio Level: ${percentage}%`;
                        
                        // Color coding based on level
                        if (percentage < 10) {
                            levelBar.style.background = '#6c757d'; // Gray for very low
                        } else if (percentage < 30) {
                            levelBar.style.background = '#28a745'; // Green for good
                        } else if (percentage < 70) {
                            levelBar.style.background = '#ffc107'; // Yellow for moderate
                        } else {
                            levelBar.style.background = '#dc3545'; // Red for high
                        }
                        
                        // Update status based on audio level
                        if (percentage > 5) {
                            statusText.textContent = '✅ Microphone is working! Audio detected.';
                            statusText.style.color = '#28a745';
                        } else {
                            statusText.textContent = '🔇 Speak louder or check microphone settings.';
                            statusText.style.color = '#ffc107';
                        }
                        
                        animationId = requestAnimationFrame(updateAudioLevel);
                    }
                    
                    updateAudioLevel();
                    
                } catch (error) {
                    console.error('Microphone access failed:', error);
                    statusText.textContent = '❌ Microphone access denied or failed. Please check permissions.';
                    statusText.style.color = '#dc3545';
                    
                    // Show specific error messages
                    if (error.name === 'NotAllowedError') {
                        statusText.textContent = '❌ Microphone access denied. Please allow microphone access and try again.';
                    } else if (error.name === 'NotFoundError') {
                        statusText.textContent = '❌ No microphone found. Please connect a microphone and try again.';
                    } else if (error.name === 'NotReadableError') {
                        statusText.textContent = '❌ Microphone is being used by another application.';
                    }
                }
                
            } catch (error) {
                console.error('Failed to create microphone test dialog:', error);
                alert('Failed to start microphone test. Please try again.');
            }
        }

        // AI-Generated App Content Creator
        function createAIGeneratedAppContent(request, appId) {
            // Start LLM processing immediately
            setTimeout(() => processAppWithLLM(request, appId), 100);
            
            return `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                    <h2 style="margin: 0 0 30px 0; color: #333; font-weight: 300;">Creating your app</h2>
                    <div class="spinner" style="
                        width: 40px;
                        height: 40px;
                        border: 4px solid #f3f3f3;
                        border-top: 4px solid #0078d4;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                    "></div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
        }

        // LLM Processing Function
        async function processAppWithLLM(request, appId, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`🔄 Processing app with LLM (attempt ${retryCount + 1}/${maxRetries})`);
                
                // Create prompt for windowed app generation
                const prompt = createWindowedAppPrompt(request, appId);
                
                // Call LLM API
                const response = await callLLMAPI(prompt, request, 'App Creation Request');
                
                if (response && response.html) {
                    console.log(`✅ LLM processing successful on attempt ${retryCount + 1}`);
                    
                    // Replace the placeholder content with the generated app
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Auto-size and center the window based on content
                        setTimeout(() => {
                            autoSizeAndCenterWindow(appId);
                        }, 100);
                        
                        // Update app title if provided
                        if (response.title) {
                            updateAppTitle(appId, response.title);
                        }
                    }
                } else {
                    throw new Error('Invalid response from LLM - missing HTML content');
                }
                
            } catch (error) {
                console.error(`❌ LLM processing failed (attempt ${retryCount + 1}):`, error);
                
                // Check if we should retry
                if (retryCount < maxRetries - 1) {
                    console.log(`🔄 Retrying in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">🔄 Retrying...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppWithLLM(request, appId, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`💥 All ${maxRetries} attempts failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">❌ Error</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        function createWindowedAppPrompt(request, appId) {
            // Get current theme
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            
            return `You are creating a functional app for a windowed operating system interface. The user requested: "${request}"

CRITICAL REQUIREMENTS:
1. Create a COMPLETE, FUNCTIONAL app that works in a window
2. The app will be placed inside a window with ID "content_${appId}"
3. Use ONLY vanilla HTML, CSS, and JavaScript - no external libraries
4. Make the app responsive and fit well in a window (300-600px wide)
5. Include ALL necessary functionality for the requested app
6. Use modern, clean UI design
7. THEME SUPPORT: The system supports Dark Mode and Light Mode themes. Currently active theme: ${currentTheme}

THEME REQUIREMENTS:
- Create CSS that works well in BOTH Dark Mode and Light Mode
- Use CSS classes with theme-specific styling: .app-light-theme and .app-dark-theme
- For Light Mode: Use light backgrounds (#ffffff, #f8f9fa), dark text (#212529, #495057)
- For Dark Mode: Use dark backgrounds (#2c3e50, #34495e), light text (#f8f9fa, #e9ecef)
- Ensure good contrast in both themes for accessibility
- The app will automatically apply the correct theme class based on system settings

RESPONSE FORMAT - Return ONLY a JSON object with this structure:
{
  "title": "App Name",
  "html": "complete HTML content",
  "css": "complete CSS styles",
  "javascript": "complete JavaScript functionality"
}

CONTENT RULES:
- HTML: Use single quotes for attributes to avoid JSON conflicts. NEVER use onclick attributes - use IDs instead
- CSS: Keep simple, no line breaks
- JavaScript: ALWAYS provide interactive logic when UI elements need functionality
- NO base64 encoding - use plain text
- Always create BOTH the User Interface AND the Logic (JavaScript)
- For interactive elements (buttons, inputs, forms), ALWAYS include JavaScript
- CRITICAL: Use addEventListener in JavaScript, NOT onclick attributes in HTML
- Give all interactive elements unique IDs and reference them in JavaScript
- IMPORTANT: onclick attributes will NOT work because JavaScript runs in isolated scope
- Always use document.getElementById() and addEventListener() pattern

EXAMPLES:

For "text input":
{
  "title": "Text Input",
  "html": "<input type='text' id='user-input' placeholder='Enter text' class='text-input'>",
  "css": ".text-input { padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin: 10px; } .app-light-theme .text-input { background: #ffffff; color: #212529; border-color: #ced4da; } .app-dark-theme .text-input { background: #34495e; color: #f8f9fa; border-color: #4a5f7a; }",
  "javascript": "const input = document.getElementById('user-input'); input.addEventListener('input', function() { console.log('User typed:', this.value); });"
}

For "button with alert":
{
  "title": "Alert Button",
  "html": "<button id='alert-btn' class='my-button'>Click me</button>",
  "css": ".my-button { padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; } .app-light-theme .my-button { background: #007bff; color: white; } .app-dark-theme .my-button { background: #3498db; color: white; } .my-button:hover { opacity: 0.9; }",
  "javascript": "document.getElementById('alert-btn').addEventListener('click', function() { alert('Button was clicked!'); });"
}

For "calculator":
{
  "title": "Calculator",
  "html": "<div class='calculator'><input type='text' id='calc-display' disabled><div class='calc-buttons'><button id='btn-1'>1</button><button id='btn-2'>2</button><button id='btn-3'>3</button><button id='btn-plus'>+</button><button id='btn-4'>4</button><button id='btn-5'>5</button><button id='btn-6'>6</button><button id='btn-minus'>-</button><button id='btn-7'>7</button><button id='btn-8'>8</button><button id='btn-9'>9</button><button id='btn-multiply'>*</button><button id='btn-0'>0</button><button id='btn-clear'>C</button><button id='btn-equals'>=</button><button id='btn-divide'>/</button></div></div>",
  "css": ".calculator { width: 300px; margin: 20px auto; border: 1px solid #ccc; padding: 15px; border-radius: 5px; } #calc-display { width: 100%; height: 40px; margin-bottom: 10px; text-align: right; padding: 5px; font-size: 20px; } .calc-buttons { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; } .calc-buttons button { padding: 15px; font-size: 16px; border: none; border-radius: 3px; cursor: pointer; background-color: #eee; }",
  "javascript": "let currentInput = ''; const display = document.getElementById('calc-display'); function updateDisplay() { display.value = currentInput; } ['1','2','3','4','5','6','7','8','9','0','+','-','*','/'].forEach(val => { document.getElementById('btn-' + (val === '+' ? 'plus' : val === '-' ? 'minus' : val === '*' ? 'multiply' : val === '/' ? 'divide' : val)).addEventListener('click', () => { currentInput += val; updateDisplay(); }); }); document.getElementById('btn-clear').addEventListener('click', () => { currentInput = ''; updateDisplay(); }); document.getElementById('btn-equals').addEventListener('click', () => { try { currentInput = eval(currentInput).toString(); updateDisplay(); } catch { currentInput = 'Error'; updateDisplay(); } });"
}

Now create a functional app for: "${request}"`
        }

        async function callLLMAPI(prompt, userRequest = '', description = 'API Request') {
            const response = await fetch(CONFIG.OPENROUTER_URL, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${CONFIG.OPENROUTER_API_KEY}`,
                    'Content-Type': 'application/json',
                    'HTTP-Referer': window.location.origin,
                    'X-Title': 'Self-Evolving OS'
                },
                body: JSON.stringify({
                    model: CONFIG.MODEL,
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.7,
                    max_tokens: 3000
                })
            });

            if (!response.ok) {
                throw new Error(`API request failed: ${response.status}`);
            }

            const data = await response.json();
            
            // Extract cost information from response
            updateCostDisplay(data, description, userRequest);
            
            const content = data.choices[0].message.content;
            
            // Extract JSON from response
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
            
            throw new Error('Invalid response format');
        }

        // Global cost tracking
        let totalCost = 0;

        function updateCostDisplay(responseData, description = 'API Request', prompt = '') {
            try {
                // OpenRouter includes usage information in the response
                if (responseData.usage) {
                    const usage = responseData.usage;
                    
                    // Calculate cost based on token usage
                    // These are approximate rates - OpenRouter may provide exact costs in headers
                    const promptTokens = usage.prompt_tokens || 0;
                    const completionTokens = usage.completion_tokens || 0;
                    
                    // Approximate cost calculation (Claude 3.5 Sonnet rates)
                    const promptCost = (promptTokens / 1000000) * 3.00; // $3 per 1M input tokens
                    const completionCost = (completionTokens / 1000000) * 15.00; // $15 per 1M output tokens
                    const requestCost = promptCost + completionCost;
                    
                    totalCost += requestCost;
                    
                    // Add to cost tracking history
                    addCostEntry(requestCost, description, prompt);
                    
                    // Update display
                    const costElement = document.getElementById('api-cost');
                    if (costElement) {
                        costElement.textContent = totalCost.toFixed(4);
                    }
                    
                    console.log(`Request cost: $${requestCost.toFixed(4)}, Total cost: $${totalCost.toFixed(4)}`);
                }
            } catch (error) {
                console.warn('Could not calculate API cost:', error);
            }
        }

        // Helper function to update cost without response data
        function updateCost(cost, description = 'Manual Update', prompt = '') {
            totalCost += cost;
            
            // Add to cost tracking history
            addCostEntry(cost, description, prompt);
            
            // Update display
            const costElement = document.getElementById('api-cost');
            if (costElement) {
                costElement.textContent = totalCost.toFixed(4);
            }
        }


        function addAppCSS(css, appId) {
            const styleElement = document.createElement('style');
            styleElement.id = `style-${appId}`;
            styleElement.textContent = css;
            document.head.appendChild(styleElement);
        }

        function executeAppJavaScript(javascript, appId) {
            try {
                // Store the JavaScript in a script element for later retrieval
                const scriptElement = document.createElement('script');
                scriptElement.id = `script-${appId}`;
                scriptElement.type = 'text/plain'; // Don't execute it as a script
                scriptElement.textContent = javascript;
                document.head.appendChild(scriptElement);
                
                // Execute JavaScript in global scope so it can access document and DOM
                eval(javascript);
            } catch (error) {
                console.error(`JavaScript execution failed for app ${appId}:`, error);
            }
        }

        function updateAppTitle(appId, newTitle) {
            const app = apps.find(a => a.id === appId);
            if (app) {
                app.title = newTitle;
                
                // Update window title
                const windowTitleElement = document.querySelector(`#window_${appId} .window-title`);
                if (windowTitleElement) {
                    windowTitleElement.textContent = newTitle;
                }
                
                // Update taskbar icon
                const iconElement = document.getElementById(`icon_${appId}`);
                if (iconElement) {
                    iconElement.textContent = newTitle.substring(0, 3);
                    iconElement.title = newTitle;
                }
            }
        }

        function autoSizeAndCenterWindow(appId) {
            const windowElement = document.getElementById(`window_${appId}`);
            const contentElement = document.getElementById(`content_${appId}`);
            
            if (!windowElement || !contentElement) return;
            
            // Temporarily make content visible and remove size constraints to measure it properly
            const originalDisplay = contentElement.style.display;
            const originalVisibility = contentElement.style.visibility;
            const originalWindowWidth = windowElement.style.width;
            const originalWindowHeight = windowElement.style.height;
            
            // Set content to be fully visible for measurement
            contentElement.style.display = 'block';
            contentElement.style.visibility = 'visible';
            
            // Temporarily set window to auto size to get natural content dimensions
            windowElement.style.width = 'auto';
            windowElement.style.height = 'auto';
            
            // Force a reflow to get accurate measurements
            windowElement.offsetHeight;
            
            // Get the natural size of the content after it's fully rendered
            const contentRect = contentElement.getBoundingClientRect();
            const windowHeaderHeight = 50; // Window header height
            const padding = 40; // Extra padding for better appearance
            const osHeaderHeight = 50; // OS header height
            
            // Calculate optimal window size with generous limits
            const maxAvailableWidth = window.innerWidth - 100; // Leave 50px margin on each side
            const maxAvailableHeight = window.innerHeight - osHeaderHeight - 100; // Leave space for OS header and margins
            
            let optimalWidth = Math.max(350, Math.min(maxAvailableWidth, contentRect.width + padding));
            let optimalHeight = Math.max(250, Math.min(maxAvailableHeight, contentRect.height + windowHeaderHeight + padding));
            
            // Update window size
            windowElement.style.width = optimalWidth + 'px';
            windowElement.style.height = optimalHeight + 'px';
            
            // Center the window in the desktop area
            const desktop = document.getElementById('desktop');
            const desktopRect = desktop.getBoundingClientRect();
            const availableWidth = desktopRect.width;
            const availableHeight = desktopRect.height;
            
            const centerX = Math.max(10, (availableWidth - optimalWidth) / 2);
            const centerY = Math.max(10, (availableHeight - optimalHeight) / 2);
            
            windowElement.style.left = centerX + 'px';
            windowElement.style.top = centerY + 'px';
            
            // Restore original content state
            contentElement.style.display = originalDisplay;
            contentElement.style.visibility = originalVisibility;
        }

        function regenerateApp(appId) {
            const app = apps.find(a => a.id === appId);
            if (app && app.customRequest) {
                processAppWithLLM(app.customRequest, appId);
            }
        }

        function modifyApp(appId, modificationRequest) {
            console.log(`Modifying app ${appId} with request: ${modificationRequest}`);
            
            const app = apps.find(a => a.id === appId);
            if (!app) {
                console.error(`App ${appId} not found`);
                return;
            }
            
            // Extract current app code
            const appContentElement = document.getElementById(`content_${appId}`);
            const currentHTML = appContentElement ? appContentElement.innerHTML : '';
            
            // Extract current CSS for this app
            const currentStyleElement = document.getElementById(`style-${appId}`);
            const currentCSS = currentStyleElement ? currentStyleElement.textContent : '';
            
            // Extract current JavaScript for this app
            const currentScriptElement = document.getElementById(`script-${appId}`);
            const currentJavaScript = currentScriptElement ? currentScriptElement.textContent : '';
            
            console.log(`📄 Current HTML length: ${currentHTML.length}`);
            console.log(`🎨 Current CSS length: ${currentCSS.length}`);
            console.log(`⚙️ Current JavaScript length: ${currentJavaScript.length}`);
            
            // Create a modification prompt that includes the current app code
            const modificationPrompt = `You are modifying an existing app for a windowed operating system interface.

CURRENT APP CONTEXT:
- Current Title: "${app.title}"
- Original Request: "${app.customRequest || 'Unknown'}"
- App ID: ${appId}

CURRENT APP CODE:
=== CURRENT HTML ===
${currentHTML}

=== CURRENT CSS ===
${currentCSS}

=== CURRENT JAVASCRIPT ===
${currentJavaScript}

MODIFICATION REQUEST: "${modificationRequest}"

IMPORTANT: You are MODIFYING the existing app above, NOT creating a new one. Please:
1. Keep the existing functionality that works
2. Only change what's needed for the modification request
3. Preserve the current UI structure where possible
4. Build upon the existing code rather than replacing it entirely

CRITICAL REQUIREMENTS:
1. MODIFY the existing app according to the user's request
2. Keep the same basic app structure but implement the requested changes
3. The app will be placed inside a window with ID "content_${appId}"
4. Use ONLY vanilla HTML, CSS, and JavaScript - no external libraries
5. Make the app responsive and fit well in a window (300-600px wide)
6. Include ALL necessary functionality for the modified app
7. Use modern, clean UI design

RESPONSE FORMAT - Return ONLY a JSON object with this structure:
{
  "title": "Updated App Name",
  "html": "complete HTML content",
  "css": "complete CSS styles",
  "javascript": "complete JavaScript functionality"
}

CONTENT RULES:
- HTML: Use single quotes for attributes to avoid JSON conflicts. NEVER use onclick attributes - use IDs instead
- CSS: Keep simple, no line breaks
- JavaScript: ALWAYS provide interactive logic when UI elements need functionality
- NO base64 encoding - use plain text
- Always create BOTH the User Interface AND the Logic (JavaScript)
- For interactive elements (buttons, inputs, forms), ALWAYS include JavaScript
- CRITICAL: Use addEventListener in JavaScript, NOT onclick attributes in HTML
- Give all interactive elements unique IDs and reference them in JavaScript
- IMPORTANT: onclick attributes will NOT work because JavaScript runs in isolated scope
- Always use document.getElementById() and addEventListener() pattern

Implement the modification: ${modificationRequest}`;

            // Show loading state
            const contentElement = document.getElementById(`content_${appId}`);
            if (contentElement) {
                contentElement.innerHTML = '<div style="text-align: center; padding: 20px;">🔄 Modifying app...</div>';
            }
            
            // Process the modification with LLM
            processAppModificationWithLLM(modificationPrompt, appId, modificationRequest);
        }

        async function processAppModificationWithLLM(prompt, appId, modificationRequest, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`🔄 Processing app modification (attempt ${retryCount + 1}/${maxRetries}) for app ${appId}`);
                
                // Call LLM API with the modification prompt
                const response = await callLLMAPI(prompt, modificationRequest, 'App Edit Request');
                console.log('Modification response:', response);
                
                if (response && response.html) {
                    console.log(`✅ App modification successful on attempt ${retryCount + 1}`);
                    
                    // Update the app content
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Update the app title if changed
                        if (response.title) {
                            const titleElement = document.querySelector(`#window_${appId} .window-title`);
                            if (titleElement) {
                                titleElement.textContent = response.title;
                            }
                            
                            // Update the app object
                            const app = apps.find(a => a.id === appId);
                            if (app) {
                                app.title = response.title;
                                app.customRequest = modificationRequest;
                            }
                            
                            // Update taskbar icon
                            const iconElement = document.getElementById(`icon_${appId}`);
                            if (iconElement) {
                                iconElement.textContent = response.title;
                            }
                        }
                        
                        console.log(`App ${appId} successfully modified`);
                    }
                } else {
                    throw new Error('Invalid modification response - missing HTML content');
                }
                
            } catch (error) {
                console.error(`❌ App modification failed (attempt ${retryCount + 1}):`, error);
                
                // Check if we should retry
                if (retryCount < maxRetries - 1) {
                    console.log(`🔄 Retrying modification in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">🔄 Retrying Modification...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppModificationWithLLM(prompt, appId, modificationRequest, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`💥 All ${maxRetries} modification attempts failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">❌ Modification Failed</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        function updateAppCSS(css, appId) {
            // Remove existing app-specific CSS
            const existingStyle = document.getElementById(`style-${appId}`);
            if (existingStyle) {
                existingStyle.remove();
            }
            
            // Add new CSS
            if (css) {
                addAppCSS(css, appId);
            }
        }

        function updateAppJavaScript(javascript, appId) {
            // Remove existing app-specific JavaScript
            const existingScript = document.getElementById(`script-${appId}`);
            if (existingScript) {
                existingScript.remove();
            }
            
            // Add new JavaScript
            if (javascript) {
                const scriptElement = document.createElement('script');
                scriptElement.id = `script-${appId}`;
                scriptElement.textContent = javascript;
                document.head.appendChild(scriptElement);
            }
        }

        function showSettings() {
            const settingsContent = `
                <div class="settings-container">
                    <h2 id="settings-main-title" style="margin: 0 0 20px 0; color: #333; border-bottom: 2px solid #0078d4; padding-bottom: 10px;">⚙️ Settings</h2>
                    
                    <div class="settings-categories">
                        <div class="settings-nav">
                            <button class="settings-nav-btn active" data-category="general">🔧 General</button>
                            <button class="settings-nav-btn" data-category="appearance">🎨 Appearance</button>
                            <button class="settings-nav-btn" data-category="voice">🎤 Voice & Audio</button>
                            <button class="settings-nav-btn" data-category="ai">🤖 AI Models</button>
                            <button class="settings-nav-btn" data-category="system">💻 System</button>
                            <button class="settings-nav-btn" data-category="about">ℹ️ About</button>
                        </div>
                        
                        <div class="settings-content">
                            <!-- General Settings -->
                            <div class="settings-panel active" id="general-panel">
                                <h3>General Settings</h3>
                                <p style="color: #666; font-style: italic; text-align: center; padding: 40px 20px;">
                                    No general settings available at this time.
                                </p>
                            </div>
                            
                            <!-- Appearance Settings -->
                            <div class="settings-panel" id="appearance-panel">
                                <h3>Appearance Settings</h3>
                                <div class="setting-item">
                                    <label for="theme">Theme</label>
                                    <select id="theme">
                                        <option value="light" selected>Light Mode</option>
                                        <option value="dark">Dark Mode</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Voice & Audio Settings -->
                            <div class="settings-panel" id="voice-panel">
                                <h3>Voice & Audio Settings</h3>
                                <div class="setting-item">
                                    <label for="voice-recognition-type">Voice recognition engine</label>
                                    <select id="voice-recognition-type">
                                        <option value="whisper" selected>OpenAI Whisper (Recommended)</option>
                                        <option value="web">Web Speech API (Browser)</option>
                                    </select>
                                </div>
                                <div class="setting-item">
                                    <label for="web-speech-language">Web Speech API language</label>
                                    <select id="web-speech-language">
                                        <option value="en-US" selected>English (United States)</option>
                                        <option value="en-GB">English (United Kingdom)</option>
                                        <option value="en-AU">English (Australia)</option>
                                        <option value="en-CA">English (Canada)</option>
                                        <option value="en-IN">English (India)</option>
                                        <option value="es-ES">Spanish (Spain)</option>
                                        <option value="es-MX">Spanish (Mexico)</option>
                                        <option value="es-AR">Spanish (Argentina)</option>
                                        <option value="fr-FR">French (France)</option>
                                        <option value="fr-CA">French (Canada)</option>
                                        <option value="de-DE">German (Germany)</option>
                                        <option value="it-IT">Italian (Italy)</option>
                                        <option value="pt-BR">Portuguese (Brazil)</option>
                                        <option value="pt-PT">Portuguese (Portugal)</option>
                                        <option value="ru-RU">Russian (Russia)</option>
                                        <option value="ja-JP">Japanese (Japan)</option>
                                        <option value="ko-KR">Korean (South Korea)</option>
                                        <option value="zh-CN">Chinese (Mandarin, Simplified)</option>
                                        <option value="zh-TW">Chinese (Traditional, Taiwan)</option>
                                        <option value="zh-HK">Chinese (Cantonese, Hong Kong)</option>
                                        <option value="ar-SA">Arabic (Saudi Arabia)</option>
                                        <option value="hi-IN">Hindi (India)</option>
                                        <option value="th-TH">Thai (Thailand)</option>
                                        <option value="vi-VN">Vietnamese (Vietnam)</option>
                                        <option value="nl-NL">Dutch (Netherlands)</option>
                                        <option value="sv-SE">Swedish (Sweden)</option>
                                        <option value="da-DK">Danish (Denmark)</option>
                                        <option value="no-NO">Norwegian (Norway)</option>
                                        <option value="fi-FI">Finnish (Finland)</option>
                                        <option value="pl-PL">Polish (Poland)</option>
                                        <option value="cs-CZ">Czech (Czech Republic)</option>
                                        <option value="hu-HU">Hungarian (Hungary)</option>
                                        <option value="tr-TR">Turkish (Turkey)</option>
                                        <option value="he-IL">Hebrew (Israel)</option>
                                        <option value="id-ID">Indonesian (Indonesia)</option>
                                        <option value="ms-MY">Malay (Malaysia)</option>
                                        <option value="uk-UA">Ukrainian (Ukraine)</option>
                                        <option value="bg-BG">Bulgarian (Bulgaria)</option>
                                        <option value="hr-HR">Croatian (Croatia)</option>
                                        <option value="sk-SK">Slovak (Slovakia)</option>
                                        <option value="sl-SI">Slovenian (Slovenia)</option>
                                        <option value="et-EE">Estonian (Estonia)</option>
                                        <option value="lv-LV">Latvian (Latvia)</option>
                                        <option value="lt-LT">Lithuanian (Lithuania)</option>
                                        <option value="ro-RO">Romanian (Romania)</option>
                                        <option value="el-GR">Greek (Greece)</option>
                                        <option value="ca-ES">Catalan (Spain)</option>
                                        <option value="eu-ES">Basque (Spain)</option>
                                        <option value="gl-ES">Galician (Spain)</option>
                                    </select>
                                </div>
                                <div class="setting-item">
                                    <button id="test-microphone" class="settings-btn">🎤 Test Microphone</button>
                                </div>
                                <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                                    <p style="font-size: 12px; color: #666; margin: 5px 0;">
                                        <strong>OpenAI Whisper:</strong> More accurate, supports multiple languages, requires API key<br>
                                        <strong>Web Speech API:</strong> Free, works offline, limited language support
                                    </p>
                                </div>
                            </div>
                            
                            <!-- AI Models Settings -->
                            <div class="settings-panel" id="ai-panel">
                                <h3>AI Model Settings</h3>
                                
                                <!-- Voice Recognition Section -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">🎤 Voice Recognition</h4>
                                    <div class="setting-item">
                                        <label for="openai-whisper-key">OpenAI Whisper API Key</label>
                                        <input type="password" id="openai-whisper-key" placeholder="sk-proj-...">
                                    </div>
                                    <div class="setting-item">
                                        <label for="openai-whisper-url">OpenAI Whisper API URL</label>
                                        <input type="url" id="openai-whisper-url" value="https://api.openai.com/v1/audio/transcriptions" placeholder="https://api.openai.com/v1/audio/transcriptions">
                                    </div>
                                </div>
                                
                                <!-- Code Generation Section -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">💻 Code Generation</h4>
                                    
                                    <!-- Provider Selection -->
                                    <div class="setting-item">
                                        <label for="llm-provider">LLM Provider</label>
                                        <select id="llm-provider">
                                            <option value="openrouter">OpenRouter</option>
                                            <option value="openai">OpenAI API</option>
                                            <option value="lmstudio">LMStudio</option>
                                        </select>
                                    </div>
                                    
                                    <!-- OpenRouter Configuration -->
                                    <div id="openrouter-config" class="provider-config">
                                        <div class="setting-item">
                                            <label for="openrouter-api-key">OpenRouter API Key</label>
                                            <input type="password" id="openrouter-api-key" placeholder="sk-or-v1-...">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-url">OpenRouter API URL</label>
                                            <input type="url" id="openrouter-url" value="https://openrouter.ai/api/v1/chat/completions" placeholder="https://openrouter.ai/api/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-simple-model">Simple Model Name</label>
                                            <input type="text" id="openrouter-simple-model" value="google/gemini-2.5-flash-lite-preview-06-17" placeholder="google/gemini-2.5-flash-lite-preview-06-17">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-tough-model">Tough Model Name</label>
                                            <input type="text" id="openrouter-tough-model" value="anthropic/claude-sonnet-4" placeholder="anthropic/claude-sonnet-4">
                                        </div>
                                    </div>
                                    
                                    <!-- OpenAI Configuration -->
                                    <div id="openai-config" class="provider-config" style="display: none;">
                                        <div class="setting-item">
                                            <label for="openai-api-key">OpenAI API Key</label>
                                            <input type="password" id="openai-api-key" placeholder="sk-...">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-url">OpenAI API URL</label>
                                            <input type="url" id="openai-url" value="https://api.openai.com/v1/chat/completions" placeholder="https://api.openai.com/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-simple-model">Simple Model Name</label>
                                            <input type="text" id="openai-simple-model" value="gpt-4o-mini" placeholder="gpt-4o-mini">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-tough-model">Tough Model Name</label>
                                            <input type="text" id="openai-tough-model" value="gpt-4o" placeholder="gpt-4o">
                                        </div>
                                    </div>
                                    
                                    <!-- LMStudio Configuration -->
                                    <div id="lmstudio-config" class="provider-config" style="display: none;">
                                        <div class="setting-item">
                                            <label for="lmstudio-url">LMStudio API URL</label>
                                            <input type="url" id="lmstudio-url" value="http://localhost:1234/v1/chat/completions" placeholder="http://localhost:1234/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="lmstudio-simple-model">Simple Model Name</label>
                                            <input type="text" id="lmstudio-simple-model" value="llama-3.2-3b-instruct" placeholder="llama-3.2-3b-instruct">
                                        </div>
                                        <div class="setting-item">
                                            <label for="lmstudio-tough-model">Tough Model Name</label>
                                            <input type="text" id="lmstudio-tough-model" value="llama-3.1-8b-instruct" placeholder="llama-3.1-8b-instruct">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- General Settings -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">⚙️ General</h4>
                                    <div class="setting-item">
                                        <label for="api-timeout">API Timeout (seconds)</label>
                                        <input type="number" id="api-timeout" value="30" min="10" max="120">
                                    </div>
                                    <div class="setting-item">
                                        <label for="max-retries">Max Retries</label>
                                        <input type="number" id="max-retries" value="3" min="1" max="10">
                                    </div>
                                    <div class="setting-item">
                                        <label for="cost-tracking">Enable cost tracking</label>
                                        <input type="checkbox" id="cost-tracking" checked>
                                    </div>
                                    <div class="setting-item">
                                        <button id="reset-cost" class="settings-btn">💰 Reset Cost Counter</button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- System Settings -->
                            <div class="settings-panel" id="system-panel">
                                <h3>System Settings</h3>
                                <div class="setting-item">
                                    <label for="debug-mode">Debug mode</label>
                                    <input type="checkbox" id="debug-mode">
                                </div>
                                <div class="setting-item">
                                    <button id="clear-cache" class="settings-btn">🗑️ Clear Cache</button>
                                </div>
                                <div class="setting-item">
                                    <button id="export-settings" class="settings-btn">📤 Export Settings</button>
                                </div>
                                <div class="setting-item">
                                    <button id="import-settings" class="settings-btn">📥 Import Settings</button>
                                    <input type="file" id="settings-file-input" accept=".json" style="display: none;">
                                </div>
                                <div class="setting-item">
                                    <button id="reset-settings" class="settings-btn">🔄 Reset All Settings</button>
                                </div>
                            </div>
                            
                            <!-- About Settings -->
                            <div class="settings-panel" id="about-panel">
                                <h3>About Self-Evolving OS</h3>
                                <div class="about-info">
                                    <p><strong>Version:</strong> 2.0.0</p>
                                    <p><strong>Build:</strong> 2025.01.20</p>
                                    <p><strong>Platform:</strong> Web-based OS</p>
                                    <p><strong>AI Models:</strong> OpenAI GPT & Claude</p>
                                    <p><strong>Features:</strong> Voice commands, AI app generation, Dynamic UI</p>
                                    <br>
                                    <p><strong>Total Apps Created:</strong> <span id="total-apps-created">0</span></p>
                                    <p><strong>Current Session Apps:</strong> <span id="current-session-apps">0</span></p>
                                    <p><strong>Total API Cost:</strong> $<span id="total-api-cost">0.00</span></p>
                                    <br>
                                    <p style="font-size: 12px; color: #666;">
                                        Self-Evolving OS is an experimental AI-powered operating system interface
                                        that can create and modify applications on demand using natural language commands.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                </div>
            `;
            
            // Create Settings app directly
            const settingsId = generateAppId();
            const settingsApp = {
                id: settingsId,
                type: 'system',
                title: 'Settings',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System Settings'
            };

            apps.push(settingsApp);
            createWindow(settingsId, 'Settings', settingsContent, 700, 500);
            createTaskbarIcon(settingsId, 'Settings');
            updateAppCount();
            
            // Add settings-specific CSS
            addSettingsCSS(settingsId);
            
            // Add event listeners for settings functionality
            setTimeout(() => {
                initializeSettingsEventListeners(settingsId);
            }, 100);
            
            document.getElementById('start-menu').classList.remove('show');
        }

        function addSettingsCSS(appId) {
            const settingsCSS = `
                .settings-container {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                }
                
                .settings-categories {
                    display: flex;
                    flex: 1;
                    gap: 0;
                }
                
                .settings-nav {
                    width: 200px;
                    background: #f8f9fa;
                    border-right: 1px solid #dee2e6;
                    padding: 10px 0;
                    display: flex;
                    flex-direction: column;
                }
                
                .settings-nav-btn {
                    background: none;
                    border: none;
                    padding: 12px 20px;
                    text-align: left;
                    cursor: pointer;
                    font-size: 14px;
                    color: #495057;
                    transition: all 0.2s ease;
                    border-left: 3px solid transparent;
                }
                
                .settings-nav-btn:hover {
                    background: #e9ecef;
                    color: #0078d4;
                }
                
                .settings-nav-btn.active {
                    background: #e3f2fd;
                    color: #0078d4;
                    border-left-color: #0078d4;
                    font-weight: 600;
                }
                
                .settings-content {
                    flex: 1;
                    padding: 20px;
                    overflow-y: auto;
                }
                
                .settings-panel {
                    display: none;
                }
                
                .settings-panel.active {
                    display: block;
                }
                
                .settings-panel h3 {
                    margin: 0 0 20px 0;
                    color: #333;
                    font-size: 18px;
                    font-weight: 600;
                }
                
                .setting-item {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    padding: 12px 0;
                    border-bottom: 1px solid #f0f0f0;
                }
                
                .setting-item:last-child {
                    border-bottom: none;
                }
                
                .setting-item label {
                    font-weight: 500;
                    color: #333;
                    flex: 1;
                }
                
                .setting-item input, .setting-item select {
                    padding: 6px 10px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 14px;
                }
                
                .setting-item input[type="checkbox"] {
                    width: 18px;
                    height: 18px;
                }
                
                .setting-item input[type="range"] {
                    width: 120px;
                    margin-right: 10px;
                }
                
                .settings-btn {
                    background: #6c757d;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                    transition: background 0.2s ease;
                }
                
                .settings-btn:hover {
                    background: #5a6268;
                }
                
                .settings-btn.primary {
                    background: #0078d4;
                }
                
                .settings-btn.primary:hover {
                    background: #106ebe;
                }
                
                .settings-footer {
                    padding: 15px 20px;
                    border-top: 1px solid #dee2e6;
                    background: #f8f9fa;
                    display: flex;
                    gap: 10px;
                    justify-content: flex-end;
                }
                
                .about-info {
                    line-height: 1.6;
                }
                
                .about-info p {
                    margin: 5px 0;
                }
            `;
            
            addAppCSS(settingsCSS, appId);
        }

        function initializeSettingsEventListeners(settingsId) {
            // Navigation between settings categories
            const navButtons = document.querySelectorAll('.settings-nav-btn');
            const panels = document.querySelectorAll('.settings-panel');
            
            navButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.dataset.category;
                    
                    // Update active nav button
                    navButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Update active panel
                    panels.forEach(p => p.classList.remove('active'));
                    document.getElementById(category + '-panel').classList.add('active');
                });
            });
            
            // Transparency slider
            const transparencySlider = document.getElementById('transparency');
            const transparencyValue = document.getElementById('transparency-value');
            if (transparencySlider && transparencyValue) {
                transparencySlider.addEventListener('input', (e) => {
                    const value = Math.round(e.target.value * 100);
                    transparencyValue.textContent = value + '%';
                });
            }
            
            // Microphone sensitivity slider
            const sensitivitySlider = document.getElementById('microphone-sensitivity');
            const sensitivityValue = document.getElementById('sensitivity-value');
            if (sensitivitySlider && sensitivityValue) {
                sensitivitySlider.addEventListener('input', (e) => {
                    const value = Math.round(e.target.value * 100);
                    sensitivityValue.textContent = value + '%';
                });
            }
            
            // Test microphone button
            const testMicBtn = document.getElementById('test-microphone');
            if (testMicBtn) {
                testMicBtn.addEventListener('click', () => {
                    testMicrophone();
                });
            }
            
            // Reset cost button
            const resetCostBtn = document.getElementById('reset-cost');
            if (resetCostBtn) {
                resetCostBtn.addEventListener('click', () => {
                    if (confirm('Reset the API cost counter to $0.00?')) {
                        totalCost = 0;
                        document.getElementById('api-cost').textContent = '0.00';
                        alert('Cost counter reset successfully!');
                    }
                });
            }
            
            // Clear cache button
            const clearCacheBtn = document.getElementById('clear-cache');
            if (clearCacheBtn) {
                clearCacheBtn.addEventListener('click', () => {
                    if (confirm('Clear all cached data? This will not affect your current apps.')) {
                        // Could implement cache clearing here
                        alert('Cache cleared successfully!');
                    }
                });
            }
            
            // Export settings button
            const exportBtn = document.getElementById('export-settings');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    const settings = {
                        version: '2.0.0',
                        exportDate: new Date().toISOString(),
                        settings: {
                            autoSave: document.getElementById('auto-save')?.checked,
                            startupApps: document.getElementById('startup-apps')?.checked,
                            maxApps: document.getElementById('max-apps')?.value,
                            theme: document.getElementById('theme')?.value,
                            transparency: document.getElementById('transparency')?.value,
                            animations: document.getElementById('animations')?.checked,
                            voiceEnabled: document.getElementById('voice-enabled')?.checked,
                            pushToTalk: document.getElementById('push-to-talk')?.checked,
                            debugMode: document.getElementById('debug-mode')?.checked,
                            performanceMode: document.getElementById('performance-mode')?.checked
                        }
                    };
                    
                    const dataStr = JSON.stringify(settings, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = 'self_evolving_os_settings.json';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                });
            }
            
            // Import settings button
            const importBtn = document.getElementById('import-settings');
            const fileInput = document.getElementById('settings-file-input');
            if (importBtn && fileInput) {
                importBtn.addEventListener('click', () => {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const settings = JSON.parse(e.target.result);
                                if (settings.settings) {
                                    // Apply imported settings
                                    Object.keys(settings.settings).forEach(key => {
                                        const element = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());
                                        if (element) {
                                            if (element.type === 'checkbox') {
                                                element.checked = settings.settings[key];
                                            } else {
                                                element.value = settings.settings[key];
                                            }
                                        }
                                    });
                                    alert('Settings imported successfully!');
                                }
                            } catch (error) {
                                alert('Failed to import settings: Invalid file format');
                            }
                        };
                        reader.readAsText(file);
                    }
                });
            }
            
            // Reset settings button
            const resetBtn = document.getElementById('reset-settings');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (confirm('Reset all settings and restart the setup assistant? This will delete all your current configuration and close all apps.')) {
                        // Delete the settings cookie
                        document.cookie = 'selfEvolvingOS_settings=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
                        
                        // Clear any localStorage data
                        localStorage.removeItem('costHistory');
                        
                        // Reset global variables to defaults
                        voiceRecognitionType = 'whisper';
                        CONFIG.OPENAI_API_KEY = 'sk-proj-...';
                        CONFIG.OPENROUTER_API_KEY = 'sk-...';
                        CONFIG.CURRENT_LLM_PROVIDER = 'openrouter';
                        totalCost = 0;
                        costHistory = [];
                        window.costHistory = costHistory;
                        
                        // Update cost display
                        const costElement = document.getElementById('api-cost');
                        if (costElement) {
                            costElement.textContent = '0.00';
                        }
                        
                        // Close all apps
                        [...apps].forEach(app => closeWindow(app.id));
                        
                        // Show confirmation and reload
                        alert('Settings reset successfully! The page will reload and the setup assistant will start.');
                        
                        // Reload the page to restart with fresh state
                        window.location.reload();
                    }
                });
            }
            
            // Voice recognition type change handler
            const voiceTypeSelect = document.getElementById('voice-recognition-type');
            if (voiceTypeSelect) {
                voiceTypeSelect.addEventListener('change', async (e) => {
                    const newType = e.target.value;
                    console.log(`Switching voice recognition from ${voiceRecognitionType} to ${newType}`);
                    
                    // Stop current voice session if active
                    if (isListening) {
                        stopVoiceSession();
                    }
                    
                    // Update the global setting
                    voiceRecognitionType = newType;
                    
                    // Re-initialize voice system with new type
                    try {
                        await initializeVoice();
                        console.log(`Voice system re-initialized with ${newType}`);
                        
                        // Show confirmation
                        const statusMsg = newType === 'web' ?
                            'Switched to Web Speech API (Browser-based)' :
                            'Switched to OpenAI Whisper (Cloud-based)';
                        
                        // Temporarily show status
                        updateVoiceStatus(statusMsg, 'ready');
                        setTimeout(() => {
                            updateVoiceStatus(`Voice Ready (${newType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
                        }, 3000);
                        
                    } catch (error) {
                        console.error('Failed to re-initialize voice system:', error);
                        updateVoiceStatus('Voice Error', 'error');
                        
                        // Revert the selection if initialization failed
                        voiceTypeSelect.value = voiceRecognitionType === 'web' ? 'whisper' : 'web';
                        voiceRecognitionType = voiceTypeSelect.value;
                    }
                });
            }
            
            // Web Speech API language change handler
            const webSpeechLanguageSelect = document.getElementById('web-speech-language');
            if (webSpeechLanguageSelect) {
                webSpeechLanguageSelect.addEventListener('change', async (e) => {
                    const newLanguage = e.target.value;
                    console.log(`Changing Web Speech API language to: ${newLanguage}`);
                    
                    // If currently using Web Speech API, re-initialize with new language
                    if (voiceRecognitionType === 'web') {
                        // Stop current voice session if active
                        if (isListening) {
                            stopVoiceSession();
                        }
                        
                        try {
                            await initializeVoice();
                            console.log(`Web Speech API re-initialized with language: ${newLanguage}`);
                            
                            // Show confirmation
                            const languageText = e.target.options[e.target.selectedIndex].text;
                            updateVoiceStatus(`Language changed to ${languageText}`, 'ready');
                            setTimeout(() => {
                                updateVoiceStatus('Voice Ready (Web)', 'ready');
                            }, 3000);
                            
                        } catch (error) {
                            console.error('Failed to re-initialize Web Speech API with new language:', error);
                            updateVoiceStatus('Language Change Error', 'error');
                            setTimeout(() => {
                                updateVoiceStatus('Voice Ready (Web)', 'ready');
                            }, 2000);
                        }
                    }
                });
            }
            
            // Update about info
            const totalAppsElement = document.getElementById('total-apps-created');
            const currentAppsElement = document.getElementById('current-session-apps');
            const totalCostElement = document.getElementById('total-api-cost');
            
            if (totalAppsElement) totalAppsElement.textContent = nextAppId - 1;
            if (currentAppsElement) currentAppsElement.textContent = apps.length;
            if (totalCostElement) totalCostElement.textContent = totalCost.toFixed(4);
            
            // Auto-save settings when any input changes
            const settingsInputs = document.querySelectorAll('.settings-panel input, .settings-panel select');
            settingsInputs.forEach(input => {
                input.addEventListener('change', () => {
                    saveSettingsToCookie();
                    console.log('Settings auto-saved');
                });
            });
            
            // Theme change handler for immediate application
            const themeSelect = document.getElementById('theme');
            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    const newTheme = e.target.value;
                    applyTheme(newTheme);
                    console.log(`Theme changed to: ${newTheme}`);
                });
            }
            
            // API Settings change handlers for immediate application
            const apiSettingsInputs = [
                'openai-whisper-key',
                'openai-whisper-url',
                'openrouter-api-key',
                'openrouter-url',
                'simple-model',
                'tough-model'
            ];
            
            apiSettingsInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', () => {
                        const settings = saveSettingsToCookie();
                        applySettingsToSystem(settings);
                        console.log(`API setting ${inputId} updated and applied`);
                    });
                }
            });
            
            // Load and apply saved settings
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                applySettingsToUI(savedSettings);
                applySettingsToSystem(savedSettings);
            }
    
            // LLM Provider switching functionality
            function initializeLLMProviderSwitching() {
                const providerSelect = document.getElementById('llm-provider');
                if (!providerSelect) return;
                
                // Show/hide provider configurations based on selection
                function showProviderConfig(provider) {
                    // Hide all provider configs
                    document.querySelectorAll('.provider-config').forEach(config => {
                        config.style.display = 'none';
                    });
                    
                    // Show selected provider config
                    const selectedConfig = document.getElementById(`${provider}-config`);
                    if (selectedConfig) {
                        selectedConfig.style.display = 'block';
                    }
                    
                    // Update current provider display in header
                    updateCurrentProviderDisplay(provider);
                }
                
                // Handle provider selection change
                providerSelect.addEventListener('change', (e) => {
                    const selectedProvider = e.target.value;
                    showProviderConfig(selectedProvider);
                    
                    // Save settings when provider changes
                    saveSettingsToCookie();
                    debugLog(`LLM Provider changed to: ${selectedProvider}`);
                });
                
                // Initialize with current selection
                showProviderConfig(providerSelect.value);
            }
    
            // Update the current provider display in the header
            function updateCurrentProviderDisplay(provider) {
                const providerDisplay = document.getElementById('current-provider-display');
                if (providerDisplay) {
                    const providerNames = {
                        'openrouter': 'OpenRouter',
                        'openai': 'OpenAI',
                        'lmstudio': 'LMStudio'
                    };
                    providerDisplay.textContent = providerNames[provider] || provider;
                }
            }
            
            // Initialize cost tracking
            loadCostHistory();
            updateCostTrackingAppVisibility();
            
            // Initialize LLM provider switching
            initializeLLMProviderSwitching();
            
            // Load and display current LLM provider from settings
            const providerSettings = loadSettingsFromCookie();
            if (providerSettings && providerSettings.llmProvider) {
                updateCurrentProviderDisplay(providerSettings.llmProvider);
            } else {
                updateCurrentProviderDisplay('openrouter'); // Default
            }
            
        }

        // Initialize the system when page loads
        window.addEventListener('load', init);

        // Handle Enter key in app request input
        document.addEventListener('keypress', function(e) {
            if (e.target.id === 'app-request' && e.key === 'Enter') {
                requestApp();
            }
        });

        // Initialize voice recognition on page load
        // Voice system will be initialized by DOMContentLoaded event handler above
    </script>
</body>
</html>