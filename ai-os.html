<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-OS</title>
    
    <!--
    NAMESPACE ISOLATION SYSTEM
    =========================
    
    This AI-OS implements comprehensive namespace isolation to prevent conflicts between apps:
    
    1. APP CONTAINER ISOLATION
       - Each app runs in its own DOM container: #content_${appId}
       - CSS is automatically scoped to the app container
       - JavaScript is wrapped in app-specific IIFE namespaces
    
    2. HTML ELEMENT NAMESPACING
       - All element IDs must be prefixed: ${appId}_elementName
       - All CSS classes must be prefixed: ${appId}__className
       - Enforced through AI prompt instructions and validation
    
    3. JAVASCRIPT SCOPE ISOLATION
       - Each app gets its own namespace: window[app_${appId}]
       - Helper functions provided: app.getElementById(), app.querySelector()
       - Custom events namespaced: ${appId}:eventName
    
    4. CSS NAMESPACE SCOPING
       - All CSS rules automatically scoped to #content_${appId}
       - Prevents style bleeding between apps
       - Maintains theme support through .app-light-theme/.app-dark-theme
    
    5. CLEANUP SYSTEM
       - Automatic cleanup when apps are closed
       - Removes CSS, JavaScript, and namespace objects
       - Prevents memory leaks and namespace pollution
    
    Key Functions:
    - generateAppId(): Creates unique app identifiers
    - namespaceCSS(): Scopes CSS to app containers
    - namespaceJavaScript(): Wraps JS in isolated namespaces
    - cleanupAppNamespace(): Removes app resources on close
    - validateAppNamespace(): Validates namespace compliance
    -->

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .desktop {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .taskbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
        }

        .start-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            margin-right: 20px;
            min-height: 44px;
            transition: all 0.2s ease;
        }

        .start-button:hover {
            background: #106ebe;
        }

        .model-toggle-container {
            margin-right: 20px;
        }

        .model-toggle-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            min-height: 36px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .model-toggle-button:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .model-toggle-button.tough-mode {
            background: #dc3545;
        }

        .model-toggle-button.tough-mode:hover {
            background: #c82333;
        }

        .app-icons {
            display: flex;
            gap: 10px;
            flex: 1;
        }

        .app-icon {
            width: 40px;
            height: 35px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 18px;
            text-align: center;
            transition: background 0.2s;
            position: relative;
        }

        .taskbar-icon {
            font-size: 18px;
            line-height: 1;
        }

        .app-icon:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .app-icon:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .app-icon.active {
            background: rgba(255, 255, 255, 0.4);
        }

        .window {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-width: 300px;
            min-height: 200px;
            z-index: 9999;
            overflow: hidden;
        }

        .window.maximized {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: calc(100% - 50px) !important;
            border-radius: 0;
        }

        .window.minimized {
            display: none;
        }

        .window-header {
            background: #f0f0f0;
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            -webkit-user-select: none;
            user-select: none;
            min-height: 50px;
        }

        .window-title {
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            min-width: 0;
        }

        .window-icon {
            font-size: 14px;
            line-height: 1;
            flex-shrink: 0;
        }

        .window-title-text {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .window-controls {
            display: flex;
            gap: 8px;
        }

        .window-control {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .minimize { background: #ffc107; }
        .maximize { background: #28a745; }
        .close { background: #dc3545; color: white; }

        .window-control:hover {
            opacity: 0.8;
        }

        .window-voice-button {
            width: 40px;
            height: 40px;
            border: none;
            background: #007bff;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .window-voice-button:hover {
            background: #0056b3;
        }

        .window-voice-button.recording {
            background: #dc3545;
            animation: pulse 1s infinite;
        }

        .window-text-button {
            width: 40px;
            height: 40px;
            border: none;
            background: #28a745;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .window-text-button:hover {
            background: #218838;
        }

        .window-download-button {
            width: 40px;
            height: 40px;
            border: none;
            background: #6f42c1;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border-radius: 6px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .window-download-button:hover {
            background: #5a32a3;
        }

        .window-history-button {
            width: 40px;
            height: 40px;
            background: #fd7e14;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            transition: background 0.2s;
        }

        .window-history-button:hover {
            background: #e8590c;
        }

        .window-content {
            padding: 20px;
            height: calc(100% - 81px);
            overflow: auto;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: se-resize;
            background: linear-gradient(-45deg, transparent 0%, transparent 40%, #ccc 40%, #ccc 60%, transparent 60%);
        }

        .start-menu {
            position: fixed;
            bottom: 50px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 20px;
            display: none;
            z-index: 1001;
        }

        .start-menu.show {
            display: block;
        }

        .menu-section {
            margin-bottom: 20px;
        }

        .menu-title {
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .menu-item {
            padding: 15px 20px;
            color: white;
            cursor: pointer;
            border-radius: 6px;
            margin-bottom: 8px;
            transition: background 0.2s;
            font-size: 16px;
            min-height: 44px;
            display: flex;
            align-items: center;
        }

        .menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .menu-item.has-submenu {
            position: relative;
        }

        .menu-item.has-submenu .apps-submenu {
            position: absolute;
            left: 100%;
            top: 0;
            width: 280px;
            max-height: 400px;
            background: rgba(0, 0, 0, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 15px;
            display: none;
            z-index: 1002;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            margin-left: 10px;
        }

        .menu-item.has-submenu .apps-submenu.show {
            display: block;
        }

        .menu-item.has-submenu::after {
            content: '▶';
            position: absolute;
            right: 15px;
            font-size: 12px;
            transition: transform 0.2s;
        }

        .menu-item.has-submenu:hover::after {
            transform: translateX(2px);
        }

        .apps-submenu.show {
            display: block;
        }

        .apps-submenu-title {
            color: white;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
        }

        .apps-submenu-item {
            padding: 12px 15px;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 4px;
            transition: background 0.2s;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .apps-submenu-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .submenu-app-icon {
            font-size: 16px;
            line-height: 1;
            min-width: 20px;
        }

        .submenu-app-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .request-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .request-button {
            background: #0078d4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        .request-button:hover {
            background: #106ebe;
        }

        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            font-size: 12px;
            z-index: 1000;
        }

        .voice-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .voice-button {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
        }

        .voice-button:hover {
            background: #c82333;
        }

        .voice-button.listening {
            background: #28a745;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .voice-status {
            font-size: 11px;
            color: #ccc;
        }

        /* Voice Command Popup */
        .voice-command-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            font-size: 18px;
            font-weight: 500;
            text-align: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
            max-width: 80%;
            word-wrap: break-word;
        }

        .voice-command-popup.show {
            opacity: 1;
        }

        .voice-command-popup.fade-out {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        .voice-command-popup::before {
            content: '🎤';
            display: block;
            font-size: 24px;
            margin-bottom: 10px;
        }

        /* Theme Styles */
        body.dark-theme {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
        }

        body.dark-theme .taskbar {
            background: rgba(0, 0, 0, 0.9);
            color: #f8f9fa;
        }

        body.dark-theme .start-menu {
            background: rgba(0, 0, 0, 0.95);
            color: #f8f9fa;
        }

        body.dark-theme .window {
            background: #2c3e50;
            color: #f8f9fa;
        }

        body.dark-theme .window-header {
            background: #34495e;
            border-bottom: 1px solid #4a5f7a;
            color: #f8f9fa;
        }

        body.dark-theme .window-content {
            background: #2c3e50;
            color: #f8f9fa;
        }

        body.dark-theme .status-bar {
            background: rgba(0, 0, 0, 0.9);
            color: #f8f9fa;
        }

        body.dark-theme .settings-container {
            background: #2c3e50;
            color: #f8f9fa;
        }

        body.dark-theme .settings-nav {
            background: #34495e;
            border-right: 1px solid #4a5f7a;
        }

        body.dark-theme .settings-nav-btn {
            color: #e9ecef !important;
            font-weight: 500;
        }

        body.dark-theme .settings-nav-btn:hover {
            background: #4a5f7a;
            color: #ffffff !important;
        }

        body.dark-theme .settings-nav-btn.active {
            background: #3498db;
            color: #ffffff !important;
            border-left-color: #3498db;
        }

        body.dark-theme .setting-item {
            border-bottom: 1px solid #4a5f7a;
        }

        body.dark-theme .setting-item label {
            color: #f8f9fa !important;
            font-weight: 500;
        }

        body.dark-theme .setting-item input,
        body.dark-theme .setting-item select {
            background: #34495e;
            border: 1px solid #4a5f7a;
            color: #f8f9fa;
        }

        body.dark-theme .settings-footer {
            background: #34495e;
            border-top: 1px solid #4a5f7a;
        }

        /* Enhanced Dark Mode text contrast */
        body.dark-theme h1,
        body.dark-theme h2,
        body.dark-theme h3,
        body.dark-theme h4,
        body.dark-theme h5,
        body.dark-theme h6 {
            color: #ffffff !important;
            font-weight: 600;
        }

        body.dark-theme .settings-header h1,
        body.dark-theme .settings-header h2,
        body.dark-theme .settings-title {
            color: #ffffff !important;
            font-weight: 700;
        }

        body.dark-theme .settings-content h3 {
            color: #ffffff !important;
            font-weight: 600;
        }

        body.dark-theme p {
            color: #e9ecef !important;
        }

        body.dark-theme .menu-title {
            color: #ffffff !important;
            font-weight: 600;
        }

        body.dark-theme .menu-item {
            color: #f8f9fa !important;
            font-weight: 500;
        }

        body.dark-theme .menu-item:hover {
            background: rgba(52, 152, 219, 0.2) !important;
            color: #ffffff !important;
        }

        body.dark-theme .start-button {
            color: #f8f9fa !important;
            font-weight: 600;
        }

        body.dark-theme .model-toggle-button {
            color: #f8f9fa !important;
            border: 1px solid #4a5f7a !important;
        }

        /* Specific fix for Settings header with inline style override */
        body.dark-theme #settings-main-title {
            color: #ffffff !important;
            font-weight: 700;
            text-shadow: none;
        }

        body.dark-theme .settings-container h1,
        body.dark-theme .settings-container h2,
        body.dark-theme .settings-container .settings-title,
        body.dark-theme .settings-panel h3 {
            color: #ffffff !important;
            font-weight: 700;
            text-shadow: none;
        }

        /* Fix for any remaining dim text */
        body.dark-theme * {
            color: inherit;
        }

        body.dark-theme .settings-content {
            color: #f8f9fa !important;
        }

        /* Dark theme fixes for voice command popup and request input */
        body.dark-theme .voice-command-popup {
            background: rgba(44, 62, 80, 0.95) !important;
            color: #ffffff !important;
            border: 2px solid rgba(52, 152, 219, 0.3) !important;
        }

        body.dark-theme .request-input {
            background: #34495e !important;
            color: #f8f9fa !important;
            border: 1px solid #4a5f7a !important;
        }

        body.dark-theme .request-input::placeholder {
            color: #bdc3c7 !important;
        }

        /* Dark theme styles for Apps sub-menu */
        body.dark-theme .apps-submenu {
            background: rgba(44, 62, 80, 0.95) !important;
            border: 1px solid rgba(52, 152, 219, 0.3) !important;
        }

        body.dark-theme .apps-submenu-title {
            color: #ffffff !important;
            border-bottom-color: rgba(52, 152, 219, 0.3) !important;
        }

        body.dark-theme .apps-submenu-item {
            color: #f8f9fa !important;
        }

        body.dark-theme .apps-submenu-item:hover {
            background: rgba(52, 152, 219, 0.2) !important;
        }

        /* Dark theme styles for icon elements */
        body.dark-theme .window-title {
            color: #f8f9fa !important;
        }

        body.dark-theme .window-icon,
        body.dark-theme .taskbar-icon,
        body.dark-theme .submenu-app-icon {
            opacity: 1;
        }

        body.dark-theme .app-icon:hover {
            background: rgba(255, 255, 255, 0.4) !important;
        }

        body.light-theme {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        body.light-theme .taskbar {
            background: rgba(255, 255, 255, 0.95);
            color: #212529;
        }

        body.light-theme .start-menu {
            background: rgba(255, 255, 255, 0.98);
            color: #212529;
            border: 1px solid #dee2e6;
        }

        body.light-theme .window {
            background: white;
            color: #212529;
        }

        body.light-theme .window-header {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            color: #333;
        }

        body.light-theme .window-content {
            background: white;
            color: #333;
        }

        body.light-theme .status-bar {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        body.light-theme .settings-container {
            background: white;
            color: #333;
        }

        body.light-theme .settings-nav {
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
        }

        body.light-theme .settings-nav-btn {
            color: #495057;
        }

        body.light-theme .settings-nav-btn:hover {
            background: #e9ecef;
            color: #0078d4;
        }

        body.light-theme .settings-nav-btn.active {
            background: #e3f2fd;
            color: #0078d4;
            border-left-color: #0078d4;
        }

        body.light-theme .setting-item {
            border-bottom: 1px solid #f0f0f0;
        }

        body.light-theme .setting-item label {
            color: #212529;
            font-weight: 500;
        }

        body.light-theme .setting-item input,
        body.light-theme .setting-item select {
            background: white;
            border: 1px solid #ced4da;
            color: #212529;
        }

        body.light-theme .settings-footer {
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
        }

        /* Enhanced Start Menu contrast for Light Theme */
        body.light-theme .menu-title {
            color: #495057 !important;
            font-weight: 600;
        }

        body.light-theme .menu-item {
            color: #212529 !important;
            font-weight: 500;
        }

        body.light-theme .menu-item:hover {
            background: rgba(0, 123, 255, 0.1) !important;
            color: #0056b3 !important;
        }

        body.light-theme .request-input {
            color: #212529 !important;
            border: 1px solid #ced4da !important;
        }

        body.light-theme .request-input::placeholder {
            color: #6c757d !important;
        }

        body.light-theme .request-button {
            background: #007bff !important;
            color: white !important;
            border: none !important;
        }

        body.light-theme .request-button:hover {
            background: #0056b3 !important;
        }

        body.light-theme .start-button {
            color: #212529 !important;
            font-weight: 600;
        }

        body.light-theme .model-toggle-button {
            color: #212529 !important;
            border: 1px solid #ced4da !important;
        }

        /* Light theme styles for Apps sub-menu */
        body.light-theme .apps-submenu {
            background: rgba(255, 255, 255, 0.98) !important;
            border: 1px solid #dee2e6 !important;
        }

        body.light-theme .apps-submenu-title {
            color: #495057 !important;
            border-bottom-color: #dee2e6 !important;
        }

        body.light-theme .apps-submenu-item {
            color: #212529 !important;
        }

        body.light-theme .apps-submenu-item:hover {
            background: rgba(0, 123, 255, 0.1) !important;
            color: #0056b3 !important;
        }

        /* Light theme styles for icon elements */
        body.light-theme .window-title {
            color: #333 !important;
        }

        body.light-theme .window-icon,
        body.light-theme .taskbar-icon,
        body.light-theme .submenu-app-icon {
            opacity: 1;
        }

        body.light-theme .app-icon:hover {
            background: rgba(0, 0, 0, 0.1) !important;
        }
    </style>
</head>
<body>
    <div class="desktop" id="desktop">
        <!-- Windows will be dynamically created here -->
    </div>

    <div class="status-bar">
        <div class="status-info">
            <span id="clock"></span> | Apps: <span id="app-count">0</span> | Cost: $<span id="api-cost">0.00</span> | LLM: <span id="current-provider-display">OpenRouter</span>
        </div>
        <div class="voice-controls">
            <span class="voice-status" id="voice-status">Voice Ready</span>
            <button class="voice-button" id="voice-button" title="Click or Hold to Talk">🎤</button>
        </div>
    </div>

    <!-- Voice Command Popup -->
    <div class="voice-command-popup" id="voice-command-popup"></div>

    <div class="taskbar">
        <button class="start-button" onclick="toggleStartMenu()">Start</button>
        <div class="model-toggle-container">
            <button class="model-toggle-button" id="model-toggle" onclick="toggleModelMode()">
                <span id="model-mode-text">Simple</span>
            </button>
        </div>
        <div class="app-icons" id="app-icons">
            <!-- App icons will be dynamically created here -->
        </div>
    </div>

    <div class="start-menu" id="start-menu">
        <div class="menu-section">
            <div class="menu-title">Request New App</div>
            <input type="text" class="request-input" id="app-request" placeholder="Describe the app you want (e.g., calculator, calendar, quiz app, weather app, etc.) - You can also paste screenshots with Ctrl+V">
            <div id="new-app-pasted-images" style="margin-top: 10px; display: none;">
                <div style="font-size: 12px; color: #ccc; margin-bottom: 8px;">📷 Pasted Images:</div>
                <div id="new-app-image-preview-container" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
            </div>
            <button class="request-button" onclick="requestApp()">Create App with AI</button>
        </div>
        
        <div class="menu-section">
            <div class="menu-title">Voice Commands</div>
            <p style="color: #ccc; font-size: 12px; margin: 0;">Click the microphone button in the top-right corner and say:</p>
            <p style="color: #ccc; font-size: 11px; margin: 5px 0 0 0;">"Create a calculator app" or "Make me a todo list"</p>
        </div>

        <div class="menu-section">
            <div class="menu-title">Apps</div>
            <div class="menu-item has-submenu" onclick="toggleAppsSubmenu()" onmouseenter="showAppsSubmenu()" onmouseleave="hideAppsSubmenuDelayed()">
                📱 All Apps
                <!-- Apps Sub-menu -->
                <div class="apps-submenu" id="apps-submenu" onmouseenter="showAppsSubmenu()" onmouseleave="hideAppsSubmenuDelayed()">
                    <div class="apps-submenu-title">All Apps</div>
                    <div id="apps-submenu-content">
                        <!-- Apps will be dynamically populated here -->
                    </div>
                </div>
            </div>
        </div>

        <div class="menu-section">
            <div class="menu-title">System</div>
            <div class="menu-item" onclick="showSettings()">⚙️ Settings</div>
            <div class="menu-item" onclick="showAppList()">📋 App Manager</div>
            <div class="menu-item" onclick="triggerLoadApp()">📁 Load App</div>
            <div class="menu-item" onclick="closeAllApps()">❌ Close All Apps</div>
        </div>
    </div>

    <script>
        const ROLE_PROMPT = `
You are an expert web developer specializing in creating modular, theme-aware web applications.
Your task is to generate HTML, CSS, and JavaScript code for a new app based on user requests.

        `;

        const NAMESPACEISOLATION_GUIDELINES = `

NAMESPACE ISOLATION REQUIREMENTS:
- ALL HTML element IDs MUST be prefixed with "{appId}_" (e.g., id="{appId}_button1")
- ALL CSS classes MUST be prefixed with "{appId}__" (e.g., class="{appId}__container")
- ALL JavaScript variables and functions MUST be scoped to avoid conflicts
- ALL custom events MUST be prefixed with "{appId}:" (e.g., "{appId}:dataChanged")
- Use querySelector with app-specific selectors: document.querySelector('#{appId}_elementId')
`;

        // Global CSS Guidelines for App Creation
        const CSS_GUIDELINES = `

ESSENTIAL CSS GUIDELINES FOR THEME SUPPORT AND ACCESSIBILITY:

TECHNICAL REQUIREMENTS:
1. Use semantic HTML with proper button elements and unique IDs
2. Center all content horizontally and vertically
3. Responsive design that adapts to window size
4. Clean, modern appearance with proper spacing
5. CSS: Keep simple, no line breaks, avoid complex selectors
6. HTML: Use single quotes for attributes to avoid JSON conflicts. NEVER use onclick attributes - use IDs instead
7. IMPORTANT: class names can only contain lowercase letters, numbers, underscores, and dashes
8. MANDATORY: the font color of an element should always contrast with the background color

CRITICAL THEME REQUIREMENTS:
- Apps automatically inherit .app-light-theme or .app-dark-theme classes
- ALWAYS design for BOTH light and dark modes
- Current theme: {currentTheme}

MANDATORY CONTRAST RULES:
1. Minimum 4.5:1 contrast ratio required
2. NEVER light text on light backgrounds or dark text on dark backgrounds
3. Yellow/warning colors MUST use dark text (#212529)
4. All other colored buttons use white text (#ffffff)
5. Display text must be clearly visible against display background
6. Use CSS theme classes: .app-light-theme and .app-dark-theme for all styling
7. Implement CSS grid or flexbox for precise button layout

APPROVED COLOR PALETTE:

Light Mode:
- Backgrounds: #ffffff, #f8f9fa, #e9ecef
- Text: #212529 (primary), #495057 (secondary), #6c757d (muted)
- Buttons: #007bff (primary), #28a745 (success), #dc3545 (danger), #ffc107 (warning with dark text)

Dark Mode:
- Backgrounds: #2c3e50, #34495e, #495057
- Text: #f8f9fa (primary), #e9ecef (secondary), #ced4da (muted)
- Buttons: #0d6efd (primary), #198754 (success), #dc3545 (danger), #ffc107 (warning with dark text)

SAFE COMBINATIONS:
✅ #ffffff text on #007bff, #28a745, #dc3545 backgrounds
✅ #212529 text on #ffc107 background (warning)
✅ #212529 text on #ffffff background (light mode)
✅ #f8f9fa text on #2c3e50 background (dark mode)

❌ #ffffff text on #ffc107 (white on yellow - FORBIDDEN)
❌ Light text on light backgrounds
❌ Dark text on dark backgrounds

IMPLEMENTATION:
- Use theme-aware CSS classes for different modes
- Include hover/focus states for all interactive elements
- Ensure 44px minimum touch targets
- Keep responsive design (300-600px window width)
`;

        // Global CSS Guidelines for App Creation
        const JAVASCRIPT_GUIDELINES = `

ESSENTIAL JAVASCRIPT CODE GENERATION GUIDELINES:
- Write your JavaScript to handle all user interactions using addEventListener pattern
- Ensure all form elements, buttons, and interactive areas have proper event handling
- Test your logic mentally to ensure the app will work as expected
- Keep code simple and avoid overly complex string manipulations that could cause parsing issues
- The JSON must use double quotes " for all keys and string values
- Escape all double quotes inside the JavaScript string as \"
- Escape all backslashes \ as \\
- Use \n for line breaks in multiline JavaScript code
- Ensure the result can be parsed with JSON.parse() in JavaScript
- Write clean JavaScript with addEventListener for all interactions
- CRITICAL JSON FORMATTING: Ensure all strings are properly escaped for JSON
- Avoid complex JavaScript with many quotes, brackets, or special characters
- Keep JavaScript simple and readable to prevent JSON parsing errors
- Always use document.getElementById() and addEventListener() pattern
- Keep Javascript scripts simple and avoid complex string operations that could break JSON
- All declared variables must be prefixed with "{appId}_" to avoid conflicts
        `;

        const APPCREATION_PROMPT = `
TASK:
You are creating a functional app for a windowed operating system interface.

CRITICAL REQUIREMENTS:
1. Create a COMPLETE, FUNCTIONAL app that works in a window
2. The app will be placed inside a window with ID "content_{appId}"
3. Use ONLY vanilla HTML, CSS, and JavaScript - no external libraries
4. Make the app responsive and fit well in a window (300-600px wide)
5. Include ALL necessary functionality for the requested app
6. Use modern, clean UI design

RESPONSE FORMAT - Return ONLY a JSON object with this structure:
{
  "title": "App Name",
  "icon": "📱",
  "html": "complete HTML content",
  "css": "complete CSS styles",
  "javascript": "complete JavaScript functionality"
}

ICON REQUIREMENTS:
- Choose a single UTF-8 emoji that best represents the app's function
- Examples: 📅 for calendar, 🧮 for calculator, 📝 for text editor, 🎮 for games, 📊 for charts, etc.
- The icon should be intuitive and clearly represent the app's purpose

CONTENT RULES:
- Always create BOTH the User Interface AND the Logic (JavaScript)
- For interactive elements (buttons, inputs, forms), ALWAYS include JavaScript
- CRITICAL: Use addEventListener in JavaScript, NOT onclick attributes in HTML
- Give all interactive elements unique IDs and reference them in JavaScript
- IMPORTANT: onclick attributes will NOT work because JavaScript runs in isolated scope
- Make sure you do not break the Response Format - return a valid JSON object

    `;

    // modificationPrompt
        const APPMODIFY_PROMPT = `
TASK:
You are modifying an existing app for a windowed operating system interface. The user wants you to make changes to the existing app. The user may also submit images to show problems or give graphical advice for changes.
This is the modification request of the user:
{modificationRequest}

CURRENT APP CONTEXT:
- App ID: {appId}
- Current Title: {appTitle}

- App Edit Prompts History:
{promptHistory}

CURRENT APP CODE:
=== CURRENT HTML ===
{currentHTML}

=== CURRENT CSS ===
{currentCSS}

=== CURRENT JAVASCRIPT
{currentJavaScript}

IMPORTANT: You are MODIFYING the existing app above, NOT creating a new one.

MODIFICATION RULES
1. Keep the existing functionality that works
2. Only change what is needed for the modification request
3. Preserve the current UI structure where possible, change the UI only if the user asks for it
4. Build upon the existing code rather than replacing it entirely
5. You will not write json code block delimiters.
6. Also ENSURE the requests from the App Edit Prompts History keep implemented

CRITICAL REQUIREMENTS
1. MODIFY the existing app according to the user request
2. Keep the same basic app structure but implement the requested changes
3. The app will be placed inside a window with ID content_ + appId +
4. Use ONLY vanilla HTML, CSS, and JavaScript - no external libraries
5. Make the app responsive and fit well in a window (300-600px wide)
6. Include ALL necessary functionality for the modified app
7. Use modern, clean UI design
8. FOLLOW CSS GUIDELINES for theme support and accessibility:

RESPONSE FORMAT - Return ONLY a JSON object with this structure:
{
  "html": "complete HTML content",
  "css": "complete CSS styles",
  "javascript": "complete JavaScript functionality"
}

IMPORTANT: Do NOT include a "title" field - the app name and icon must remain unchanged during editing.
`;


        // Global app management system
        let apps = [];
        let nextAppId = 1;
        let activeWindow = null;
        let dragData = null;
        let resizeData = null;

        // Initialize the system
        function init() {
            updateClock();
            setInterval(updateClock, 1000);
            updateAppCount();
            
            // Load and apply saved settings on startup BEFORE voice initialization
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                applySettingsToSystem(savedSettings);
                console.log('Loaded settings from cookie on startup');
            } else {
                // No settings found - start setup assistant
                console.log('No settings found, starting setup assistant');
                setTimeout(() => startSetupAssistant(), 500);
            }
            
            // Close start menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.start-menu') && !e.target.closest('.start-button')) {
                    document.getElementById('start-menu').classList.remove('show');
                }
            });
            
            // Initialize new app request image pasting functionality
            initializeNewAppImagePasting();
        }

        // Global variable to store pasted images for new app requests
        let newAppPastedImages = [];

        function initializeNewAppImagePasting() {
            const appRequestInput = document.getElementById('app-request');
            if (!appRequestInput) return;

            // Add paste event listener for image support
            appRequestInput.addEventListener('paste', async (e) => {
                const items = e.clipboardData.items;
                
                for (let item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        e.preventDefault();
                        
                        const file = item.getAsFile();
                        if (file) {
                            try {
                                // Convert image to base64
                                const base64 = await fileToBase64NewApp(file);
                                
                                // Add to pasted images array
                                const imageData = {
                                    base64: base64,
                                    type: file.type,
                                    name: `new-app-image-${Date.now()}.${file.type.split('/')[1]}`
                                };
                                newAppPastedImages.push(imageData);
                                
                                // Show image preview
                                showNewAppImagePreview(imageData, newAppPastedImages.length - 1);
                                
                                // Show the pasted images container
                                const pastedImagesContainer = document.getElementById('new-app-pasted-images');
                                if (pastedImagesContainer) {
                                    pastedImagesContainer.style.display = 'block';
                                }
                                
                                console.log('Image pasted successfully for new app:', imageData.name);
                            } catch (error) {
                                console.error('Error processing pasted image for new app:', error);
                                alert('Error processing pasted image. Please try again.');
                            }
                        }
                    }
                }
            });

            // Helper function to convert file to base64 for new app
            function fileToBase64NewApp(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            // Helper function to show image preview for new app
            function showNewAppImagePreview(imageData, index) {
                const container = document.getElementById('new-app-image-preview-container');
                if (!container) return;

                const previewDiv = document.createElement('div');
                previewDiv.style.cssText = `
                    position: relative;
                    display: inline-block;
                    border: 1px solid #666;
                    border-radius: 4px;
                    overflow: hidden;
                `;

                const img = document.createElement('img');
                img.src = imageData.base64;
                img.style.cssText = `
                    width: 60px;
                    height: 60px;
                    object-fit: cover;
                    display: block;
                `;

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '×';
                removeBtn.style.cssText = `
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    width: 16px;
                    height: 16px;
                    background: rgba(220, 53, 69, 0.8);
                    color: white;
                    border: none;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 10px;
                    line-height: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                removeBtn.addEventListener('click', () => {
                    // Remove from array
                    newAppPastedImages.splice(index, 1);
                    // Remove preview
                    previewDiv.remove();
                    // Hide container if no images left
                    if (newAppPastedImages.length === 0) {
                        const pastedImagesContainer = document.getElementById('new-app-pasted-images');
                        if (pastedImagesContainer) {
                            pastedImagesContainer.style.display = 'none';
                        }
                    }
                    // Update indices for remaining images
                    updateNewAppImageIndices();
                });

                previewDiv.appendChild(img);
                previewDiv.appendChild(removeBtn);
                container.appendChild(previewDiv);
            }

            // Helper function to update image indices after removal
            function updateNewAppImageIndices() {
                const container = document.getElementById('new-app-image-preview-container');
                if (!container) return;
                
                const previews = container.children;
                for (let i = 0; i < previews.length; i++) {
                    const removeBtn = previews[i].querySelector('button');
                    if (removeBtn) {
                        removeBtn.onclick = () => {
                            newAppPastedImages.splice(i, 1);
                            previews[i].remove();
                            if (newAppPastedImages.length === 0) {
                                document.getElementById('new-app-pasted-images').style.display = 'none';
                            }
                            updateNewAppImageIndices();
                        };
                    }
                }
            }
        }

        function updateClock() {
            const now = new Date();
            document.getElementById('clock').textContent = now.toLocaleTimeString();
        }

        function updateAppCount() {
            document.getElementById('app-count').textContent = apps.length;
        }

        function updateProviderDisplay() {
            const providerElement = document.getElementById('current-provider-display');
            if (providerElement) {
                // Capitalize the provider name for display
                const displayName = CONFIG.CURRENT_LLM_PROVIDER.charAt(0).toUpperCase() + CONFIG.CURRENT_LLM_PROVIDER.slice(1);
                providerElement.textContent = displayName;
            }
        }

        function toggleStartMenu() {
            const menu = document.getElementById('start-menu');
            menu.classList.toggle('show');
        }

        function toggleModelMode() {
            const toggleButton = document.getElementById('model-toggle');
            const modeText = document.getElementById('model-mode-text');
            
            if (currentModelMode === 'Simple') {
                // Switch to Tough mode
                currentModelMode = 'Tough';
                CONFIG.MODEL = CONFIG.MODEL_TOUGH;
                modeText.textContent = 'Tough';
                toggleButton.classList.add('tough-mode');
            } else {
                // Switch to Simple mode
                currentModelMode = 'Simple';
                CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                modeText.textContent = 'Simple';
                toggleButton.classList.remove('tough-mode');
            }
            
            console.log(`Model mode switched to: ${currentModelMode} (${CONFIG.MODEL})`);
        }

        function generateAppId() {
            // Generate a unique ID using timestamp + random characters
            // This ensures uniqueness even after page reloads
            const timestamp = Date.now().toString(36); // Base36 timestamp (shorter)
            const randomPart = Math.random().toString(36).substr(2, 4); // 4 random chars
            return `app_${timestamp}${randomPart}`;
        }

        function validateAppNamespace(html, css, javascript, appId) {
            const issues = [];
            
            // Check HTML for proper ID prefixing
            const htmlIdMatches = html.match(/id=['"]([^'"]+)['"]/g) || [];
            htmlIdMatches.forEach(match => {
                const id = match.match(/id=['"]([^'"]+)['"]/)[1];
                if (!id.startsWith(`${appId}_`)) {
                    issues.push(`HTML ID "${id}" should be prefixed with "${appId}_"`);
                }
            });
            
            // Check HTML for proper class prefixing
            const htmlClassMatches = html.match(/class=['"]([^'"]+)['"]/g) || [];
            htmlClassMatches.forEach(match => {
                const classes = match.match(/class=['"]([^'"]+)['"]/)[1].split(' ');
                classes.forEach(className => {
                    if (className.trim() && !className.startsWith(`${appId}__`) && !className.startsWith('app-')) {
                        issues.push(`HTML class "${className}" should be prefixed with "${appId}__"`);
                    }
                });
            });
            
            // Check CSS for proper scoping
            if (css && !css.includes(`#content_${appId}`)) {
                issues.push('CSS should be scoped to the app container');
            }
            
            // Check JavaScript for namespace usage
            if (javascript && !javascript.includes('appId')) {
                issues.push('JavaScript should use the provided appId parameter for namespacing');
            }
            
            if (issues.length > 0) {
                console.warn(`Namespace validation issues for app ${appId}:`, issues);
                return { valid: false, issues };
            }
            
            return { valid: true, issues: [] };
        }

        function createAppHelperFunctions(appId) {
            return `
// App Helper Functions for ${appId}
const app = {
    id: '${appId}',
    
    // Get element by app-scoped ID (without prefix)
    getElementById: (id) => document.getElementById('${appId}_' + id),
    
    // Query within app container
    querySelector: (selector) => document.querySelector('#content_${appId} ' + selector),
    querySelectorAll: (selector) => document.querySelectorAll('#content_${appId} ' + selector),
    
    // App-scoped event system
    emit: (eventName, detail) => {
        document.dispatchEvent(new CustomEvent('${appId}:' + eventName, { detail }));
    },
    
    on: (eventName, handler) => {
        document.addEventListener('${appId}:' + eventName, handler);
    },
    
    off: (eventName, handler) => {
        document.removeEventListener('${appId}:' + eventName, handler);
    },
    
    // App data storage
    data: window['${appId}_data'] || (window['${appId}_data'] = {}),
    
    // Utility functions
    addClass: (elementId, className) => {
        const el = app.getElementById(elementId);
        if (el) el.classList.add('${appId}__' + className);
    },
    
    removeClass: (elementId, className) => {
        const el = app.getElementById(elementId);
        if (el) el.classList.remove('${appId}__' + className);
    }
};
            `;
        }

        // Debug function to test namespace isolation
        function testNamespaceIsolation() {
            console.log('🧪 Testing Namespace Isolation System...');
            
            // Test 1: Check if apps have unique IDs
            const appIds = apps.map(app => app.id);
            const uniqueIds = [...new Set(appIds)];
            console.log(`✅ App ID Uniqueness: ${appIds.length === uniqueIds.length ? 'PASS' : 'FAIL'}`);
            
            // Test 2: Check if namespaces exist
            let namespaceCount = 0;
            apps.forEach(app => {
                const namespace = `app_${app.id.replace(/-/g, '_')}`;
                if (window[namespace]) {
                    namespaceCount++;
                }
            });
            console.log(`✅ Namespace Creation: ${namespaceCount}/${apps.length} apps have namespaces`);
            
            // Test 3: Check CSS isolation
            const styleElements = document.querySelectorAll('[id^="style-app_"]');
            console.log(`✅ CSS Isolation: ${styleElements.length} app-specific stylesheets found`);
            
            // Test 4: Check JavaScript isolation
            const scriptElements = document.querySelectorAll('[id^="script-app_"]');
            console.log(`✅ JavaScript Isolation: ${scriptElements.length} app-specific scripts found`);
            
            // Test 5: Check container isolation
            const containers = document.querySelectorAll('[id^="content_app_"]');
            console.log(`✅ Container Isolation: ${containers.length} app containers found`);
            
            console.log('🧪 Namespace Isolation Test Complete');
            
            return {
                uniqueIds: appIds.length === uniqueIds.length,
                namespaces: namespaceCount,
                cssIsolation: styleElements.length,
                jsIsolation: scriptElements.length,
                containers: containers.length
            };
        }

        // Make test function globally available for debugging
        window.testNamespaceIsolation = testNamespaceIsolation;

        function createWindow(appId, title, content, width = 400, height = 300, icon = '📱') {
            const desktop = document.getElementById('desktop');
            const window = document.createElement('div');
            window.className = 'window';
            window.id = `window_${appId}`;
            window.style.width = width + 'px';
            window.style.height = height + 'px';
            
            // Center the window in the desktop area (below header)
            const headerHeight = 50;
            const desktopRect = desktop.getBoundingClientRect();
            const availableWidth = desktopRect.width;
            const availableHeight = desktopRect.height;
            
            window.style.left = Math.max(0, (availableWidth - width) / 2) + 'px';
            window.style.top = Math.max(10, (availableHeight - height) / 2) + 'px';
            
            // Z-index is now handled by CSS class (9999)

            window.innerHTML = `
                <div class="window-header" onmousedown="startDrag(event, '${appId}')">
                    <div class="window-title" ontouchstart="startDrag(event, '${appId}')">
                        <span class="window-icon">${icon}</span>
                        <span class="window-title-text">${title}</span>
                    </div>
                    <div class="window-controls">
                        <button class="window-voice-button" id="voice-button-${appId}" title="Hold to talk - Modify this app with voice">🎤</button>
                        <button class="window-text-button" id="text-button-${appId}" title="Edit this app with text prompt">✏️</button>
                        <button class="window-history-button" id="history-button-${appId}" title="View prompt history" onclick="showPromptHistory('${appId}')">📜</button>
                        <button class="window-download-button" id="download-button-${appId}" title="Download this app">💾</button>
                        <button class="window-control minimize" onclick="minimizeWindow('${appId}')">−</button>
                        <button class="window-control maximize" onclick="toggleMaximize('${appId}')">□</button>
                        <button class="window-control close" onclick="closeWindow('${appId}')">×</button>
                    </div>
                </div>
                <div class="window-content" id="content_${appId}">
                    ${content}
                </div>
                <div class="resize-handle" onmousedown="startResize(event, '${appId}')"></div>
            `;

            desktop.appendChild(window);
            
            // Apply current theme to the app content
            applyThemeToApp(appId);
            
            // Dispatch app shown event for newly created apps
            setTimeout(() => dispatchAppShownEvent(appId), 100); // Small delay to ensure app is fully rendered
            
            // Add push-to-talk event handlers to the app voice button
            const appVoiceButton = document.getElementById(`voice-button-${appId}`);
            if (appVoiceButton) {
                // Mouse events for push-to-talk
                appVoiceButton.addEventListener('mousedown', function(e) {
                    if (e.button === 0) { // Left mouse button
                        e.preventDefault();
                        startAppVoiceCommand(appId);
                    }
                });

                appVoiceButton.addEventListener('mouseup', function(e) {
                    if (e.button === 0) { // Left mouse button
                        e.preventDefault();
                        stopAppVoiceCommand(appId);
                    }
                });

                // Touch events for mobile push-to-talk
                appVoiceButton.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startAppVoiceCommand(appId);
                });

                appVoiceButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    stopAppVoiceCommand(appId);
                });

                // Click event as fallback (toggle behavior)
                appVoiceButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (!isListening || currentModifyingAppId !== appId) {
                        startAppVoiceCommand(appId);
                    } else {
                        stopAppVoiceCommand(appId);
                    }
                });
            }
            
            // Add event listener to the app text button
            const appTextButton = document.getElementById(`text-button-${appId}`);
            if (appTextButton) {
                appTextButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    showTextPromptDialog(appId);
                });
            }
            
            // Add event listener to the app download button
            const appDownloadButton = document.getElementById(`download-button-${appId}`);
            if (appDownloadButton) {
                appDownloadButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    downloadApp(appId);
                });
            }
            
            bringToFront(appId);
            return window;
        }

        function generateAppIcon(customRequest, title) {
            // Convert request and title to lowercase for matching
            const request = customRequest.toLowerCase();
            const appTitle = title.toLowerCase();
            
            // Define icon mappings based on keywords
            const iconMappings = {
                // Math & Calculation
                'calculator': '🧮',
                'calc': '🧮',
                'math': '🧮',
                'arithmetic': '🧮',
                
                // Time & Calendar
                'clock': '🕐',
                'time': '⏰',
                'timer': '⏱️',
                'stopwatch': '⏱️',
                'calendar': '📅',
                'schedule': '📅',
                'date': '📅',
                
                // Text & Documents
                'text': '📝',
                'note': '📝',
                'editor': '📝',
                'document': '📄',
                'word': '📄',
                'write': '✍️',
                
                // Games
                'game': '🎮',
                'puzzle': '🧩',
                'quiz': '❓',
                'trivia': '🧠',
                'memory': '🧠',
                'card': '🃏',
                'dice': '🎲',
                
                // Media
                'music': '🎵',
                'audio': '🔊',
                'video': '🎬',
                'player': '▶️',
                'media': '🎭',
                
                // Tools & Utilities
                'tool': '🔧',
                'utility': '⚙️',
                'converter': '🔄',
                'generator': '⚡',
                'random': '🎲',
                
                // Communication
                'chat': '💬',
                'message': '💬',
                'mail': '📧',
                'email': '📧',
                
                // Weather & Environment
                'weather': '🌤️',
                'temperature': '🌡️',
                'forecast': '🌦️',
                
                // Finance & Shopping
                'money': '💰',
                'cost': '💰',
                'price': '💲',
                'budget': '💰',
                'finance': '💰',
                'shopping': '🛒',
                'cart': '🛒',
                
                // Health & Fitness
                'health': '🏥',
                'fitness': '💪',
                'exercise': '🏃',
                'workout': '💪',
                
                // Food & Cooking
                'food': '🍽️',
                'recipe': '👨‍🍳',
                'cooking': '👨‍🍳',
                'restaurant': '🍽️',
                
                // Travel & Maps
                'map': '🗺️',
                'travel': '✈️',
                'navigation': '🧭',
                'location': '📍',
                
                // Education & Learning
                'learn': '📚',
                'education': '🎓',
                'study': '📖',
                'book': '📚',
                'library': '📚',
                
                // Art & Design
                'art': '🎨',
                'design': '🎨',
                'draw': '✏️',
                'paint': '🎨',
                'color': '🌈',
                
                // Science & Technology
                'science': '🔬',
                'lab': '🔬',
                'experiment': '🧪',
                'data': '📊',
                'chart': '📈',
                'graph': '📊',
                
                // Default categories
                'app': '📱',
                'application': '📱',
                'program': '💻'
            };
            
            // Check for matches in request first, then title
            const searchText = `${request} ${appTitle}`;
            
            for (const [keyword, icon] of Object.entries(iconMappings)) {
                if (searchText.includes(keyword)) {
                    return icon;
                }
            }
            
            // Default icon if no match found
            return '📱';
        }

        function createApp(customRequest) {
            const appId = generateAppId();
            const title = 'New App';
            const icon = generateAppIcon(customRequest, title);
            const content = createAIGeneratedAppContent(customRequest, appId);

            const app = {
                id: appId,
                type: 'ai-generated',
                title: title,
                icon: icon,
                isMinimized: false,
                isMaximized: false,
                system: false,
                customRequest: customRequest,
                promptHistory: [],
                namespace: `app_${appId.replace(/-/g, '_')}` // Store namespace for cleanup
            };

            apps.push(app);
            createWindow(appId, title, content, 400, 300, icon);
            createTaskbarIcon(appId, title, icon);
            updateAppCount();
            
            // Update apps submenu to include the new user-generated app
            updateAppsSubmenuContent();

            return appId;
        }

        function createAppWithImages(customRequest, images) {
            const appId = generateAppId();
            const title = 'New App';
            const icon = generateAppIcon(customRequest, title);
            const content = createAIGeneratedAppContentWithImages(customRequest, images, appId);

            const app = {
                id: appId,
                type: 'ai-generated',
                title: title,
                icon: icon,
                isMinimized: false,
                isMaximized: false,
                system: false,
                customRequest: customRequest,
                promptHistory: [],
                namespace: `app_${appId.replace(/-/g, '_')}`, // Store namespace for cleanup
                hasImages: true,
                imageCount: images.length
            };

            apps.push(app);
            createWindow(appId, title, content, 400, 300, icon);
            createTaskbarIcon(appId, title, icon);
            updateAppCount();
            
            // Update apps submenu to include the new user-generated app
            updateAppsSubmenuContent();

            return appId;
        }

        function createTaskbarIcon(appId, title, appIcon = '📱') {
            const iconsContainer = document.getElementById('app-icons');
            const icon = document.createElement('div');
            icon.className = 'app-icon';
            icon.id = `icon_${appId}`;
            icon.onclick = () => toggleWindow(appId);
            icon.innerHTML = `<span class="taskbar-icon">${appIcon}</span>`;
            icon.title = title; // Show title on hover
            iconsContainer.appendChild(icon);
        }

        function requestApp() {
            const request = document.getElementById('app-request').value.trim();
            if (request || newAppPastedImages.length > 0) {
                if (newAppPastedImages.length > 0) {
                    console.log(`Creating app with ${newAppPastedImages.length} images`);
                    createAppWithImages(request, newAppPastedImages);
                } else {
                    createApp(request);
                }
                
                // Clear the input and images
                document.getElementById('app-request').value = '';
                newAppPastedImages = [];
                
                // Hide image preview container
                const pastedImagesContainer = document.getElementById('new-app-pasted-images');
                if (pastedImagesContainer) {
                    pastedImagesContainer.style.display = 'none';
                }
                
                // Clear image previews
                const imageContainer = document.getElementById('new-app-image-preview-container');
                if (imageContainer) {
                    imageContainer.innerHTML = '';
                }
                
                document.getElementById('start-menu').classList.remove('show');
            }
        }

        // Voice Recognition System using OpenAI Realtime API
        let isListening = false;

        // Initialize voice system on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up voice system...');
            
            // Voice button event handlers for Whisper API - attach immediately
            const voiceButton = document.getElementById('voice-button');
            console.log('Voice button element:', voiceButton);
            
            if (voiceButton) {
                voiceButton.addEventListener('click', function() {
                    console.log('Voice button clicked!'); // Debug log
                    if (!isListening) {
                        startVoiceSession();
                    } else {
                        stopVoiceSession();
                    }
                });
                console.log('Voice button click handler attached');
            } else {
                console.error('Voice button element not found!');
            }
            
            // Load saved settings first, then initialize voice system
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                if (savedSettings.voiceRecognitionType) {
                    voiceRecognitionType = savedSettings.voiceRecognitionType;
                    console.log(`Loaded voice recognition type from settings: ${voiceRecognitionType}`);
                }
                
                // Also apply the Web Speech API language if it's saved
                if (savedSettings.webSpeechLanguage && voiceRecognitionType === 'web') {
                    console.log(`Loaded Web Speech API language from settings: ${savedSettings.webSpeechLanguage}`);
                }
            }
            
            // Initialize voice in background (non-blocking) with correct settings
            initializeVoice().then(() => {
                console.log('Voice system initialized successfully');
            }).catch((error) => {
                console.warn('Voice initialization failed:', error);
                updateVoiceStatus('Voice Error', 'error');
            });

            // Also support mousedown/mouseup for push-to-talk
            document.getElementById('voice-button').addEventListener('mousedown', function(e) {
                if (e.button === 0 && !isListening) { // Left mouse button
                    startVoiceSession();
                }
            });

            document.getElementById('voice-button').addEventListener('mouseup', function(e) {
                if (e.button === 0 && isListening) { // Left mouse button
                    stopVoiceSession();
                }
            });

            // Touch events for mobile
            document.getElementById('voice-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (!isListening) {
                    startVoiceSession();
                }
            });

            document.getElementById('voice-button').addEventListener('touchend', function(e) {
                e.preventDefault();
                if (isListening) {
                    stopVoiceSession();
                }
            });

            // Initialize model mode to Simple (default) only if no settings were loaded
            // This prevents overwriting the model set from saved settings
            // Check if settings were already loaded in init()
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' && CONFIG.MODEL === 'google/gemini-2.5-flash-lite-preview-06-17') {
                // No settings were loaded, use default
                CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                console.log(`Model initialized to: ${currentModelMode} mode (${CONFIG.MODEL})`);
            } else {
                console.log(`Model loaded from settings: ${currentModelMode} mode (${CONFIG.MODEL})`);
            }
        });

        // Voice Handler supporting both Whisper and Web Speech API
        async function initializeVoice() {
            try {
                // Check Web Speech API support
                isWebSpeechSupported = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;
                
                if (voiceRecognitionType === 'web' && isWebSpeechSupported) {
                    // Initialize Web Speech API
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    webSpeechRecognition = new SpeechRecognition();
                    webSpeechRecognition.continuous = false;
                    webSpeechRecognition.interimResults = false;
                    
                    // Get selected language from settings or saved settings or default to en-US
                    let selectedLanguage = 'en-US';
                    
                    // First try to get from UI element
                    const languageSelect = document.getElementById('web-speech-language');
                    if (languageSelect && languageSelect.value) {
                        selectedLanguage = languageSelect.value;
                    } else {
                        // If UI element not available, try to get from saved settings
                        const savedSettings = loadSettingsFromCookie();
                        if (savedSettings && savedSettings.webSpeechLanguage) {
                            selectedLanguage = savedSettings.webSpeechLanguage;
                        }
                    }
                    
                    webSpeechRecognition.lang = selectedLanguage;
                    console.log(`Web Speech API initialized with language: ${selectedLanguage}`);
                    
                    webSpeechRecognition.onresult = function(event) {
                        const transcript = event.results[0][0].transcript;
                        console.log('Web Speech transcript:', transcript);
                        handleVoiceTranscription(transcript);
                    };
                    
                    webSpeechRecognition.onerror = function(event) {
                        console.error('Web Speech error:', event.error);
                        updateVoiceStatus('Voice Error', 'error');
                        isListening = false;
                    };
                    
                    webSpeechRecognition.onend = function() {
                        console.log('Web Speech ended');
                        isListening = false;
                        updateVoiceStatus('Voice Ready', 'ready');
                    };
                    
                    updateVoiceStatus('Voice Ready (Web)', 'ready');
                    return true;
                } else {
                    // Initialize Whisper API (requires microphone access)
                    mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                    
                    updateVoiceStatus('Voice Ready (Whisper)', 'ready');
                    return true;
                }
            } catch (error) {
                console.error('Voice initialization failed:', error);
                updateVoiceStatus('Voice Error', 'error');
                return false;
            }
        }

        async function startVoiceSession() {
            console.log(`🎙️ startVoiceSession() called with type: ${voiceRecognitionType}`);
            console.log(`🔍 isListening: ${isListening}`);
            
            if (isListening) {
                console.log(`❌ Already listening, returning early`);
                return;
            }
            
            try {
                isListening = true;
                updateVoiceStatus('Recording...', 'listening');
                console.log('✅ Voice session starting...');
                
                if (voiceRecognitionType === 'web' && isWebSpeechSupported && webSpeechRecognition) {
                    // Use Web Speech API
                    console.log('🌐 Starting Web Speech Recognition...');
                    webSpeechRecognition.start();
                } else {
                    // Use Whisper API
                    console.log('🎤 Starting Whisper recording...');
                    
                    if (!mediaStream) {
                        console.log(`❌ No mediaStream available, initializing...`);
                        try {
                            await initializeVoice();
                            console.log(`✅ Voice system re-initialized`);
                        } catch (error) {
                            console.error(`❌ Failed to re-initialize voice system:`, error);
                            updateVoiceStatus('Voice Error', 'error');
                            isListening = false;
                            return;
                        }
                    }
                    
                    // Start recording audio for Whisper
                    mediaRecorder = new MediaRecorder(mediaStream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    // Clear and initialize audio chunks array
                    audioChunks = [];
                    console.log(`🧹 Initialized fresh audioChunks array, length: ${audioChunks.length}`);
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        console.log('Recording stopped, processing audio...');
                        updateVoiceStatus('Processing...', 'processing');
                        
                        // Create audio blob
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        
                        // Send to Whisper API
                        await transcribeAudio(audioBlob);
                    };
                    
                    mediaRecorder.start();
                }
                
            } catch (error) {
                console.error('Failed to start voice session:', error);
                stopVoiceSession();
                updateVoiceStatus('Voice Error', 'error');
            }
        }

        function handleVoiceTranscription(transcription) {
            console.log('Voice transcription received:', transcription);
            
            if (transcription.trim()) {
                // Show voice command popup
                showVoiceCommandPopup(transcription.trim());
                
                // Check if we're modifying an existing app or creating a new one
                if (currentModifyingAppId) {
                    // Modify existing app
                    modifyApp(currentModifyingAppId, transcription.trim());
                    
                    // Reset the voice button appearance
                    const voiceButton = document.querySelector(`#window_${currentModifyingAppId} .window-voice-button`);
                    if (voiceButton) {
                        voiceButton.classList.remove('recording');
                    }
                    
                    // Clear the modifying app ID
                    currentModifyingAppId = null;
                } else {
                    // Create new app based on voice command
                    createApp(transcription.trim());
                }
                
                updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
            } else {
                updateVoiceStatus('No speech detected', 'error');
                setTimeout(() => updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready'), 2000);
            }
        }

        async function transcribeAudio(audioBlob) {
            try {
                // Convert to FormData for Whisper API
                const formData = new FormData();
                formData.append('file', audioBlob, 'audio.webm');
                formData.append('model', 'whisper-1');
                formData.append('response_format', 'text');
                
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${CONFIG.OPENAI_API_KEY}`
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Whisper API error: ${response.status}`);
                }
                
                const transcription = await response.text();
                console.log('Whisper transcription:', transcription);
                
                // Use the common transcription handler
                handleVoiceTranscription(transcription);
                
            } catch (error) {
                console.error('Whisper transcription failed:', error);
                updateVoiceStatus('Transcription Error', 'error');
                setTimeout(() => updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready'), 2000);
            }
        }

        function stopVoiceSession() {
            console.log(`🛑 Stopping voice session (type: ${voiceRecognitionType})...`);
            isListening = false;
            
            if (voiceRecognitionType === 'web' && webSpeechRecognition) {
                // Stop Web Speech API
                try {
                    webSpeechRecognition.stop();
                    console.log(`🛑 Stopped Web Speech Recognition`);
                } catch (error) {
                    console.warn('Error stopping Web Speech Recognition:', error);
                }
            } else {
                // Stop Whisper recording
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    console.log(`🛑 Stopping mediaRecorder...`);
                    mediaRecorder.stop();
                }
                
                // Clear audio chunks to prevent accumulation
                audioChunks = [];
                console.log(`🧹 Cleared audioChunks array`);
            }
            
            updateVoiceStatus(`Voice Ready (${voiceRecognitionType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
        }

        // Removed old Realtime API functions - now using simple Whisper approach
        
        function processVoiceCommand(command) {
            const lowerCommand = command.toLowerCase();
            
            // Extract app creation requests
            if (lowerCommand.includes('create') || lowerCommand.includes('make') || lowerCommand.includes('build')) {
                // Remove command words and extract the app description
                let appRequest = command
                    .replace(/create|make|build|me|a|an/gi, '')
                    .replace(/app|application/gi, '')
                    .trim();
                
                if (appRequest) {
                    createApp(appRequest);
                    updateVoiceStatus(`Creating: ${appRequest}`, 'ready');
                }
            } else if (lowerCommand.includes('close all')) {
                closeAllApps();
                updateVoiceStatus('Closing all apps', 'ready');
            } else if (lowerCommand.includes('show apps') || lowerCommand.includes('app manager')) {
                showAppList();
                updateVoiceStatus('Opening App Manager', 'ready');
            } else {
                // Treat the entire command as an app request
                createApp(command);
                updateVoiceStatus(`Creating: ${command}`, 'ready');
            }
        }

        function updateVoiceStatus(text, state) {
            const voiceStatusElement = document.getElementById('voice-status');
            if (voiceStatusElement) {
                voiceStatusElement.textContent = text;
            }
            
            const voiceButton = document.getElementById('voice-button');
            if (voiceButton) {
                voiceButton.className = state;
            }
        }

        function showVoiceCommandPopup(command) {
            const popup = document.getElementById('voice-command-popup');
            if (!popup) return;
            
            // Set the command text
            popup.textContent = command;
            
            // Show the popup with fade-in
            popup.classList.add('show');
            
            // Fade out after 2 seconds
            setTimeout(() => {
                popup.classList.add('fade-out');
                
                // Remove classes after fade-out completes
                setTimeout(() => {
                    popup.classList.remove('show', 'fade-out');
                }, 500);
            }, 2000);
        }

        // Global variable to track which app is being modified
        let currentModifyingAppId = null;

        function startAppVoiceCommand(appId) {
            console.log(`🎤 Starting voice command for app: ${appId}`);
            console.log(`🔍 Current isListening state: ${isListening}`);
            console.log(`🔍 Current mediaStream:`, mediaStream);
            console.log(`🔍 Current mediaRecorder:`, mediaRecorder);
            
            // Set the app being modified
            currentModifyingAppId = appId;
            console.log(`✅ Set currentModifyingAppId to: ${currentModifyingAppId}`);
            
            // Visual feedback - make the voice button red and pulsing
            const voiceButton = document.querySelector(`#window_${appId} .window-voice-button`);
            if (voiceButton) {
                voiceButton.classList.add('recording');
                console.log(`✅ Added 'recording' class to voice button for app ${appId}`);
            } else {
                console.error(`❌ Could not find voice button for app ${appId}`);
            }
            
            // Handle voice session for app modification
            if (isListening) {
                console.log(`🔄 Already listening - stopping current session and starting app-specific session`);
                // Stop current session and start new one for app
                stopVoiceSession();
                // Wait a moment then start new session
                setTimeout(() => {
                    console.log(`🎙️ Starting new voice session for app ${appId}...`);
                    startVoiceSession();
                }, 100);
            } else {
                console.log(`🎙️ Starting new voice session for app modification...`);
                try {
                    startVoiceSession();
                    console.log(`✅ startVoiceSession() called successfully`);
                } catch (error) {
                    console.error(`❌ Error calling startVoiceSession():`, error);
                }
            }
            
            // Update voice status to show app-specific recording
            updateVoiceStatus(`Recording for ${appId}`, 'listening');
        }

        function stopAppVoiceCommand(appId) {
            console.log(`🛑 Stopping voice command for app: ${appId}`);
            
            // Stop the voice session
            stopVoiceSession();
            
            // Reset the voice button appearance
            const voiceButton = document.querySelector(`#window_${appId} .window-voice-button`);
            if (voiceButton) {
                voiceButton.classList.remove('recording');
                console.log(`✅ Removed 'recording' class from voice button for app ${appId}`);
            }
            
            // DON'T clear currentModifyingAppId here - let transcribeAudio() handle it
            // The transcription process needs currentModifyingAppId to know which app to modify
            console.log(`✅ Keeping currentModifyingAppId (${currentModifyingAppId}) for transcription processing`);
        }

        function showTextPromptDialog(appId) {
            const app = apps.find(a => a.id === appId);
            if (!app) {
                alert('App not found!');
                return;
            }

            // Get the app window element to position the dialog relative to it
            const appWindow = document.getElementById(`window_${appId}`);
            if (!appWindow) {
                alert('App window not found!');
                return;
            }

            // Create the modal overlay
            const overlay = document.createElement('div');
            overlay.className = 'text-prompt-overlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(2px);
            `;

            // Create the dialog box
            const dialog = document.createElement('div');
            dialog.className = 'text-prompt-dialog';
            dialog.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 24px;
                max-width: 90%;
                width: 400px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;

            // Apply theme to dialog
            if (document.body.classList.contains('dark-theme')) {
                dialog.style.background = '#2c3e50';
                dialog.style.color = '#f8f9fa';
            }

            dialog.innerHTML = `
                <div style="margin-bottom: 16px;">
                    <h3 style="margin: 0 0 8px 0; color: ${document.body.classList.contains('dark-theme') ? '#f8f9fa' : '#333'}; font-size: 18px;">✏️ Edit App</h3>
                    <p style="margin: 0; color: ${document.body.classList.contains('dark-theme') ? '#e9ecef' : '#666'}; font-size: 14px;">Enter modification instructions for "${app.title}". You can also paste screenshots (Ctrl+V):</p>
                </div>
                <div style="margin-bottom: 20px;">
                    <textarea
                        id="text-prompt-input-${appId}"
                        placeholder="Add a new feature or modify the existing functionality... You can also paste screenshots here with Ctrl+V"
                        style="
                            width: 100%;
                            height: 120px;
                            padding: 12px;
                            border: 2px solid ${document.body.classList.contains('dark-theme') ? '#6c757d' : '#ddd'};
                            border-radius: 6px;
                            font-size: 14px;
                            font-family: inherit;
                            resize: vertical;
                            background: ${document.body.classList.contains('dark-theme') ? '#495057' : '#ffffff'};
                            color: ${document.body.classList.contains('dark-theme') ? '#f8f9fa' : '#333'};
                        "
                    ></textarea>
                    <div id="pasted-images-${appId}" style="margin-top: 10px; display: none;">
                        <div style="font-size: 12px; color: ${document.body.classList.contains('dark-theme') ? '#e9ecef' : '#666'}; margin-bottom: 8px;">📷 Pasted Images:</div>
                        <div id="image-preview-container-${appId}" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button
                        id="text-prompt-cancel-${appId}"
                        style="
                            background: #6c757d;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: 500;
                            transition: background 0.2s ease;
                        "
                    >Cancel</button>
                    <button
                        id="text-prompt-submit-${appId}"
                        style="
                            background: #0078d4;
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                            font-weight: 500;
                            transition: background 0.2s ease;
                        "
                    >Apply Changes</button>
                </div>
            `;

            overlay.appendChild(dialog);
            appWindow.appendChild(overlay);

            // Focus the textarea
            const textarea = document.getElementById(`text-prompt-input-${appId}`);
            setTimeout(() => {
                textarea.focus();
                textarea.select();
            }, 100);

            // Store pasted images for this dialog
            let pastedImages = [];

            // Add paste event listener for image support
            textarea.addEventListener('paste', async (e) => {
                const items = e.clipboardData.items;
                
                for (let item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        e.preventDefault();
                        
                        const file = item.getAsFile();
                        if (file) {
                            try {
                                // Convert image to base64
                                const base64 = await fileToBase64(file);
                                
                                // Add to pasted images array
                                const imageData = {
                                    base64: base64,
                                    type: file.type,
                                    name: `pasted-image-${Date.now()}.${file.type.split('/')[1]}`
                                };
                                pastedImages.push(imageData);
                                
                                // Show image preview
                                showImagePreview(appId, imageData, pastedImages.length - 1);
                                
                                // Show the pasted images container
                                const pastedImagesContainer = document.getElementById(`pasted-images-${appId}`);
                                if (pastedImagesContainer) {
                                    pastedImagesContainer.style.display = 'block';
                                }
                                
                                console.log('Image pasted successfully:', imageData.name);
                            } catch (error) {
                                console.error('Error processing pasted image:', error);
                                alert('Error processing pasted image. Please try again.');
                            }
                        }
                    }
                }
            });

            // Helper function to convert file to base64
            function fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            // Helper function to show image preview
            function showImagePreview(appId, imageData, index) {
                const container = document.getElementById(`image-preview-container-${appId}`);
                if (!container) return;

                const previewDiv = document.createElement('div');
                previewDiv.style.cssText = `
                    position: relative;
                    display: inline-block;
                    border: 1px solid ${document.body.classList.contains('dark-theme') ? '#6c757d' : '#ddd'};
                    border-radius: 4px;
                    overflow: hidden;
                `;

                const img = document.createElement('img');
                img.src = imageData.base64;
                img.style.cssText = `
                    width: 80px;
                    height: 80px;
                    object-fit: cover;
                    display: block;
                `;

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '×';
                removeBtn.style.cssText = `
                    position: absolute;
                    top: 2px;
                    right: 2px;
                    width: 20px;
                    height: 20px;
                    background: rgba(220, 53, 69, 0.8);
                    color: white;
                    border: none;
                    border-radius: 50%;
                    cursor: pointer;
                    font-size: 12px;
                    line-height: 1;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                removeBtn.addEventListener('click', () => {
                    // Remove from array
                    pastedImages.splice(index, 1);
                    // Remove preview
                    previewDiv.remove();
                    // Hide container if no images left
                    if (pastedImages.length === 0) {
                        const pastedImagesContainer = document.getElementById(`pasted-images-${appId}`);
                        if (pastedImagesContainer) {
                            pastedImagesContainer.style.display = 'none';
                        }
                    }
                });

                previewDiv.appendChild(img);
                previewDiv.appendChild(removeBtn);
                container.appendChild(previewDiv);
            }

            // Handle button clicks
            const cancelBtn = document.getElementById(`text-prompt-cancel-${appId}`);
            const submitBtn = document.getElementById(`text-prompt-submit-${appId}`);

            function closeDialog() {
                overlay.remove();
            }

            cancelBtn.addEventListener('click', closeDialog);

            submitBtn.addEventListener('click', () => {
                const promptText = textarea.value.trim();
                if (promptText || pastedImages.length > 0) {
                    console.log(`Text modification request for app ${appId}: ${promptText}`);
                    console.log(`Pasted images count: ${pastedImages.length}`);
                    
                    // Create modification request with images
                    const modificationData = {
                        text: promptText,
                        images: pastedImages
                    };
                    
                    modifyAppWithImages(appId, modificationData);
                    closeDialog();
                } else {
                    textarea.focus();
                    textarea.style.borderColor = '#dc3545';
                    setTimeout(() => {
                        textarea.style.borderColor = document.body.classList.contains('dark-theme') ? '#6c757d' : '#ddd';
                    }, 2000);
                }
            });

            // Handle Enter key (Ctrl+Enter to submit)
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    submitBtn.click();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeDialog();
                }
            });

            // Close on overlay click (but not dialog click)
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeDialog();
                }
            });

            // Add hover effects to buttons
            cancelBtn.addEventListener('mouseenter', () => {
                cancelBtn.style.background = '#5a6268';
            });
            cancelBtn.addEventListener('mouseleave', () => {
                cancelBtn.style.background = '#6c757d';
            });

            submitBtn.addEventListener('mouseenter', () => {
                submitBtn.style.background = '#106ebe';
            });
            submitBtn.addEventListener('mouseleave', () => {
                submitBtn.style.background = '#0078d4';
            });
        }

        function closeWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const icon = document.getElementById(`icon_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (app && app.isSystemApp) {
                // For system apps, hide instead of remove
                if (window) {
                    window.style.display = 'none';
                    app.isHidden = true;
                }
                if (icon) {
                    icon.style.display = 'none';
                }
                console.log(`System app ${appId} hidden`);
            } else {
                // For user apps, remove completely and clean up namespace
                if (window) window.remove();
                if (icon) icon.remove();
                
                // Clean up app-specific resources
                cleanupAppNamespace(appId);
                
                apps = apps.filter(app => app.id !== appId);
                console.log(`User app ${appId} removed and namespace cleaned`);
            }
            
            updateAppCount();
        }

        function cleanupAppNamespace(appId) {
            try {
                // Remove app-specific CSS
                const styleElement = document.getElementById(`style-${appId}`);
                if (styleElement) {
                    styleElement.remove();
                }
                
                // Remove app-specific JavaScript storage
                const scriptElement = document.getElementById(`script-${appId}`);
                if (scriptElement) {
                    scriptElement.remove();
                }
                
                // Clean up app namespace from window object
                const namespace = `app_${appId.replace(/-/g, '_')}`;
                if (window[namespace]) {
                    delete window[namespace];
                }
                
                // Remove app-specific event listeners
                const events = document._appEventListeners || {};
                Object.keys(events).forEach(eventName => {
                    if (eventName.startsWith(`${appId}:`)) {
                        delete events[eventName];
                    }
                });
                
                console.log(`Cleaned up namespace for app ${appId}`);
            } catch (error) {
                console.warn(`Error cleaning up namespace for app ${appId}:`, error);
            }
        }

        function minimizeWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                window.classList.add('minimized');
                app.isMinimized = true;
                updateIconState(appId);
            }
        }

        function toggleMaximize(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                window.classList.toggle('maximized');
                app.isMaximized = !app.isMaximized;
                bringToFront(appId);
            }
        }

        function toggleWindow(appId) {
            const window = document.getElementById(`window_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (window && app) {
                if (app.isMinimized) {
                    window.classList.remove('minimized');
                    app.isMinimized = false;
                    bringToFront(appId);
                } else {
                    minimizeWindow(appId);
                }
                updateIconState(appId);
            }
        }

        function updateIconState(appId) {
            const icon = document.getElementById(`icon_${appId}`);
            const app = apps.find(a => a.id === appId);
            
            if (icon && app) {
                icon.classList.toggle('active', !app.isMinimized);
            }
        }

        function bringToFront(appId) {
            const window = document.getElementById(`window_${appId}`);
            if (window) {
                const maxZ = Math.max(...Array.from(document.querySelectorAll('.window')).map(w => parseInt(w.style.zIndex) || 0));
                window.style.zIndex = maxZ + 1;
                activeWindow = appId;
            }
        }

        function startDrag(event, appId) {
            event.preventDefault();
            const window = document.getElementById(`window_${appId}`);
            if (window.classList.contains('maximized')) return;
            
            bringToFront(appId);
            
            // Handle both mouse and touch events
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            
            dragData = {
                appId: appId,
                startX: clientX,
                startY: clientY,
                startLeft: parseInt(window.style.left),
                startTop: parseInt(window.style.top)
            };
            
            // Add both mouse and touch event listeners
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }

        function drag(event) {
            if (!dragData) return;
            event.preventDefault(); // Prevent scrolling on touch
            
            // Handle both mouse and touch events
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            
            const window = document.getElementById(`window_${dragData.appId}`);
            const deltaX = clientX - dragData.startX;
            const deltaY = clientY - dragData.startY;
            
            window.style.left = (dragData.startLeft + deltaX) + 'px';
            window.style.top = (dragData.startTop + deltaY) + 'px';
        }

        function stopDrag() {
            dragData = null;
            // Remove both mouse and touch event listeners
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', stopDrag);
        }

        function startResize(event, appId) {
            event.preventDefault();
            event.stopPropagation();
            
            const window = document.getElementById(`window_${appId}`);
            if (window.classList.contains('maximized')) return;
            
            bringToFront(appId);
            
            resizeData = {
                appId: appId,
                startX: event.clientX,
                startY: event.clientY,
                startWidth: parseInt(window.style.width),
                startHeight: parseInt(window.style.height)
            };
            
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', stopResize);
        }

        function resize(event) {
            if (!resizeData) return;
            
            const window = document.getElementById(`window_${resizeData.appId}`);
            const deltaX = event.clientX - resizeData.startX;
            const deltaY = event.clientY - resizeData.startY;
            
            const newWidth = Math.max(300, resizeData.startWidth + deltaX);
            const newHeight = Math.max(200, resizeData.startHeight + deltaY);
            
            window.style.width = newWidth + 'px';
            window.style.height = newHeight + 'px';
        }

        function stopResize() {
            resizeData = null;
            document.removeEventListener('mousemove', resize);
            document.removeEventListener('mouseup', stopResize);
        }

        function showAppList() {
            const appListContent = `
                <h3>App Manager</h3>
                <div style="margin-bottom: 15px;">
                    <button id="load-app-btn" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 10px;">📁 Load App</button>
                    <input type="file" id="app-file-input" accept=".json" style="display: none;">
                </div>
                <div style="max-height: 300px; overflow-y: auto;">
                    ${apps.map(app => `
                        <div style="padding: 10px; border: 1px solid #ddd; margin: 5px 0; border-radius: 4px;">
                            <strong>ID:</strong> ${app.id}<br>
                            <strong>Title:</strong> ${app.title}<br>
                            <strong>Type:</strong> ${app.type}<br>
                            ${app.customRequest ? `<strong>Request:</strong> ${app.customRequest}<br>` : ''}
                            <strong>Status:</strong> ${app.isMinimized ? 'Minimized' : 'Active'}
                            <div style="margin-top: 8px;">
                                <button onclick="downloadApp('${app.id}')" style="background: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-right: 5px; font-size: 12px;">💾 Download</button>
                                <button onclick="closeWindow('${app.id}')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">❌ Close</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Total apps: ${apps.length} | Next ID: app_${nextAppId}
                </p>
            `;
            
            // Create App Manager directly without AI generation
            const managerId = generateAppId();
            const managerApp = {
                id: managerId,
                type: 'system',
                title: 'App Manager',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System App Manager'
            };

            apps.push(managerApp);
            createWindow(managerId, 'App Manager', appListContent);
            createTaskbarIcon(managerId, 'App Manager');
            updateAppCount();
            
            const contentElement = document.getElementById(`content_${managerId}`);
            
            // Add event listeners for the new buttons
            setTimeout(() => {
                const loadBtn = document.getElementById('load-app-btn');
                const fileInput = document.getElementById('app-file-input');
                
                if (loadBtn && fileInput) {
                    loadBtn.addEventListener('click', () => {
                        fileInput.click();
                    });
                    
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            loadAppFromFile(file);
                        }
                    });
                }
            }, 100);
            
            document.getElementById('start-menu').classList.remove('show');
        }

        function closeAllApps() {
            if (confirm('Close all applications?')) {
                [...apps].forEach(app => closeWindow(app.id));
            }
            document.getElementById('start-menu').classList.remove('show');
        }

        function downloadApp(appId) {
            const app = apps.find(a => a.id === appId);
            if (!app) {
                alert('App not found!');
                return;
            }

            // Get the current app content
            const contentElement = document.getElementById(`content_${appId}`);
            const currentHTML = contentElement ? contentElement.innerHTML : '';
            
            // Get the current CSS for this app
            const styleElement = document.getElementById(`style-${appId}`);
            const currentCSS = styleElement ? styleElement.textContent : '';
            
            // Get the current JavaScript for this app (if any)
            const scriptElement = document.getElementById(`script-${appId}`);
            const currentJavaScript = scriptElement ? scriptElement.textContent : '';

            // Create app data object
            const appData = {
                id: app.id,
                title: app.title,
                type: app.type,
                customRequest: app.customRequest,
                html: currentHTML,
                css: currentCSS,
                javascript: currentJavaScript,
                isMinimized: app.isMinimized,
                isMaximized: app.isMaximized,
                modificationHistory: app.modificationHistory || [],
                lastModification: app.lastModification || null,
                promptHistory: app.promptHistory || [],
                exportDate: new Date().toISOString(),
                version: '1.1'
            };

            // Create and download the file
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `${app.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${app.id}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log(`Downloaded app: ${app.title} (${app.id})`);
        }

        function loadAppFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const appData = JSON.parse(e.target.result);
                    
                    // Validate the app data structure
                    if (!appData.title || !appData.html) {
                        throw new Error('Invalid app file format - missing required fields');
                    }
                    
                    // Generate a new app ID to avoid conflicts
                    const newAppId = generateAppId();
                    
                    // Create the app object
                    const newApp = {
                        id: newAppId,
                        type: appData.type || 'imported',
                        title: appData.title,
                        isMinimized: false,
                        isMaximized: false,
                        customRequest: appData.customRequest || 'Imported app',
                        promptHistory: appData.promptHistory || []
                    };
                    
                    // Add to apps array
                    apps.push(newApp);
                    
                    // Create the window with the imported content
                    createWindow(newAppId, appData.title, appData.html);
                    createTaskbarIcon(newAppId, appData.title);
                    
                    // Add CSS if present
                    if (appData.css) {
                        addAppCSS(appData.css, newAppId);
                    }
                    
                    updateAppCount();
                    
                    // Execute JavaScript and auto-size after content is fully rendered
                    setTimeout(() => {
                        // Execute JavaScript if present
                        if (appData.javascript) {
                            executeAppJavaScript(appData.javascript, newAppId);
                        }
                        
                        // Auto-size and center the window based on content
                        autoSizeAndCenterWindow(newAppId);
                    }, 200);
                    
                    console.log(`Loaded app: ${appData.title} as ${newAppId}`);
                    
                } catch (error) {
                    console.error('Failed to load app:', error);
                    alert(`Failed to load app: ${error.message}`);
                }
            };
            
            reader.onerror = function() {
                alert('Failed to read the file');
            };
            
            reader.readAsText(file);
        }

        function triggerLoadApp() {
            // Create a hidden file input and trigger it
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            fileInput.style.display = 'none';
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadAppFromFile(file);
                }
                // Clean up
                document.body.removeChild(fileInput);
            });
            
            document.body.appendChild(fileInput);
            fileInput.click();
            
            // Close the start menu
            document.getElementById('start-menu').classList.remove('show');
        }

        // System Apps Definition Dictionary
        const SYSTEM_APPS_DEFINITIONS = {

            'Calculator': {
                generationMode: 'SIMPLE',
                icon: '🧮',
                prompt: `Create a fully functional Calculator app with a professional interface and specific design requirements.

EXACT LAYOUT REQUIREMENTS:
- Display screen at the top: large, dark background, white text, right-aligned numbers
- Row 1: Clear (C), Plus/Minus (±), Percentage (%), Division (÷)
- Row 2: Seven (7), Eight (8), Nine (9), Multiplication (×)
- Row 3: Four (4), Five (5), Six (6), Subtraction (-)
- Row 4: One (1), Two (2), Three (3), Addition (+)
- Row 5: Zero (0) spans 2 columns, Decimal (.), Equals (=)
- Center all content in the window

BUTTON SIZING AND SPACING:
- All buttons uniform size: exactly 60px × 60px

VISUAL DESIGN DETAILS:
- Clean, modern calculator appearance
- Subtle shadow effects on buttons for depth
- Hover effects: slight brightness change when hovering over buttons
- Active/pressed state: slightly darker version of button color
- Professional typography with clear, readable fonts
- Responsive design that scales well within the window
- MANDATORY: column spacing between buttons: 5px max
- Button colors:
  - number buttons are grey (#28a745) with white text
  - function buttons (C, ±, %, ÷, ×, -, +) are blue (#007bff) with white text
  - equal button (=) is green (#fd7e14) with white text
  - clear button (C) is red (#dc3545) with white text

FUNCTIONALITY REQUIREMENTS:
- All basic arithmetic operations working correctly
- Clear function resets calculator to zero
- Decimal point support for floating point calculations
- Plus/minus toggle changes sign of current displayed number
- Percentage calculations work properly
- Proper order of operations and chaining calculations
- Error handling for division by zero shows "Error"
- Display updates immediately when any button is pressed
- Keyboard support for number keys and basic operators
- MANDATORY: show the selected operation in the display

TECHNICAL IMPLEMENTATION:
- Maintain proper calculator state between operations
- Handle edge cases like multiple operators, leading zeros, decimal points
- Ensure calculator behaves exactly like a standard calculator

The calculator must be immediately functional with the exact color scheme and layout specified.`
            },

            'Digital Clock': {
                generationMode: 'SIMPLE',
                icon: '🕐',
                prompt: `Create a simple but functional Digital Clock that displays the current time and updates every second.

ESSENTIAL REQUIREMENTS:
- Create a working digital clock that shows the current time
- Update the display every second automatically
- Show hours, minutes, and seconds in HH:MM:SS format
- Use 12-hour format with AM/PM indicator
- add a switch to switch between 12-hour (hh:mm:ss AM/PM) and 24-hour formats (HH:mm:ss)
- the 12/24h switch must move when clicked not just toggle the format
- Center the clock display in the window
- Use a large, readable font for the time display
- Include the current date below the time
- Make it visually appealing with proper theme support

FUNCTIONALITY:
- Automatically start when the app opens
- Update every second without user interaction
- Show accurate current time
- Display current date in a readable format
- Handle time changes correctly (including midnight transitions)

The clock should be immediately functional and start displaying the current time as soon as the app loads.`
            },

            'Cost Tracking': {
                generationMode: 'SIMPLE',
                icon: '💰',
                prompt: `Create a Cost Tracking app that displays API usage costs. The app must access the global 'costHistory' array which contains cost entries with the following structure:
            
            costHistory = [
                {
                    timestamp: "2024-01-01T12:00:00.000Z",
                    cost: 0.0025,
                    description: "App Creation Request",
                    prompt: "Create a calculator app..."
                }
            ]

            SPECIFIC REQUIREMENTS:
            1. Title: "💰 Cost Tracking"
            2. Display total cost at the top in a highlighted summary box
            3. Show number of API calls made
            4. Display cost history in a table with columns: Date/Time, Cost, Description, Prompt
            5. Sort entries by newest first (reverse chronological order)
            6. Include a "Clear History" button that calls clearCostHistory() function
            7. Include a "Load Costs" button that refreshes the data from the global costHistory
            8. Handle empty history with a "No cost entries recorded yet" message
            9. Use proper currency formatting ($X.XXXX)
            10. Make the table scrollable if there are many entries
            11. Truncate long prompts to fit in the table (max 100 characters)

            STYLING REQUIREMENTS WITH THEME SUPPORT:
            LIGHT MODE (.app-light-theme):
            - Background: #ffffff (white) or #f8f9fa (light gray)
            - Summary box: #e3f2fd (light blue) background with #0d47a1 (dark blue) text
            - Table headers: #f8f9fa background with #212529 text
            - Table rows: Alternating #ffffff and #f8f9fa backgrounds with #212529 text
            - Cost values: #dc3545 (red) text for emphasis
            - Buttons: #007bff (blue) background with #ffffff text
            - Borders: #dee2e6 (light gray) for table and containers

            DARK MODE (.app-dark-theme):
            - Background: #2c3e50 (dark blue) or #34495e (medium dark)
            - Summary box: #1e3a5f (dark blue) background with #66b3ff (light blue) text
            - Table headers: #495057 background with #f8f9fa text
            - Table rows: Alternating #3a4a5c and #495057 backgrounds with #f8f9fa text
            - Cost values: #ff6b6b (light red) text for emphasis
            - Buttons: #0d6efd (blue) background with #ffffff text
            - Borders: #6c757d (gray) for table and containers

            CRITICAL CONTRAST REQUIREMENTS:
            - Use CSS theme classes: .app-light-theme and .app-dark-theme for all styling
            - Ensure minimum 4.5:1 contrast ratio between text and background
            - Cost values must be clearly visible in both themes
            - Button text must be white (#ffffff) on colored button backgrounds
            - Table text must have high contrast against row backgrounds
            - Use proper spacing and padding for readability
            - Responsive design that works in 400-600px windows

            TECHNICAL REQUIREMENTS:
            - CRITICAL: Access costHistory using window.costHistory (this is the global array with all cost data)
            - ALWAYS use: const costs = window.costHistory || []; to safely access the data
            - Calculate total cost: const total = costs.reduce((sum, entry) => sum + entry.cost, 0);
            - Format dates using new Date(entry.timestamp).toLocaleDateString() and toLocaleTimeString()
            - Clear History button MUST call: window.clearCostHistory()
            - Load Costs button MUST call your local loadCostData() function
            - MANDATORY: Create loadCostData() function that refreshes display from window.costHistory
            - MANDATORY: Call loadCostData() immediately when app loads AND when 'appShown' event fires
            - MANDATORY: Listen for 'appShown' event: document.addEventListener('appShown', loadCostData);
            - Handle empty data gracefully with "No cost entries recorded yet" message
            - DEBUGGING: Add console.log('Loading cost data:', window.costHistory); in loadCostData()

            APP VISIBILITY EVENT:
            - The system will dispatch a custom 'appShown' event when the app becomes visible
            - Listen for this event: document.addEventListener('appShown', function(event) { if(event.detail.appId === 'your-app-id') loadCostData(); });
            - This allows the app to refresh its data when reopened from hidden state
            - Always refresh cost data when this event is received

            EXAMPLE STRUCTURE:
            - Summary section with total cost and call count
            - Button row with "Load Costs" and "Clear History" buttons
            - Scrollable table with cost entries
            - Proper error handling for missing or invalid data

            EXAMPLE CODE SNIPPET:
            function loadCostData() {
                console.log('Loading cost data:', window.costHistory);
                const costs = window.costHistory || [];
                const total = costs.reduce((sum, entry) => sum + entry.cost, 0);
                
                console.log('Found', costs.length, 'cost entries, total:', total);
                
                // Update summary
                const totalElement = document.getElementById('total-cost');
                const countElement = document.getElementById('call-count');
                if (totalElement) totalElement.textContent = '$' + total.toFixed(4);
                if (countElement) countElement.textContent = costs.length;
                
                // Update table
                const tbody = document.getElementById('cost-table-body');
                if (tbody) {
                    tbody.innerHTML = '';
                    if (costs.length === 0) {
                        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px;">No cost entries recorded yet.</td></tr>';
                    } else {
                        costs.slice().reverse().forEach(entry => {
                            const row = tbody.insertRow();
                            const date = new Date(entry.timestamp);
                            row.innerHTML = '<td>' + date.toLocaleDateString() + ' ' + date.toLocaleTimeString() + '</td><td style="color: #dc3545; font-weight: bold;">$' + entry.cost.toFixed(4) + '</td><td>' + entry.description + '</td><td>' + (entry.prompt || 'N/A').substring(0, 100) + '</td>';
                        });
                    }
                }
            }
            
            // MANDATORY: Call loadCostData when app loads and on appShown event
            loadCostData();
            document.addEventListener('appShown', function(event) {
                console.log('App shown event received for:', event.detail.appId);
                loadCostData();
            });`
            }
        };

        // Configuration for LLM integration
        const CONFIG = {
            OPENAI_API_KEY: 'sk-proj-...', // Replace with your actual OpenAI API key
            OPENROUTER_API_KEY: 'sk-...', // Replace with your actual OpenRouter API key
            OPENROUTER_URL: 'https://openrouter.ai/api/v1/chat/completions',
            MODEL_SIMPLE: 'google/gemini-2.5-flash-lite-preview-06-17',
            MODEL_TOUGH: 'anthropic/claude-sonnet-4',
            MODEL: 'google/gemini-2.5-flash-lite-preview-06-17', // Will be updated based on mode selection
            CURRENT_LLM_PROVIDER: 'openrouter' // Current LLM provider: 'openrouter', 'openai', or 'lmstudio'
        };

        // Model selection state
        let currentModelMode = 'Simple'; // Default to Simple mode
        let previousModelMode = 'Simple'; // Store previous mode for restoration

        // Global voice recognition settings
        let voiceRecognitionType = 'whisper'; // 'whisper' or 'web'
        
        // Global voice state for Whisper API
        let mediaRecorder = null;
        let audioChunks = [];
        let mediaStream = null;
        
        // Global voice state for Web Speech API
        let webSpeechRecognition = null;
        let isWebSpeechSupported = false;

        // Global cost tracking
        let costTrackingEnabled = true;
        let costHistory = [];
        
        // Make costHistory globally accessible for generated apps
        window.costHistory = costHistory;

        // Global debug mode
        let debugMode = false;

        // Debug logging function
        function debugLog(...args) {
            if (debugMode) {
                console.log(...args);
            }
        }

        // Debug warn function
        function debugWarn(...args) {
            if (debugMode) {
                console.warn(...args);
            }
        }

        // Debug error function
        function debugError(...args) {
            if (debugMode) {
                console.error(...args);
            }
        }

        // Setup Assistant Functions
        function startSetupAssistant() {
            const setupContent = `
                <div class="setup-assistant">
                    <div class="setup-header">
                        <h2>🚀 Welcome to Self-Evolving OS</h2>
                        <p>Let's set up your AI-powered operating system in just a few steps.</p>
                        <div class="setup-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="setup-progress-fill"></div>
                            </div>
                            <span class="progress-text" id="setup-progress-text">Step 1 of 4</span>
                        </div>
                    </div>
                    
                    <div class="setup-content" id="setup-content">
                        <!-- Step content will be dynamically loaded here -->
                    </div>
                    
                    <div class="setup-footer">
                        <button class="setup-btn secondary" id="setup-back" style="display: none;">← Back</button>
                        <div class="setup-footer-right">
                            <button class="setup-btn secondary" id="setup-skip">Skip Setup</button>
                            <button class="setup-btn primary" id="setup-next">Next →</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Create Setup Assistant app
            const setupId = generateAppId();
            const setupApp = {
                id: setupId,
                type: 'system',
                title: 'Setup Assistant',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System Setup Assistant'
            };

            apps.push(setupApp);
            createWindow(setupId, 'Setup Assistant', setupContent, 600, 500);
            createTaskbarIcon(setupId, 'Setup Assistant');
            updateAppCount();
            
            // Add setup-specific CSS
            addSetupAssistantCSS(setupId);
            
            // Initialize setup assistant
            setTimeout(() => {
                initializeSetupAssistant(setupId);
            }, 100);
        }

        function addSetupAssistantCSS(appId) {
            const setupCSS = `
                .setup-assistant {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                }
                
                .setup-header {
                    padding: 30px 30px 20px 30px;
                    text-align: center;
                    background: white;
                    border-bottom: 1px solid #dee2e6;
                }
                
                .setup-header h2 {
                    margin: 0 0 10px 0;
                    color: #0078d4;
                    font-size: 24px;
                    font-weight: 600;
                }
                
                .setup-header p {
                    margin: 0 0 20px 0;
                    color: #6c757d;
                    font-size: 16px;
                }
                
                .setup-progress {
                    display: flex;
                    align-items: center;
                    gap: 15px;
                }
                
                .progress-bar {
                    flex: 1;
                    height: 8px;
                    background: #e9ecef;
                    border-radius: 4px;
                    overflow: hidden;
                }
                
                .progress-fill {
                    height: 100%;
                    background: linear-gradient(90deg, #0078d4, #106ebe);
                    border-radius: 4px;
                    transition: width 0.3s ease;
                    width: 25%;
                }
                
                .progress-text {
                    font-size: 14px;
                    color: #6c757d;
                    font-weight: 500;
                    min-width: 80px;
                }
                
                .setup-content {
                    flex: 1;
                    padding: 30px;
                    overflow-y: auto;
                }
                
                .setup-step {
                    max-width: 500px;
                    margin: 0 auto;
                }
                
                .setup-step h3 {
                    margin: 0 0 20px 0;
                    color: #333;
                    font-size: 20px;
                    font-weight: 600;
                }
                
                .setup-step p {
                    margin: 0 0 20px 0;
                    color: #6c757d;
                    line-height: 1.6;
                }
                
                .setup-form-group {
                    margin-bottom: 20px;
                }
                
                .setup-form-group label {
                    display: block;
                    margin-bottom: 8px;
                    color: #333;
                    font-weight: 500;
                }
                
                .setup-form-group input,
                .setup-form-group select {
                    width: 100%;
                    padding: 12px;
                    border: 2px solid #e9ecef;
                    border-radius: 6px;
                    font-size: 14px;
                    transition: border-color 0.2s ease;
                }
                
                .setup-form-group input:focus,
                .setup-form-group select:focus {
                    outline: none;
                    border-color: #0078d4;
                }
                
                .setup-form-group .help-text {
                    margin-top: 5px;
                    font-size: 12px;
                    color: #6c757d;
                }
                
                .setup-option-card {
                    border: 2px solid #e9ecef;
                    border-radius: 8px;
                    padding: 20px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
                
                .setup-option-card:hover {
                    border-color: #0078d4;
                    background: #f8f9ff;
                }
                
                .setup-option-card.selected {
                    border-color: #0078d4;
                    background: #e3f2fd;
                }
                
                .setup-option-card h4 {
                    margin: 0 0 8px 0;
                    color: #333;
                    font-size: 16px;
                    font-weight: 600;
                }
                
                .setup-option-card p {
                    margin: 0;
                    color: #6c757d;
                    font-size: 14px;
                }
                
                .setup-test-result {
                    margin-top: 15px;
                    padding: 15px;
                    border-radius: 6px;
                    font-size: 14px;
                }
                
                .setup-test-result.success {
                    background: #d4edda;
                    color: #155724;
                    border: 1px solid #c3e6cb;
                }
                
                .setup-test-result.error {
                    background: #f8d7da;
                    color: #721c24;
                    border: 1px solid #f5c6cb;
                }
                
                .setup-test-result.warning {
                    background: #fff3cd;
                    color: #856404;
                    border: 1px solid #ffeaa7;
                }
                
                .setup-footer {
                    padding: 20px 30px;
                    background: white;
                    border-top: 1px solid #dee2e6;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                
                .setup-footer-right {
                    display: flex;
                    gap: 10px;
                }
                
                .setup-btn {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 6px;
                    font-size: 14px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.2s ease;
                }
                
                .setup-btn.primary {
                    background: #0078d4;
                    color: white;
                }
                
                .setup-btn.primary:hover {
                    background: #106ebe;
                }
                
                .setup-btn.secondary {
                    background: #6c757d;
                    color: white;
                }
                
                .setup-btn.secondary:hover {
                    background: #5a6268;
                }
                
                .setup-btn:disabled {
                    opacity: 0.6;
                    cursor: not-allowed;
                }
            `;
            
            addAppCSS(setupCSS, appId);
        }

        function initializeSetupAssistant(setupId) {
            let currentStep = 1;
            const totalSteps = 4;
            
            const steps = {
                1: createWelcomeStep,
                2: createAIModelStep,
                3: createVoiceAudioStep,
                4: createCompletionStep
            };
            
            function updateProgress() {
                const progressFill = document.getElementById('setup-progress-fill');
                const progressText = document.getElementById('setup-progress-text');
                
                if (progressFill) {
                    progressFill.style.width = `${(currentStep / totalSteps) * 100}%`;
                }
                if (progressText) {
                    progressText.textContent = `Step ${currentStep} of ${totalSteps}`;
                }
            }
            
            function showStep(stepNumber) {
                const content = document.getElementById('setup-content');
                const backBtn = document.getElementById('setup-back');
                const nextBtn = document.getElementById('setup-next');
                const skipBtn = document.getElementById('setup-skip');
                
                if (content && steps[stepNumber]) {
                    content.innerHTML = steps[stepNumber]();
                }
                
                // Update button visibility
                if (backBtn) {
                    backBtn.style.display = stepNumber > 1 ? 'block' : 'none';
                }
                
                if (nextBtn) {
                    nextBtn.textContent = stepNumber === totalSteps ? 'Finish' : 'Next →';
                }
                
                if (skipBtn) {
                    skipBtn.style.display = stepNumber === totalSteps ? 'none' : 'block';
                }
                
                updateProgress();
                
                // Add step-specific event listeners
                setTimeout(() => {
                    addStepEventListeners(stepNumber);
                }, 100);
            }
            
            function addStepEventListeners(stepNumber) {
                if (stepNumber === 2) {
                    // AI Model step listeners
                    const providerCards = document.querySelectorAll('.setup-option-card[data-provider]');
                    providerCards.forEach(card => {
                        card.addEventListener('click', () => {
                            providerCards.forEach(c => c.classList.remove('selected'));
                            card.classList.add('selected');
                            
                            const provider = card.dataset.provider;
                            showProviderConfig(provider);
                        });
                    });
                    
                    const testBtn = document.getElementById('test-ai-connection');
                    if (testBtn) {
                        testBtn.addEventListener('click', testAIConnection);
                    }
                } else if (stepNumber === 3) {
                    // Voice & Audio step listeners
                    const voiceCards = document.querySelectorAll('.setup-option-card[data-voice]');
                    voiceCards.forEach(card => {
                        card.addEventListener('click', () => {
                            voiceCards.forEach(c => c.classList.remove('selected'));
                            card.classList.add('selected');
                            
                            const voiceType = card.dataset.voice;
                            showVoiceConfig(voiceType);
                        });
                    });
                    
                    const testMicBtn = document.getElementById('test-microphone-setup');
                    if (testMicBtn) {
                        testMicBtn.addEventListener('click', testMicrophone);
                    }
                    
                    const testVoiceBtn = document.getElementById('test-voice-recognition');
                    if (testVoiceBtn) {
                        testVoiceBtn.addEventListener('click', testVoiceRecognition);
                    }
                }
            }
            
            // Navigation event listeners
            const backBtn = document.getElementById('setup-back');
            const nextBtn = document.getElementById('setup-next');
            const skipBtn = document.getElementById('setup-skip');
            
            if (backBtn) {
                backBtn.addEventListener('click', () => {
                    if (currentStep > 1) {
                        currentStep--;
                        showStep(currentStep);
                    }
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (currentStep < totalSteps) {
                        if (validateCurrentStep(currentStep)) {
                            saveCurrentStepSettings(currentStep);
                            currentStep++;
                            showStep(currentStep);
                        }
                    } else {
                        // Finish setup
                        finishSetup(setupId);
                    }
                });
            }
            
            if (skipBtn) {
                skipBtn.addEventListener('click', () => {
                    if (confirm('Skip setup? You can configure these settings later in the Settings app.')) {
                        finishSetup(setupId);
                    }
                });
            }
            
            // Start with first step
            showStep(1);
        }

        function createWelcomeStep() {
            return `
                <div class="setup-step">
                    <h3>🎉 Welcome to Self-Evolving OS</h3>
                    <p>This AI-powered operating system can create and modify applications using natural language commands. Let's configure it for your needs.</p>
                    
                    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="margin: 0 0 15px 0; color: #0078d4;">✨ What you can do:</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #6c757d;">
                            <li>Create apps by voice: "Create a calculator app"</li>
                            <li>Modify existing apps: "Add a dark mode to this app"</li>
                            <li>Use text commands in the Start menu</li>
                            <li>Download and share your created apps</li>
                        </ul>
                    </div>
                    
                    <div style="background: #fff3cd; padding: 15px; border-radius: 6px; border: 1px solid #ffeaa7;">
                        <strong style="color: #856404;">📝 Note:</strong>
                        <span style="color: #856404;">You'll need API keys for AI services. Don't worry - we'll help you set this up!</span>
                    </div>
                </div>
            `;
        }

        function createAIModelStep() {
            return `
                <div class="setup-step">
                    <h3>🤖 AI Model Configuration</h3>
                    <p>Choose your AI provider for app generation. Each has different features and pricing.</p>
                    
                    <div class="setup-option-card" data-provider="openrouter">
                        <h4>🌐 OpenRouter (Recommended)</h4>
                        <p>Access to multiple AI models including Claude, GPT-4, and Gemini. Best balance of quality and cost.</p>
                    </div>
                    
                    <div class="setup-option-card" data-provider="openai">
                        <h4>🧠 OpenAI API</h4>
                        <p>Direct access to GPT models. Higher quality but more expensive.</p>
                    </div>
                    
                    <div class="setup-option-card" data-provider="lmstudio">
                        <h4>💻 LMStudio (Local)</h4>
                        <p>Run AI models locally on your computer. Free but requires powerful hardware.</p>
                    </div>
                    
                    <div id="provider-config" style="margin-top: 20px;">
                        <!-- Provider-specific configuration will appear here -->
                    </div>
                    
                    <button id="test-ai-connection" class="setup-btn secondary" style="margin-top: 15px;">🧪 Test Connection</button>
                    <div id="ai-test-result"></div>
                </div>
            `;
        }

        function createVoiceAudioStep() {
            return `
                <div class="setup-step">
                    <h3>🎤 Voice & Audio Setup</h3>
                    <p>Configure voice recognition for hands-free app creation and modification.</p>
                    
                    <div class="setup-option-card selected" data-voice="whisper">
                        <h4>🎯 OpenAI Whisper (Recommended)</h4>
                        <p>High-accuracy speech recognition supporting 50+ languages. Requires internet connection.</p>
                    </div>
                    
                    <div class="setup-option-card" data-voice="web">
                        <h4>🌐 Web Speech API</h4>
                        <p>Browser-based speech recognition. Free but limited language support and accuracy.</p>
                    </div>
                    
                    <div id="voice-config" style="margin-top: 20px;">
                        <!-- Voice-specific configuration will appear here -->
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button id="test-microphone-setup" class="setup-btn secondary">🎤 Test Microphone</button>
                        <button id="test-voice-recognition" class="setup-btn secondary">🗣️ Test Voice Recognition</button>
                    </div>
                    <div id="voice-test-result"></div>
                </div>
            `;
        }

        function createCompletionStep() {
            return `
                <div class="setup-step">
                    <h3>🎉 Setup Complete!</h3>
                    <p>Your Self-Evolving OS is ready to use. Here's what you can do next:</p>
                    
                    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h4 style="margin: 0 0 15px 0; color: #0078d4;">🚀 Quick Start:</h4>
                        <ol style="margin: 0; padding-left: 20px; color: #6c757d;">
                            <li>Click the microphone button and say "Create a calculator app"</li>
                            <li>Or use the Start menu to type your app request</li>
                            <li>Try modifying apps with the voice button in each window</li>
                            <li>Access Settings anytime from the Start menu</li>
                        </ol>
                    </div>
                    
                    <div style="background: #d4edda; padding: 15px; border-radius: 6px; border: 1px solid #c3e6cb;">
                        <strong style="color: #155724;">✅ Configuration Summary:</strong>
                        <div id="setup-summary" style="color: #155724; margin-top: 10px;">
                            <!-- Summary will be populated here -->
                        </div>
                    </div>
                </div>
            `;
        }

        function showProviderConfig(provider) {
            const configDiv = document.getElementById('provider-config');
            if (!configDiv) return;
            
            let configHTML = '';
            
            if (provider === 'openrouter') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-openrouter-key">OpenRouter API Key</label>
                        <input type="password" id="setup-openrouter-key" placeholder="sk-or-v1-...">
                        <div class="help-text">Get your API key from <a href="https://openrouter.ai/keys" target="_blank">openrouter.ai/keys</a></div>
                    </div>
                `;
            } else if (provider === 'openai') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-openai-key">OpenAI API Key</label>
                        <input type="password" id="setup-openai-key" placeholder="sk-...">
                        <div class="help-text">Get your API key from <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com/api-keys</a></div>
                    </div>
                `;
            } else if (provider === 'lmstudio') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-lmstudio-url">LMStudio Server URL</label>
                        <input type="url" id="setup-lmstudio-url" value="http://localhost:1234/v1/chat/completions">
                        <div class="help-text">Make sure LMStudio is running with a loaded model and server enabled</div>
                    </div>
                `;
            }
            
            configDiv.innerHTML = configHTML;
        }

        function showVoiceConfig(voiceType) {
            const configDiv = document.getElementById('voice-config');
            if (!configDiv) return;
            
            let configHTML = '';
            
            if (voiceType === 'whisper') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-whisper-key">OpenAI API Key (for Whisper)</label>
                        <input type="password" id="setup-whisper-key" placeholder="sk-proj-...">
                        <div class="help-text">Same as OpenAI API key. Get it from <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com/api-keys</a></div>
                    </div>
                `;
            } else if (voiceType === 'web') {
                configHTML = `
                    <div class="setup-form-group">
                        <label for="setup-web-speech-lang">Language</label>
                        <select id="setup-web-speech-lang">
                            <option value="en-US">English (United States)</option>
                            <option value="en-GB">English (United Kingdom)</option>
                            <option value="es-ES">Spanish (Spain)</option>
                            <option value="fr-FR">French (France)</option>
                            <option value="de-DE">German (Germany)</option>
                            <option value="it-IT">Italian (Italy)</option>
                            <option value="pt-BR">Portuguese (Brazil)</option>
                            <option value="ru-RU">Russian (Russia)</option>
                            <option value="ja-JP">Japanese (Japan)</option>
                            <option value="zh-CN">Chinese (Mandarin)</option>
                        </select>
                        <div class="help-text">Choose your preferred language for voice recognition</div>
                    </div>
                `;
            }
            
            configDiv.innerHTML = configHTML;
        }

        async function testAIConnection() {
            const resultDiv = document.getElementById('ai-test-result');
            if (!resultDiv) return;
            
            const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
            if (!selectedProvider) {
                resultDiv.innerHTML = '<div class="setup-test-result error">Please select an AI provider first.</div>';
                return;
            }
            
            const provider = selectedProvider.dataset.provider;
            resultDiv.innerHTML = '<div class="setup-test-result warning">Testing connection...</div>';
            
            try {
                let apiKey = '';
                let apiUrl = '';
                
                if (provider === 'openrouter') {
                    apiKey = document.getElementById('setup-openrouter-key')?.value;
                    apiUrl = 'https://openrouter.ai/api/v1/chat/completions';
                } else if (provider === 'openai') {
                    apiKey = document.getElementById('setup-openai-key')?.value;
                    apiUrl = 'https://api.openai.com/v1/chat/completions';
                } else if (provider === 'lmstudio') {
                    apiUrl = document.getElementById('setup-lmstudio-url')?.value || 'http://localhost:1234/v1/chat/completions';
                    apiKey = 'not-needed';
                }
                
                if (!apiKey && provider !== 'lmstudio') {
                    resultDiv.innerHTML = '<div class="setup-test-result error">Please enter your API key.</div>';
                    return;
                }
                
                let headers = {
                    'Content-Type': 'application/json'
                };
                
                // Only add Authorization header for providers that need it
                if (provider !== 'lmstudio') {
                    headers['Authorization'] = `Bearer ${apiKey}`;
                }
                
                // Add OpenRouter-specific headers
                if (provider === 'openrouter') {
                    headers['HTTP-Referer'] = window.location.origin;
                    headers['X-Title'] = 'Self-Evolving OS Setup';
                }
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        model: provider === 'openrouter' ? 'google/gemini-2.5-flash-lite-preview-06-17' :
                               provider === 'openai' ? 'gpt-4o-mini' : 'llama-3.2-3b-instruct',
                        messages: [{ role: 'user', content: 'Hello! This is a test message.' }],
                        ...(provider === 'openai' ?
                            { max_completion_tokens: 50, temperature: 1 } :
                            { max_tokens: 50, temperature: 0.7 })
                    })
                });
                
                if (response.ok) {
                    resultDiv.innerHTML = '<div class="setup-test-result success">✅ Connection successful! AI provider is working correctly.</div>';
                } else {
                    const errorText = await response.text();
                    resultDiv.innerHTML = `<div class="setup-test-result error">❌ Connection failed: ${response.status} - ${errorText}</div>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="setup-test-result error">❌ Connection failed: ${error.message}</div>`;
            }
        }

        async function testVoiceRecognition() {
            const resultDiv = document.getElementById('voice-test-result');
            if (!resultDiv) return;
            
            const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
            if (!selectedVoice) {
                resultDiv.innerHTML = '<div class="setup-test-result error">Please select a voice recognition method first.</div>';
                return;
            }
            
            const voiceType = selectedVoice.dataset.voice;
            resultDiv.innerHTML = '<div class="setup-test-result warning">🎤 Say something to test voice recognition...</div>';
            
            try {
                if (voiceType === 'web') {
                    // Test Web Speech API
                    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">❌ Web Speech API not supported in this browser.</div>';
                        return;
                    }
                    
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    const recognition = new SpeechRecognition();
                    recognition.continuous = false;
                    recognition.interimResults = false;
                    recognition.lang = document.getElementById('setup-web-speech-lang')?.value || 'en-US';
                    
                    recognition.onresult = function(event) {
                        const transcript = event.results[0][0].transcript;
                        resultDiv.innerHTML = `<div class="setup-test-result success">✅ Voice recognition working! You said: "${transcript}"</div>`;
                    };
                    
                    recognition.onerror = function(event) {
                        resultDiv.innerHTML = `<div class="setup-test-result error">❌ Voice recognition error: ${event.error}</div>`;
                    };
                    
                    recognition.start();
                    
                } else if (voiceType === 'whisper') {
                    // Test Whisper API
                    const apiKey = document.getElementById('setup-whisper-key')?.value;
                    if (!apiKey) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">Please enter your OpenAI API key first.</div>';
                        return;
                    }
                    
                    // Request microphone access for Whisper test
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        resultDiv.innerHTML = '<div class="setup-test-result success">✅ Microphone access granted! Whisper API key will be tested when you create your first app.</div>';
                        stream.getTracks().forEach(track => track.stop());
                    } catch (error) {
                        resultDiv.innerHTML = '<div class="setup-test-result error">❌ Microphone access denied. Please allow microphone access for voice recognition.</div>';
                    }
                }
            } catch (error) {
                resultDiv.innerHTML = `<div class="setup-test-result error">❌ Voice test failed: ${error.message}</div>`;
            }
        }

        function validateCurrentStep(stepNumber) {
            if (stepNumber === 2) {
                // Validate AI Model step
                const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
                if (!selectedProvider) {
                    alert('Please select an AI provider.');
                    return false;
                }
                
                const provider = selectedProvider.dataset.provider;
                if (provider === 'openrouter') {
                    const apiKey = document.getElementById('setup-openrouter-key')?.value;
                    if (!apiKey) {
                        alert('Please enter your OpenRouter API key.');
                        return false;
                    }
                } else if (provider === 'openai') {
                    const apiKey = document.getElementById('setup-openai-key')?.value;
                    if (!apiKey) {
                        alert('Please enter your OpenAI API key.');
                        return false;
                    }
                }
            } else if (stepNumber === 3) {
                // Validate Voice & Audio step
                const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
                if (!selectedVoice) {
                    alert('Please select a voice recognition method.');
                    return false;
                }
                
                const voiceType = selectedVoice.dataset.voice;
                if (voiceType === 'whisper') {
                    const apiKey = document.getElementById('setup-whisper-key')?.value;
                    if (!apiKey) {
                        alert('Please enter your OpenAI API key for Whisper.');
                        return false;
                    }
                }
            }
            return true;
        }

        function saveCurrentStepSettings(stepNumber) {
            if (stepNumber === 2) {
                // Save AI Model settings
                const selectedProvider = document.querySelector('.setup-option-card[data-provider].selected');
                if (selectedProvider) {
                    const provider = selectedProvider.dataset.provider;
                    
                    if (provider === 'openrouter') {
                        const apiKey = document.getElementById('setup-openrouter-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENROUTER_API_KEY = apiKey;
                            CONFIG.CURRENT_LLM_PROVIDER = 'openrouter';
                        }
                    } else if (provider === 'openai') {
                        const apiKey = document.getElementById('setup-openai-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENROUTER_API_KEY = apiKey; // Reuse same config key
                            CONFIG.OPENROUTER_URL = 'https://api.openai.com/v1/chat/completions';
                            CONFIG.CURRENT_LLM_PROVIDER = 'openai';
                        }
                    } else if (provider === 'lmstudio') {
                        const url = document.getElementById('setup-lmstudio-url')?.value;
                        if (url) {
                            CONFIG.OPENROUTER_API_KEY = 'not-needed';
                            CONFIG.OPENROUTER_URL = url;
                            CONFIG.CURRENT_LLM_PROVIDER = 'lmstudio';
                        }
                    }
                }
            } else if (stepNumber === 3) {
                // Save Voice & Audio settings
                const selectedVoice = document.querySelector('.setup-option-card[data-voice].selected');
                if (selectedVoice) {
                    const voiceType = selectedVoice.dataset.voice;
                    voiceRecognitionType = voiceType;
                    
                    if (voiceType === 'whisper') {
                        const apiKey = document.getElementById('setup-whisper-key')?.value;
                        if (apiKey) {
                            CONFIG.OPENAI_API_KEY = apiKey;
                        }
                    }
                }
            }
        }

        function finishSetup(setupId) {
            // Create final settings object and save to cookie
            const settings = {
                // Appearance Settings
                theme: 'light',
                
                // Voice & Audio Settings
                voiceRecognitionType: voiceRecognitionType,
                webSpeechLanguage: document.getElementById('setup-web-speech-lang')?.value || 'en-US',
                
                // AI Model Settings - Voice Recognition
                openaiWhisperKey: CONFIG.OPENAI_API_KEY || '',
                openaiWhisperUrl: 'https://api.openai.com/v1/audio/transcriptions',
                
                // AI Model Settings - Code Generation
                llmProvider: CONFIG.CURRENT_LLM_PROVIDER || 'openrouter',
                
                // Provider-specific settings
                openrouterApiKey: CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' ? CONFIG.OPENROUTER_API_KEY : '',
                openrouterUrl: CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' ? CONFIG.OPENROUTER_URL : 'https://openrouter.ai/api/v1/chat/completions',
                openrouterSimpleModel: 'google/gemini-2.5-flash-lite-preview-06-17',
                openrouterToughModel: 'anthropic/claude-sonnet-4',
                
                openaiApiKey: CONFIG.CURRENT_LLM_PROVIDER === 'openai' ? CONFIG.OPENROUTER_API_KEY : '',
                openaiUrl: CONFIG.CURRENT_LLM_PROVIDER === 'openai' ? CONFIG.OPENROUTER_URL : 'https://api.openai.com/v1/chat/completions',
                openaiSimpleModel: 'gpt-4o-mini',
                openaiToughModel: 'gpt-4o',
                
                lmstudioUrl: CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio' ? CONFIG.OPENROUTER_URL : 'http://localhost:1234/v1/chat/completions',
                lmstudioSimpleModel: 'llama-3.2-3b-instruct',
                lmstudioToughModel: 'llama-3.1-8b-instruct',
                
                // AI Model Settings - General
                apiTimeout: 30,
                maxRetries: 3,
                costTracking: true,
                
                // System Settings
                debugMode: false,
                performanceMode: false,
                autoCleanup: true,
                
                // Metadata
                version: '2.0.0',
                lastSaved: new Date().toISOString()
            };
            
            // Save settings to cookie
            const expires = new Date();
            expires.setFullYear(expires.getFullYear() + 1);
            document.cookie = `selfEvolvingOS_settings=${encodeURIComponent(JSON.stringify(settings))}; expires=${expires.toUTCString()}; path=/`;
            
            // Apply settings to system
            applySettingsToSystem(settings);
            
            // Update summary in completion step
            const summaryDiv = document.getElementById('setup-summary');
            if (summaryDiv) {
                summaryDiv.innerHTML = `
                    <div>🤖 AI Provider: ${CONFIG.CURRENT_LLM_PROVIDER || 'OpenRouter'}</div>
                    <div>🎤 Voice Recognition: ${voiceRecognitionType === 'web' ? 'Web Speech API' : 'OpenAI Whisper'}</div>
                    <div>🎨 Theme: Light Mode</div>
                `;
            }
            
            // Initialize voice system with new settings
            setTimeout(async () => {
                try {
                    await initializeVoice();
                    console.log('Voice system initialized with setup settings');
                } catch (error) {
                    console.warn('Voice initialization failed during setup:', error);
                }
            }, 1000);
            
            console.log('Setup completed successfully!', settings);
            
            // Show completion message and close setup after delay
            setTimeout(() => {
                alert('🎉 Setup completed! Your Self-Evolving OS is ready to use. Try saying "Create a calculator app" or use the Start menu.');
                closeWindow(setupId);
            }, 2000);
        }

        // Settings persistence functions
        function saveSettingsToCookie() {
            const settings = {
                // Appearance Settings
                theme: document.getElementById('theme')?.value ?? 'light',
                
                // Voice & Audio Settings
                voiceRecognitionType: document.getElementById('voice-recognition-type')?.value ?? 'whisper',
                webSpeechLanguage: document.getElementById('web-speech-language')?.value ?? 'en-US',
                
                // AI Model Settings - Voice Recognition
                openaiWhisperKey: document.getElementById('openai-whisper-key')?.value ?? '',
                openaiWhisperUrl: document.getElementById('openai-whisper-url')?.value ?? 'https://api.openai.com/v1/audio/transcriptions',
                
                // AI Model Settings - Code Generation
                llmProvider: document.getElementById('llm-provider')?.value ?? 'openrouter',
                
                // OpenRouter settings
                openrouterApiKey: document.getElementById('openrouter-api-key')?.value ?? '',
                openrouterUrl: document.getElementById('openrouter-url')?.value ?? 'https://openrouter.ai/api/v1/chat/completions',
                openrouterSimpleModel: document.getElementById('openrouter-simple-model')?.value ?? 'google/gemini-2.5-flash-lite-preview-06-17',
                openrouterToughModel: document.getElementById('openrouter-tough-model')?.value ?? 'anthropic/claude-sonnet-4',
                
                // OpenAI settings
                openaiApiKey: document.getElementById('openai-api-key')?.value ?? '',
                openaiUrl: document.getElementById('openai-url')?.value ?? 'https://api.openai.com/v1/chat/completions',
                openaiSimpleModel: document.getElementById('openai-simple-model')?.value ?? 'gpt-4o-mini',
                openaiToughModel: document.getElementById('openai-tough-model')?.value ?? 'gpt-4o',
                
                // LMStudio settings
                lmstudioUrl: document.getElementById('lmstudio-url')?.value ?? 'http://localhost:1234/v1/chat/completions',
                lmstudioSimpleModel: document.getElementById('lmstudio-simple-model')?.value ?? 'llama-3.2-3b-instruct',
                lmstudioToughModel: document.getElementById('lmstudio-tough-model')?.value ?? 'llama-3.1-8b-instruct',
                
                // AI Model Settings - General
                apiTimeout: parseInt(document.getElementById('api-timeout')?.value) ?? 30,
                maxRetries: parseInt(document.getElementById('max-retries')?.value) ?? 3,
                costTracking: document.getElementById('cost-tracking')?.checked ?? true,
                
                // System Settings
                debugMode: document.getElementById('debug-mode')?.checked ?? false,
                performanceMode: document.getElementById('performance-mode')?.checked ?? false,
                autoCleanup: document.getElementById('auto-cleanup')?.checked ?? true,
                
                // Metadata
                version: '2.0.0',
                lastSaved: new Date().toISOString()
            };
            
            // Save to cookie (expires in 1 year)
            const expires = new Date();
            expires.setFullYear(expires.getFullYear() + 1);
            document.cookie = `selfEvolvingOS_settings=${encodeURIComponent(JSON.stringify(settings))}; expires=${expires.toUTCString()}; path=/`;
            
            console.log('Settings saved to cookie:', settings);
            return settings;
        }

        function loadSettingsFromCookie() {
            try {
                const cookies = document.cookie.split(';');
                const settingsCookie = cookies.find(cookie => cookie.trim().startsWith('selfEvolvingOS_settings='));
                
                if (settingsCookie) {
                    const settingsJson = decodeURIComponent(settingsCookie.split('=')[1]);
                    const settings = JSON.parse(settingsJson);
                    console.log('Settings loaded from cookie:', settings);
                    return settings;
                }
            } catch (error) {
                console.warn('Failed to load settings from cookie:', error);
            }
            
            return null;
        }

        function applySettingsToUI(settings) {
            if (!settings) return;
            
            try {
                // Appearance Settings
                const theme = document.getElementById('theme');
                if (theme) theme.value = settings.theme ?? 'light';
                
                // Voice & Audio Settings
                const voiceRecognitionTypeEl = document.getElementById('voice-recognition-type');
                if (voiceRecognitionTypeEl) {
                    voiceRecognitionTypeEl.value = settings.voiceRecognitionType ?? 'whisper';
                    // Update global variable
                    voiceRecognitionType = settings.voiceRecognitionType ?? 'whisper';
                }
                
                const webSpeechLanguage = document.getElementById('web-speech-language');
                if (webSpeechLanguage) webSpeechLanguage.value = settings.webSpeechLanguage ?? 'en-US';
                
                // AI Model Settings - Voice Recognition
                const openaiWhisperKey = document.getElementById('openai-whisper-key');
                if (openaiWhisperKey) openaiWhisperKey.value = settings.openaiWhisperKey ?? '';
                
                const openaiWhisperUrl = document.getElementById('openai-whisper-url');
                if (openaiWhisperUrl) openaiWhisperUrl.value = settings.openaiWhisperUrl ?? 'https://api.openai.com/v1/audio/transcriptions';
                
                // AI Model Settings - Code Generation
                const llmProvider = document.getElementById('llm-provider');
                if (llmProvider) llmProvider.value = settings.llmProvider ?? 'openrouter';
                
                // OpenRouter settings
                const openrouterApiKey = document.getElementById('openrouter-api-key');
                if (openrouterApiKey) openrouterApiKey.value = settings.openrouterApiKey ?? '';
                
                const openrouterUrl = document.getElementById('openrouter-url');
                if (openrouterUrl) openrouterUrl.value = settings.openrouterUrl ?? 'https://openrouter.ai/api/v1/chat/completions';
                
                const openrouterSimpleModel = document.getElementById('openrouter-simple-model');
                if (openrouterSimpleModel) openrouterSimpleModel.value = settings.openrouterSimpleModel ?? 'google/gemini-2.5-flash-lite-preview-06-17';
                
                const openrouterToughModel = document.getElementById('openrouter-tough-model');
                if (openrouterToughModel) openrouterToughModel.value = settings.openrouterToughModel ?? 'anthropic/claude-sonnet-4';
                
                // OpenAI settings
                const openaiApiKey = document.getElementById('openai-api-key');
                if (openaiApiKey) openaiApiKey.value = settings.openaiApiKey ?? '';
                
                const openaiUrl = document.getElementById('openai-url');
                if (openaiUrl) openaiUrl.value = settings.openaiUrl ?? 'https://api.openai.com/v1/chat/completions';
                
                const openaiSimpleModel = document.getElementById('openai-simple-model');
                if (openaiSimpleModel) openaiSimpleModel.value = settings.openaiSimpleModel ?? 'gpt-4o-mini';
                
                const openaiToughModel = document.getElementById('openai-tough-model');
                if (openaiToughModel) openaiToughModel.value = settings.openaiToughModel ?? 'gpt-4o';
                
                // LMStudio settings
                const lmstudioUrl = document.getElementById('lmstudio-url');
                if (lmstudioUrl) lmstudioUrl.value = settings.lmstudioUrl ?? 'http://localhost:1234/v1/chat/completions';
                
                const lmstudioSimpleModel = document.getElementById('lmstudio-simple-model');
                if (lmstudioSimpleModel) lmstudioSimpleModel.value = settings.lmstudioSimpleModel ?? 'llama-3.2-3b-instruct';
                
                const lmstudioToughModel = document.getElementById('lmstudio-tough-model');
                if (lmstudioToughModel) lmstudioToughModel.value = settings.lmstudioToughModel ?? 'llama-3.1-8b-instruct';
                
                // AI Model Settings - General
                const apiTimeout = document.getElementById('api-timeout');
                if (apiTimeout) apiTimeout.value = settings.apiTimeout ?? 30;
                
                const maxRetries = document.getElementById('max-retries');
                if (maxRetries) maxRetries.value = settings.maxRetries ?? 3;
                
                const costTracking = document.getElementById('cost-tracking');
                if (costTracking) costTracking.checked = settings.costTracking ?? true;
                
                // System Settings
                const debugMode = document.getElementById('debug-mode');
                if (debugMode) debugMode.checked = settings.debugMode ?? false;
                
                const performanceMode = document.getElementById('performance-mode');
                if (performanceMode) performanceMode.checked = settings.performanceMode ?? false;
                
                const autoCleanup = document.getElementById('auto-cleanup');
                if (autoCleanup) autoCleanup.checked = settings.autoCleanup ?? true;
                
                console.log('Settings applied to UI successfully');
                
            } catch (error) {
                console.error('Error applying settings to UI:', error);
            }
        }

        function applyTheme(theme) {
            // Remove existing theme classes
            document.body.classList.remove('light-theme', 'dark-theme');
            
            // Apply new theme class
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
            } else {
                document.body.classList.add('light-theme');
            }
            
            // Apply theme to all existing apps
            applyThemeToAllApps(theme);
            
            console.log(`Theme applied: ${theme}`);
        }

        function applyThemeToApp(appId) {
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            const contentElement = document.getElementById(`content_${appId}`);
            
            if (contentElement) {
                // Remove existing theme classes
                contentElement.classList.remove('app-light-theme', 'app-dark-theme');
                
                // Apply current theme class
                if (currentTheme === 'dark') {
                    contentElement.classList.add('app-dark-theme');
                } else {
                    contentElement.classList.add('app-light-theme');
                }
                
                console.log(`Theme ${currentTheme} applied to app ${appId}`);
            }
        }

        function applyThemeToAllApps(theme) {
            // Apply theme to all existing app content areas
            const allAppContents = document.querySelectorAll('[id^="content_"]');
            
            allAppContents.forEach(contentElement => {
                // Remove existing theme classes
                contentElement.classList.remove('app-light-theme', 'app-dark-theme');
                
                // Apply new theme class
                if (theme === 'dark') {
                    contentElement.classList.add('app-dark-theme');
                } else {
                    contentElement.classList.add('app-light-theme');
                }
            });
            
            console.log(`Theme ${theme} applied to ${allAppContents.length} existing apps`);
        }

        // App visibility event system
        function dispatchAppShownEvent(appId) {
            const event = new CustomEvent('appShown', {
                detail: { appId: appId }
            });
            document.dispatchEvent(event);
            debugLog(`App shown event dispatched for app: ${appId}`);
        }

        function applySettingsToSystem(settings) {
            if (!settings) return;
            
            try {
                // Apply theme
                if (settings.theme) {
                    applyTheme(settings.theme);
                }
                
                // Apply voice recognition type to global variable
                if (settings.voiceRecognitionType) {
                    voiceRecognitionType = settings.voiceRecognitionType;
                }
                
                // Apply API settings to CONFIG
                if (settings.openaiWhisperKey) {
                    CONFIG.OPENAI_API_KEY = settings.openaiWhisperKey;
                }
                
                // Apply LLM provider settings based on selected provider
                const currentProvider = settings.llmProvider || 'openrouter';
                
                if (currentProvider === 'openrouter') {
                    if (settings.openrouterApiKey) CONFIG.OPENROUTER_API_KEY = settings.openrouterApiKey;
                    if (settings.openrouterUrl) CONFIG.OPENROUTER_URL = settings.openrouterUrl;
                    if (settings.openrouterSimpleModel) CONFIG.MODEL_SIMPLE = settings.openrouterSimpleModel;
                    if (settings.openrouterToughModel) CONFIG.MODEL_TOUGH = settings.openrouterToughModel;
                } else if (currentProvider === 'openai') {
                    if (settings.openaiApiKey) CONFIG.OPENROUTER_API_KEY = settings.openaiApiKey; // Reuse the same config key
                    if (settings.openaiUrl) CONFIG.OPENROUTER_URL = settings.openaiUrl; // Reuse the same config key
                    if (settings.openaiSimpleModel) CONFIG.MODEL_SIMPLE = settings.openaiSimpleModel;
                    if (settings.openaiToughModel) CONFIG.MODEL_TOUGH = settings.openaiToughModel;
                } else if (currentProvider === 'lmstudio') {
                    CONFIG.OPENROUTER_API_KEY = 'not-needed'; // LMStudio doesn't need API key
                    if (settings.lmstudioUrl) CONFIG.OPENROUTER_URL = settings.lmstudioUrl; // Reuse the same config key
                    if (settings.lmstudioSimpleModel) CONFIG.MODEL_SIMPLE = settings.lmstudioSimpleModel;
                    if (settings.lmstudioToughModel) CONFIG.MODEL_TOUGH = settings.lmstudioToughModel;
                }
                
                // Store current provider in CONFIG
                CONFIG.CURRENT_LLM_PROVIDER = currentProvider;
                
                // Update CONFIG.MODEL to match the current mode with the new provider-specific models
                if (currentModelMode === 'Simple') {
                    CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                } else {
                    CONFIG.MODEL = CONFIG.MODEL_TOUGH;
                }
                
                // Update the provider display in the header
                updateProviderDisplay();
                
                // Apply cost tracking setting
                if (settings.costTracking !== undefined) {
                    costTrackingEnabled = settings.costTracking;
                    
                    // Show/hide cost tracking app in start menu based on setting
                    updateCostTrackingAppVisibility();
                }
                
                // Apply API timeout and max retries to CONFIG
                if (settings.apiTimeout) {
                    CONFIG.API_TIMEOUT = settings.apiTimeout * 1000; // Convert to milliseconds
                }
                
                if (settings.maxRetries) {
                    CONFIG.MAX_RETRIES = settings.maxRetries;
                }
                
                // Apply debug mode setting
                if (settings.debugMode !== undefined) {
                    debugMode = settings.debugMode;
                }
                
                if (debugMode) {
                    console.log('Settings applied to system successfully');
                    console.log('Updated CONFIG:', CONFIG);
                    console.log('Debug mode:', debugMode);
                }
                
            } catch (error) {
                console.error('Error applying settings to system:', error);
            }
        }

        // Cost tracking functions
        function addCostEntry(cost, description, prompt = '') {
            if (!costTrackingEnabled) return;
            
            const entry = {
                timestamp: new Date().toISOString(),
                cost: parseFloat(cost),
                description: description,
                prompt: prompt.substring(0, 200) + (prompt.length > 200 ? '...' : '') // Limit prompt length
            };
            
            costHistory.push(entry);
            
            // Update global window reference
            window.costHistory = costHistory;
            
            // Save to localStorage for persistence
            localStorage.setItem('costHistory', JSON.stringify(costHistory));
            
            debugLog('Cost entry added:', entry);
        }

        function loadCostHistory() {
            try {
                const saved = localStorage.getItem('costHistory');
                if (saved) {
                    costHistory = JSON.parse(saved);
                    // Update global window reference
                    window.costHistory = costHistory;
                }
            } catch (error) {
                debugWarn('Failed to load cost history:', error);
                costHistory = [];
                window.costHistory = costHistory;
            }
        }

        function updateCostTrackingAppVisibility() {
            const startMenu = document.getElementById('start-menu');
            let costTrackingItem = document.getElementById('cost-tracking-item');
            
            if (costTrackingEnabled) {
                // Add cost tracking app to System section if not exists
                if (!costTrackingItem) {
                    // Find the System section
                    const systemSection = Array.from(startMenu.querySelectorAll('.menu-section')).find(section =>
                        section.querySelector('.menu-title')?.textContent === 'System'
                    );
                    
                    // Cost Tracking is now handled in the "All Apps" submenu
                }
            } else {
                // Remove cost tracking app from System section
                if (costTrackingItem) {
                    costTrackingItem.remove();
                }
            }
            
            // Remove old cost tracking section if it exists (for backward compatibility)
            const oldCostTrackingSection = document.getElementById('cost-tracking-section');
            if (oldCostTrackingSection) {
                oldCostTrackingSection.remove();
            }
        }

        function openCostTrackingApp() {
            // Check if Cost Tracking app already exists
            const existingApp = apps.find(app => app.title === 'Cost Tracking' || app.title === '💰 Cost Tracking');
            
            if (existingApp) {
                // If app exists, show/focus the existing window
                const windowElement = document.getElementById(`window_${existingApp.id}`);
                const iconElement = document.getElementById(`icon_${existingApp.id}`);
                
                if (windowElement) {
                    // Show if hidden
                    if (existingApp.isHidden) {
                        windowElement.style.display = 'block';
                        if (iconElement) iconElement.style.display = 'block';
                        existingApp.isHidden = false;
                        
                        // Update apps submenu to reflect the change
                        updateAppsSubmenuContent();
                    }
                    
                    // Unminimize if minimized
                    if (existingApp.isMinimized) {
                        toggleWindow(existingApp.id);
                    }
                    
                    // Bring to front
                    windowElement.style.zIndex = getHighestZIndex() + 1;
                    
                    // Dispatch app shown event to notify the app it's visible
                    dispatchAppShownEvent(existingApp.id);
                    
                    debugLog('Opened existing Cost Tracking app');
                } else {
                    // Window doesn't exist but app is in array, recreate it
                    generateSystemApp('Cost Tracking', existingApp.id);
                    
                    // Ensure it's still marked as system app
                    existingApp.isSystemApp = true;
                    existingApp.isHidden = false;
                    
                    debugLog('Recreated Cost Tracking app window');
                }
            } else {
                // Create new AI-generated cost tracking app
                const newAppId = createCostTrackingApp();
                
                // Mark the new app as a system app
                const newApp = apps.find(app => app.id === newAppId);
                if (newApp) {
                    newApp.isSystemApp = true;
                    console.log('Marked new Cost Tracking app as system app');
                }
            }
            
            // Close start menu
            hideAppsSubmenu();
            document.getElementById('start-menu').classList.remove('show');
        }

        function createCostTrackingApp() {
            return generateSystemApp('Cost Tracking');
        }

        function getHighestZIndex() {
            const windows = document.querySelectorAll('.window');
            let highest = 0;
            windows.forEach(window => {
                const zIndex = parseInt(window.style.zIndex) || 0;
                if (zIndex > highest) {
                    highest = zIndex;
                }
            });
            return highest;
        }

        function createCostTrackingPrompt() {
            // This function is kept for backward compatibility but now uses the definition dictionary
            return SYSTEM_APPS_DEFINITIONS['Cost Tracking'].prompt;
        }


        function clearCostHistory() {
            if (confirm('Are you sure you want to clear all cost history? This action cannot be undone.')) {
                costHistory = [];
                window.costHistory = costHistory;
                localStorage.removeItem('costHistory');
                
                // Update status bar
                const costElement = document.getElementById('api-cost');
                if (costElement) {
                    costElement.textContent = '0.00';
                }
                
                // Reset total cost
                totalCost = 0;
                
                alert('Cost history cleared successfully! Please refresh any open Cost Tracking apps to see the changes.');
            }
        }
        
        // Make clearCostHistory globally accessible for generated apps
        window.clearCostHistory = clearCostHistory;

        // Global function for apps to load cost data
        function loadCostData() {
            // This function can be called by generated apps to get fresh cost data
            // Return the current cost history and total
            const totalCost = costHistory.reduce((sum, entry) => sum + entry.cost, 0);
            return {
                costHistory: costHistory,
                totalCost: totalCost,
                callCount: costHistory.length
            };
        }
        
        // Make loadCostData globally accessible for generated apps
        window.loadCostData = loadCostData;

        // Debug function to check cost data state
        function debugCostData() {
            console.log('=== COST DATA DEBUG ===');
            console.log('costTrackingEnabled:', costTrackingEnabled);
            console.log('costHistory length:', costHistory.length);
            console.log('costHistory:', costHistory);
            console.log('window.costHistory:', window.costHistory);
            console.log('totalCost:', totalCost);
            console.log('localStorage costHistory:', localStorage.getItem('costHistory'));
            console.log('======================');
        }
        
        // Make debug function globally accessible
        window.debugCostData = debugCostData;

        // Test function to add a sample cost entry for debugging
        function addTestCostEntry() {
            addCostEntry(0.0025, 'Test Entry', 'This is a test cost entry for debugging');
            console.log('Test cost entry added. Total entries:', costHistory.length);
            debugCostData();
        }
        
        // Make test function globally accessible
        window.addTestCostEntry = addTestCostEntry;

        // Apps Sub-menu Functions
        let appsSubmenuTimeout = null;

        function showAppsSubmenu() {
            if (appsSubmenuTimeout) {
                clearTimeout(appsSubmenuTimeout);
                appsSubmenuTimeout = null;
            }
            
            const submenu = document.getElementById('apps-submenu');
            if (submenu) {
                updateAppsSubmenuContent();
                submenu.classList.add('show');
            }
        }

        function toggleAppsSubmenu() {
            const submenu = document.getElementById('apps-submenu');
            if (submenu) {
                if (submenu.classList.contains('show')) {
                    hideAppsSubmenu();
                } else {
                    showAppsSubmenu();
                }
            }
        }

        function hideAppsSubmenuDelayed() {
            appsSubmenuTimeout = setTimeout(() => {
                const submenu = document.getElementById('apps-submenu');
                if (submenu) {
                    submenu.classList.remove('show');
                }
            }, 300); // 300ms delay
        }

        function normalizeAppIconsAndTitles(apps) {
            return apps.map(app => {
                // Check if title starts with an emoji
                const emojiMatch = app.title.match(/^([\u{1F000}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])\s*(.+)$/u);
                
                if (emojiMatch) {
                    // Extract emoji and clean title
                    const emoji = emojiMatch[1];
                    const cleanTitle = emojiMatch[2].trim();
                    
                    return {
                        ...app,
                        title: cleanTitle,
                        icon: app.icon || emoji
                    };
                } else {
                    // Title is already clean, ensure icon exists
                    return {
                        ...app,
                        icon: app.icon || '📱'
                    };
                }
            });
        }

        function normalizeAllApps() {
            // Normalize all apps in the main apps array
            const normalizedApps = normalizeAppIconsAndTitles(apps);
            
            // Update the apps array in place
            for (let i = 0; i < apps.length; i++) {
                apps[i] = normalizedApps[i];
            }
            
            console.log('Normalized all apps:', apps.map(app => ({ title: app.title, icon: app.icon })));
        }

        function updateAppsSubmenuContent() {
            const content = document.getElementById('apps-submenu-content');
            if (!content) return;

            // Clear existing content
            content.innerHTML = '';

            // First normalize all apps in the main array
            normalizeAllApps();

            // Get all real apps (now normalized)
            const allApps = [...apps];
            
            // Add system app placeholders from SYSTEM_APPS_DEFINITIONS for apps that don't exist yet
            console.log('All apps titles:', allApps.map(app => app.title));
            
            Object.keys(SYSTEM_APPS_DEFINITIONS).forEach(appName => {
                const appDefinition = SYSTEM_APPS_DEFINITIONS[appName];
                const hasRealApp = allApps.some(app =>
                    app.title === appName ||
                    app.title === `${appDefinition.icon} ${appName}`
                );
                
                console.log(`Has real ${appName} app:`, hasRealApp);
                
                if (!hasRealApp) {
                    allApps.push({
                        id: `${appName.toLowerCase().replace(/\s+/g, '-')}-system`,
                        title: appName,
                        icon: appDefinition.icon,
                        isSystemApp: true,
                        type: 'system'
                    });
                    console.log(`Added ${appName} placeholder`);
                }
            });

            // Sort apps alphabetically by title
            allApps.sort((a, b) => {
                const titleA = a.title.replace(/^[^\w]+/, ''); // Remove emoji/symbols for sorting
                const titleB = b.title.replace(/^[^\w]+/, '');
                return titleA.localeCompare(titleB);
            });

            // Create menu items for each app
            allApps.forEach(app => {
                const item = document.createElement('div');
                item.className = 'apps-submenu-item';
                
                // Create icon and title elements (now simplified)
                const iconSpan = document.createElement('span');
                iconSpan.className = 'submenu-app-icon';
                iconSpan.textContent = app.icon || '📱';
                
                const titleSpan = document.createElement('span');
                titleSpan.className = 'submenu-app-title';
                titleSpan.textContent = app.title;
                
                item.appendChild(iconSpan);
                item.appendChild(titleSpan);
                
                console.log('Creating submenu item for app:', app);
                
                // Check if this is a system app from definitions
                const systemAppOpenFunction = getSystemAppOpenFunction(app.title);
                
                if (systemAppOpenFunction) {
                    // Use the specific open function for system apps (both real and placeholder)
                    const systemAppHandler = () => {
                        console.log(`${app.title} submenu item clicked`);
                        systemAppOpenFunction();
                    };
                    item.onclick = systemAppHandler;
                    item.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        systemAppHandler();
                    });
                } else {
                    const appHandler = () => {
                        console.log('Regular app submenu item clicked for:', app.id);
                        // Focus existing app or show it if minimized/hidden
                        if (app.isHidden) {
                            // For hidden system apps, show them
                            const windowElement = document.getElementById(`window_${app.id}`);
                            const iconElement = document.getElementById(`icon_${app.id}`);
                            if (windowElement) {
                                windowElement.style.display = 'block';
                                if (iconElement) iconElement.style.display = 'block';
                                app.isHidden = false;
                                windowElement.style.zIndex = getHighestZIndex() + 1;
                            }
                        } else if (app.isMinimized) {
                            toggleMinimize(app.id);
                        } else {
                            bringToFront(app.id);
                        }
                        hideAppsSubmenu();
                    };
                    item.onclick = appHandler;
                    item.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        appHandler();
                    });
                }
                
                content.appendChild(item);
            });

            // If no apps, show a message
            if (allApps.length === 0) {
                const noAppsItem = document.createElement('div');
                noAppsItem.className = 'apps-submenu-item';
                noAppsItem.textContent = 'No apps available';
                noAppsItem.style.color = '#888';
                noAppsItem.style.fontStyle = 'italic';
                content.appendChild(noAppsItem);
            }
        }

        function hideAppsSubmenu() {
            const submenu = document.getElementById('apps-submenu');
            if (submenu) {
                submenu.classList.remove('show');
            }
        }

        // Calculator App Functions
        function openCalculatorApp() {
            console.log('=== openCalculatorApp called ===');
            console.log('Current apps array:', apps);
            
            // Check if Calculator app already exists
            const existingApp = apps.find(app => app.title === 'Calculator');
            console.log('Found existing Calculator app:', existingApp);
            
            if (existingApp) {
                console.log('Found existing Calculator app with ID:', existingApp.id);
                console.log('App state - isHidden:', existingApp.isHidden, 'isMinimized:', existingApp.isMinimized);
                
                // If app exists, show/focus the existing window
                const windowElement = document.getElementById(`window_${existingApp.id}`);
                const iconElement = document.getElementById(`icon_${existingApp.id}`);
                
                console.log('Window element exists:', !!windowElement);
                console.log('Icon element exists:', !!iconElement);
                
                if (windowElement) {
                    // Show if hidden
                    if (existingApp.isHidden) {
                        console.log('Showing hidden Calculator app');
                        windowElement.style.display = 'block';
                        if (iconElement) iconElement.style.display = 'block';
                        existingApp.isHidden = false;
                        
                        // Update apps submenu to reflect the change
                        updateAppsSubmenuContent();
                    }
                    
                    // Unminimize if minimized
                    if (existingApp.isMinimized) {
                        console.log('Unminimizing Calculator app');
                        toggleWindow(existingApp.id);
                    }
                    
                    // Bring to front
                    windowElement.style.zIndex = getHighestZIndex() + 1;
                    
                    // Dispatch app shown event to notify the app it's visible
                    dispatchAppShownEvent(existingApp.id);
                    
                    console.log('Successfully opened existing Calculator app');
                    debugLog('Opened existing Calculator app');
                } else {
                    console.log('Window element missing, recreating Calculator app window');
                    // Window element doesn't exist, recreate it using the system app generation
                    generateSystemApp('Calculator', existingApp.id);
                    
                    // Ensure it's still marked as system app
                    existingApp.isSystemApp = true;
                    existingApp.isHidden = false;
                    
                    console.log('Successfully recreated Calculator app window');
                    debugLog('Recreated Calculator app window');
                }
            } else {
                console.log('No existing Calculator app found, creating new one');
                // Create new AI-generated calculator app
                const newAppId = createCalculatorApp();
                
                // Mark the new app as a system app
                const newApp = apps.find(app => app.id === newAppId);
                if (newApp) {
                    newApp.isSystemApp = true;
                    console.log('Marked new Calculator app as system app');
                }
            }
            
            // Close start menu and submenu
            hideAppsSubmenu();
            document.getElementById('start-menu').classList.remove('show');
        }

        // System App Generation with Mode Management
        function generateSystemApp(appName, appId = null) {
            console.log(`🔧 Generating system app: ${appName}`);
            
            // Get app definition from dictionary
            const appDefinition = SYSTEM_APPS_DEFINITIONS[appName];
            if (!appDefinition) {
                console.error(`❌ No definition found for system app: ${appName}`);
                return null;
            }
            
            // Store current mode for restoration
            previousModelMode = currentModelMode;
            
            // Set generation mode based on app definition
            const requiredMode = appDefinition.generationMode === 'TOUGH' ? 'Tough' : 'Simple';
            if (currentModelMode !== requiredMode) {
                console.log(`🔄 Switching from ${currentModelMode} to ${requiredMode} mode for ${appName} generation`);
                setModelMode(requiredMode);
            }
            
            // Generate or use provided app ID
            const finalAppId = appId || generateAppId();
            
            // Get app-specific settings
            const icon = getSystemAppIcon(appName);
            const dimensions = getSystemAppDimensions(appName);
            
            // Create app content using the definition's prompt
            const content = createAIGeneratedAppContent(appDefinition.prompt, finalAppId);

            const app = {
                id: finalAppId,
                type: 'ai-generated',
                title: appName,
                icon: icon,
                isMinimized: false,
                isMaximized: false,
                system: true,
                customRequest: appDefinition.prompt,
                isSystemApp: true,
                generationMode: appDefinition.generationMode,
                isHidden: false
            };

            apps.push(app);
            createWindow(finalAppId, appName, content, dimensions.width, dimensions.height, icon);
            createTaskbarIcon(finalAppId, appName, icon);
            updateAppCount();
            
            // Update apps submenu to include the new system app
            updateAppsSubmenuContent();
            
            // Schedule mode restoration after generation completes
            scheduleModelModeRestoration();
            
            debugLog(`Created new ${appName} system app with ${appDefinition.generationMode} mode`);
            return finalAppId;
        }

        // Helper function to set model mode
        function setModelMode(mode) {
            const toggleButton = document.getElementById('model-toggle');
            const modeText = document.getElementById('model-mode-text');
            
            if (mode === 'Tough' && currentModelMode !== 'Tough') {
                currentModelMode = 'Tough';
                CONFIG.MODEL = CONFIG.MODEL_TOUGH;
                if (modeText) modeText.textContent = 'Tough';
                if (toggleButton) toggleButton.classList.add('tough-mode');
            } else if (mode === 'Simple' && currentModelMode !== 'Simple') {
                currentModelMode = 'Simple';
                CONFIG.MODEL = CONFIG.MODEL_SIMPLE;
                if (modeText) modeText.textContent = 'Simple';
                if (toggleButton) toggleButton.classList.remove('tough-mode');
            }
            
            console.log(`Model mode set to: ${currentModelMode} (${CONFIG.MODEL})`);
        }

        // Helper function to get system app icon
        function getSystemAppIcon(appName) {
            const appDefinition = SYSTEM_APPS_DEFINITIONS[appName];
            return appDefinition ? appDefinition.icon : '📱';
        }

        // Helper function to get system app open function
        function getSystemAppOpenFunction(appName) {
            const openFunctionMap = {
                'Calculator': openCalculatorApp,
                'Digital Clock': openDigitalClockApp,
                'Cost Tracking': openCostTrackingApp
            };
            return openFunctionMap[appName];
        }
        
        // Helper function to check if an app is a system app by name
        function isSystemAppByName(appName) {
            return SYSTEM_APPS_DEFINITIONS.hasOwnProperty(appName);
        }

        // Helper function to get system app dimensions
        function getSystemAppDimensions(appName) {
            const dimensionMap = {
                'Calculator': { width: 350, height: 450 },
                'Digital Clock': { width: 400, height: 300 },
                'Cost Tracking': { width: 600, height: 500 }
            };
            return dimensionMap[appName] || { width: 400, height: 300 };
        }

        // Schedule model mode restoration after generation
        function scheduleModelModeRestoration() {
            // Wait for generation to complete (estimated time) then restore mode
            setTimeout(() => {
                if (previousModelMode !== currentModelMode) {
                    console.log(`🔄 Restoring model mode from ${currentModelMode} back to ${previousModelMode}`);
                    setModelMode(previousModelMode);
                }
            }, 10000); // Wait 10 seconds for generation to complete
        }

        function createCalculatorApp() {
            return generateSystemApp('Calculator');
        }

        function createCalculatorPrompt() {
            // This function is kept for backward compatibility but now uses the definition dictionary
            return SYSTEM_APPS_DEFINITIONS['Calculator'].prompt;
        }

        // Digital Clock App Functions
        function openDigitalClockApp() {
            console.log('=== openDigitalClockApp called ===');
            console.log('Current apps array:', apps);
            
            // Check if Digital Clock app already exists
            const existingApp = apps.find(app => app.title === 'Digital Clock');
            console.log('Found existing Digital Clock app:', existingApp);
            
            if (existingApp) {
                console.log('Found existing Digital Clock app with ID:', existingApp.id);
                console.log('App state - isHidden:', existingApp.isHidden, 'isMinimized:', existingApp.isMinimized);
                
                // If app exists, show/focus the existing window
                const windowElement = document.getElementById(`window_${existingApp.id}`);
                const iconElement = document.getElementById(`icon_${existingApp.id}`);
                
                console.log('Window element exists:', !!windowElement);
                console.log('Icon element exists:', !!iconElement);
                
                if (windowElement) {
                    // Show if hidden
                    if (existingApp.isHidden) {
                        console.log('Showing hidden Digital Clock app');
                        windowElement.style.display = 'block';
                        if (iconElement) iconElement.style.display = 'block';
                        existingApp.isHidden = false;
                        
                        // Update apps submenu to reflect the change
                        updateAppsSubmenuContent();
                    }
                    
                    // Unminimize if minimized
                    if (existingApp.isMinimized) {
                        console.log('Unminimizing Digital Clock app');
                        toggleWindow(existingApp.id);
                    }
                    
                    // Bring to front
                    windowElement.style.zIndex = getHighestZIndex() + 1;
                    
                    // Dispatch app shown event to notify the app it's visible
                    dispatchAppShownEvent(existingApp.id);
                    
                    console.log('Successfully opened existing Digital Clock app');
                    debugLog('Opened existing Digital Clock app');
                } else {
                    console.log('Window element missing, recreating Digital Clock app window');
                    // Window element doesn't exist, recreate it using the system app generation
                    generateSystemApp('Digital Clock', existingApp.id);
                    
                    // Ensure it's still marked as system app
                    existingApp.isSystemApp = true;
                    existingApp.isHidden = false;
                    
                    console.log('Successfully recreated Digital Clock app window');
                    debugLog('Recreated Digital Clock app window');
                }
            } else {
                console.log('No existing Digital Clock app found, creating new one');
                // Create new AI-generated digital clock app
                const newAppId = createDigitalClockApp();
                
                // Mark the new app as a system app
                const newApp = apps.find(app => app.id === newAppId);
                if (newApp) {
                    newApp.isSystemApp = true;
                    console.log('Marked new Digital Clock app as system app');
                }
            }
            
            // Close start menu and submenu
            hideAppsSubmenu();
            document.getElementById('start-menu').classList.remove('show');
        }

        function createDigitalClockApp() {
            return generateSystemApp('Digital Clock');
        }

        function createDigitalClockPrompt() {
            // This function is kept for backward compatibility but now uses the definition dictionary
            return SYSTEM_APPS_DEFINITIONS['Digital Clock'].prompt;
        }

        // Microphone test function
        async function testMicrophone() {
            let testStream = null;
            let audioContext = null;
            let analyser = null;
            let microphone = null;
            let dataArray = null;
            let animationId = null;
            
            try {
                // Create a modal dialog for the microphone test
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const testDialog = document.createElement('div');
                testDialog.style.cssText = `
                    background: white;
                    padding: 30px;
                    border-radius: 10px;
                    text-align: center;
                    max-width: 400px;
                    width: 90%;
                `;
                
                testDialog.innerHTML = `
                    <h3 style="margin: 0 0 20px 0; color: #333;">🎤 Microphone Test</h3>
                    <p style="margin: 0 0 20px 0; color: #666;">Speak into your microphone to test audio levels</p>
                    <div style="margin: 20px 0;">
                        <div id="mic-level-bar" style="
                            width: 100%;
                            height: 20px;
                            background: #f0f0f0;
                            border-radius: 10px;
                            overflow: hidden;
                            position: relative;
                        ">
                            <div id="mic-level-fill" style="
                                height: 100%;
                                background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
                                width: 0%;
                                transition: width 0.1s ease;
                            "></div>
                        </div>
                        <p id="mic-level-text" style="margin: 10px 0 0 0; font-size: 14px; color: #666;">Audio Level: 0%</p>
                    </div>
                    <div id="mic-status" style="margin: 20px 0; font-size: 14px; color: #666;">Requesting microphone access...</div>
                    <button id="close-mic-test" style="
                        background: #dc3545;
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                    ">Close Test</button>
                `;
                
                modal.appendChild(testDialog);
                document.body.appendChild(modal);
                
                const levelBar = document.getElementById('mic-level-fill');
                const levelText = document.getElementById('mic-level-text');
                const statusText = document.getElementById('mic-status');
                const closeBtn = document.getElementById('close-mic-test');
                
                // Close button handler
                closeBtn.addEventListener('click', () => {
                    cleanup();
                });
                
                // Click outside to close
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        cleanup();
                    }
                });
                
                function cleanup() {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    if (testStream) {
                        testStream.getTracks().forEach(track => track.stop());
                    }
                    if (audioContext) {
                        audioContext.close();
                    }
                    if (modal && modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                }
                
                // Request microphone access
                try {
                    testStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                    
                    statusText.textContent = 'Microphone access granted! Speak to see audio levels.';
                    statusText.style.color = '#28a745';
                    
                    // Set up audio analysis
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    microphone = audioContext.createMediaStreamSource(testStream);
                    
                    analyser.fftSize = 256;
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                    
                    microphone.connect(analyser);
                    
                    // Start monitoring audio levels
                    function updateAudioLevel() {
                        analyser.getByteFrequencyData(dataArray);
                        
                        // Calculate average volume
                        let sum = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            sum += dataArray[i];
                        }
                        const average = sum / bufferLength;
                        const percentage = Math.round((average / 255) * 100);
                        
                        // Update visual indicators
                        levelBar.style.width = percentage + '%';
                        levelText.textContent = `Audio Level: ${percentage}%`;
                        
                        // Color coding based on level
                        if (percentage < 10) {
                            levelBar.style.background = '#6c757d'; // Gray for very low
                        } else if (percentage < 30) {
                            levelBar.style.background = '#28a745'; // Green for good
                        } else if (percentage < 70) {
                            levelBar.style.background = '#ffc107'; // Yellow for moderate
                        } else {
                            levelBar.style.background = '#dc3545'; // Red for high
                        }
                        
                        // Update status based on audio level
                        if (percentage > 5) {
                            statusText.textContent = '✅ Microphone is working! Audio detected.';
                            statusText.style.color = '#28a745';
                        } else {
                            statusText.textContent = '🔇 Speak louder or check microphone settings.';
                            statusText.style.color = '#ffc107';
                        }
                        
                        animationId = requestAnimationFrame(updateAudioLevel);
                    }
                    
                    updateAudioLevel();
                    
                } catch (error) {
                    console.error('Microphone access failed:', error);
                    statusText.textContent = '❌ Microphone access denied or failed. Please check permissions.';
                    statusText.style.color = '#dc3545';
                    
                    // Show specific error messages
                    if (error.name === 'NotAllowedError') {
                        statusText.textContent = '❌ Microphone access denied. Please allow microphone access and try again.';
                    } else if (error.name === 'NotFoundError') {
                        statusText.textContent = '❌ No microphone found. Please connect a microphone and try again.';
                    } else if (error.name === 'NotReadableError') {
                        statusText.textContent = '❌ Microphone is being used by another application.';
                    }
                }
                
            } catch (error) {
                console.error('Failed to create microphone test dialog:', error);
                alert('Failed to start microphone test. Please try again.');
            }
        }

        // AI-Generated App Content Creator
        function createAIGeneratedAppContent(request, appId) {
            // Start LLM processing immediately
            setTimeout(() => processAppWithLLM(request, appId), 100);
            
            return `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                    <h2 style="margin: 0 0 30px 0; color: #333; font-weight: 300;">Creating your app</h2>
                    <div class="spinner" style="
                        width: 40px;
                        height: 40px;
                        border: 4px solid #f3f3f3;
                        border-top: 4px solid #0078d4;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                    "></div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
        }

        // AI-Generated App Content Creator with Images
        function createAIGeneratedAppContentWithImages(request, images, appId) {
            // Start LLM processing with images immediately
            setTimeout(() => processAppWithLLMAndImages(request, images, appId), 100);
            
            return `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                    <h2 style="margin: 0 0 20px 0; color: #333; font-weight: 300;">Creating your app</h2>
                    <p style="margin: 0 0 30px 0; color: #666;">Analyzing ${images.length} screenshot(s)...</p>
                    <div class="spinner" style="
                        width: 40px;
                        height: 40px;
                        border: 4px solid #f3f3f3;
                        border-top: 4px solid #0078d4;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                    "></div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
        }

        // LLM Processing Function
        async function processAppWithLLM(request, appId, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`🔄 Processing app with LLM (attempt ${retryCount + 1}/${maxRetries})`);
                
                // Create prompt for windowed app generation
                const prompt = createWindowedAppPrompt(request, appId);
                
                // Call LLM API
                const response = await callLLMAPI(prompt, request, 'App Creation Request', appId);
                
                if (response && response.html) {
                    console.log(`✅ LLM processing successful on attempt ${retryCount + 1}`);
                    
                    // Replace the placeholder content with the generated app
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Auto-size and center the window based on content
                        setTimeout(() => {
                            autoSizeAndCenterWindow(appId);
                        }, 100);
                        
                        // Update app title if provided
                        if (response.title) {
                            updateAppTitle(appId, response.title);
                        }
                        
                        // Update app icon if provided
                        if (response.icon) {
                            updateAppIcon(appId, response.icon);
                        }
                    }
                } else {
                    throw new Error('Invalid response from LLM - missing HTML content');
                }
                
            } catch (error) {
                console.error(`❌ LLM processing failed (attempt ${retryCount + 1}):`, error);
                
                // Don't retry if it's a configuration error
                const isConfigError = error.message.includes('not configured') ||
                                    error.message.includes('API key') ||
                                    error.message.includes('URL not configured');
                
                // Check if we should retry
                if (retryCount < maxRetries - 1 && !isConfigError) {
                    console.log(`🔄 Retrying in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">🔄 Retrying...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppWithLLM(request, appId, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`💥 All ${maxRetries} attempts failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">❌ Error</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        async function processAppWithLLMAndImages(request, images, appId, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`🔄 Processing app with images (attempt ${retryCount + 1}/${maxRetries})`);
                
                // Create prompt for windowed app generation with images
                let prompt = createWindowedAppPrompt(request, appId);
                
                // Add image context
                if (images && images.length > 0) {
                    prompt += `\n\nIMAGE CONTEXT:\nThe user has provided ${images.length} screenshot(s) to help with app creation. Please analyze the provided images and incorporate any relevant visual information, UI elements, design patterns, or functionality shown in the screenshots into your app creation.`;
                }
                
                // Call LLM API with images
                const response = await callLLMAPIWithImages(prompt, request, images, 'App Creation Request with Images', appId);
                
                if (response && response.html) {
                    console.log(`✅ LLM processing with images successful on attempt ${retryCount + 1}`);
                    
                    // Replace the placeholder content with the generated app
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Auto-size and center the window based on content
                        setTimeout(() => {
                            autoSizeAndCenterWindow(appId);
                        }, 100);
                        
                        // Update app title if provided
                        if (response.title) {
                            updateAppTitle(appId, response.title);
                        }
                        
                        // Update app icon if provided
                        if (response.icon) {
                            updateAppIcon(appId, response.icon);
                        }
                    }
                } else {
                    throw new Error('Invalid response from LLM - missing HTML content');
                }
                
            } catch (error) {
                console.error(`❌ LLM processing with images failed (attempt ${retryCount + 1}):`, error);
                
                // Don't retry if it's a configuration error
                const isConfigError = error.message.includes('not configured') ||
                                    error.message.includes('API key') ||
                                    error.message.includes('URL not configured');
                
                // Check if we should retry
                if (retryCount < maxRetries - 1 && !isConfigError) {
                    console.log(`🔄 Retrying in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">🔄 Retrying...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppWithLLMAndImages(request, images, appId, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`💥 All ${maxRetries} attempts failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">❌ Error</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        function createWindowedAppPrompt(request, appId) {
            // Get current theme
            const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
            
            let prompt = ROLE_PROMPT + 
                         APPCREATION_PROMPT.replace(/{appId}/g, appId) +
                         NAMESPACEISOLATION_GUIDELINES.replace(/{appId}/g, appId) +
                         CSS_GUIDELINES.replace(/{currentTheme}/g, currentTheme) +
                         JAVASCRIPT_GUIDELINES.replace(/{appId}/g, appId) +
                         "Now create a functional app for: " + request;
  
            return prompt;
        }

        // Function to show prompt history for an app
        function showPromptHistory(appId) {
            const app = apps.find(a => a.id === appId);
            if (!app || !app.promptHistory || app.promptHistory.length === 0) {
                alert('No prompt history available for this app.');
                return;
            }

            // Create a modal window to display the prompt history
            const modal = document.createElement('div');
            modal.className = 'prompt-history-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 20px;
                max-width: 80%;
                max-height: 80%;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            `;

            // Apply theme to modal
            if (document.body.classList.contains('dark-theme')) {
                modalContent.style.background = '#2c3e50';
                modalContent.style.color = '#f8f9fa';
            }

            let historyHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">📜 Prompt History - ${app.title}</h2>
                    <button onclick="this.closest('.prompt-history-modal').remove()" style="
                        background: #dc3545;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        padding: 8px 12px;
                        cursor: pointer;
                        font-size: 16px;
                    ">×</button>
                </div>
                <div style="margin-bottom: 15px; color: #666;">
                    Total prompts: ${app.promptHistory.length}
                </div>
            `;

            app.promptHistory.forEach((entry, index) => {
                const typeIcon = entry.type === 'creation' ? '🆕' : '✏️';
                const typeLabel = entry.type === 'creation' ? 'Creation' : 'Edit';
                
                historyHTML += `
                    <div style="
                        border: 1px solid #ddd;
                        border-radius: 6px;
                        margin-bottom: 15px;
                        padding: 15px;
                        background: ${document.body.classList.contains('dark-theme') ? '#34495e' : '#f8f9fa'};
                    ">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong>${typeIcon} ${typeLabel} #${index + 1}</strong>
                            <span style="color: #666; font-size: 14px;">${entry.date}</span>
                        </div>
                        ${entry.userRequest ? `
                            <div style="margin-bottom: 10px;">
                                <strong>User Request:</strong>
                                <div style="
                                    background: ${document.body.classList.contains('dark-theme') ? '#495057' : '#e9ecef'};
                                    padding: 8px;
                                    border-radius: 4px;
                                    margin-top: 5px;
                                    font-family: monospace;
                                    font-size: 14px;
                                ">${entry.userRequest}</div>
                            </div>
                        ` : ''}
                        <div>
                            <strong>Full Prompt:</strong>
                            <div style="
                                background: ${document.body.classList.contains('dark-theme') ? '#495057' : '#e9ecef'};
                                padding: 10px;
                                border-radius: 4px;
                                margin-top: 5px;
                                font-family: monospace;
                                font-size: 12px;
                                max-height: 200px;
                                overflow-y: auto;
                                white-space: pre-wrap;
                                word-wrap: break-word;
                            ">${entry.prompt}</div>
                        </div>
                    </div>
                `;
            });

            modalContent.innerHTML = historyHTML;
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Function to record a prompt in an app's history
        function recordPromptInHistory(appId, prompt, type = 'creation', userRequest = '') {
            const app = apps.find(a => a.id === appId);
            if (app) {
                if (!app.promptHistory) {
                    app.promptHistory = [];
                }
                
                const historyEntry = {
                    timestamp: new Date().toISOString(),
                    type: type, // 'creation' or 'edit'
                    userRequest: userRequest,
                    prompt: prompt,
                    date: new Date().toLocaleString()
                };
                
                app.promptHistory.push(historyEntry);
                console.log(`Recorded ${type} prompt for app ${appId}:`, historyEntry);
            }
        }


        function escapeJsonString(str) {
            return str
                .replace(/\\/g, '\\\\')     // Escape backslashes
                .replace(/"/g, '\\"');      // Escape double quotes
            }

function escapeJsonString(str) {
    return str
        .replace(/\\/g, '\\\\')      // Escape backslash
        .replace(/"/g, '\\"')        // Escape double quote
        .replace(/\n/g, '\\n')       // Escape newline
        .replace(/\r/g, '\\r')       // Escape carriage return
        .replace(/\t/g, '\\t');      // Escape tab
}

function sanitizeJsonCodeFields(jsonStr) {
    // First try to parse directly
    try {
        JSON.parse(jsonStr);
        return jsonStr; // If valid JSON, return as is
    } catch (e) {
        // Proceed to sanitize if JSON is malformed
    }

    // Regex to extract key-value pairs with string values
    const fieldRegex = /"(\w+)"\s*:\s*"((?:\\.|[^"\\])*)"/gs;

    const sanitized = jsonStr.replace(fieldRegex, (match, key, value) => {
        if (["javascript", "html", "css"].includes(key)) {
            // First unescape to get raw code
            const unescaped = value
                .replace(/\\\\/g, '\\')   // unescape backslashes
                .replace(/\\"/g, '"')     // unescape double quotes
                .replace(/\\n/g, '\n')    // unescape newlines
                .replace(/\\r/g, '\r')    // unescape carriage returns
                .replace(/\\t/g, '\t');   // unescape tabs

            // Then escape properly again
            const reescaped = escapeJsonString(unescaped);
            return `"${key}": "${reescaped}"`;
        }
        return match;
    });

    // Final parse attempt after sanitization
    return sanitized;
}




        async function callLLMAPI(prompt, userRequest = '', description = 'API Request', appId = null) {
            // If appId is provided, append the ID prefixing prompt add-on
            if (appId) {
                
                // Record the prompt in the app's history
                const promptType = description.includes('Edit') ? 'edit' : 'creation';
                recordPromptInHistory(appId, prompt, promptType, userRequest);
            }
            
            // Check if provider is properly configured
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' && (!CONFIG.OPENROUTER_API_KEY || CONFIG.OPENROUTER_API_KEY === 'sk-...')) {
                throw new Error('OpenRouter API key not configured');
            }
            
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openai' && (!CONFIG.OPENROUTER_API_KEY || CONFIG.OPENROUTER_API_KEY === 'sk-proj-...')) {
                throw new Error('OpenAI API key not configured');
            }
            
            if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio' && (!CONFIG.OPENROUTER_URL || CONFIG.OPENROUTER_URL === 'https://openrouter.ai/api/v1/chat/completions')) {
                throw new Error('LMStudio URL not configured');
            }
            
            // Prepare headers based on current provider
            let headers = {
                'Content-Type': 'application/json'
            };
            
            // Add provider-specific headers
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter') {
                headers['Authorization'] = `Bearer ${CONFIG.OPENROUTER_API_KEY}`;
                headers['HTTP-Referer'] = window.location.origin;
                headers['X-Title'] = 'Self-Evolving OS';
            } else if (CONFIG.CURRENT_LLM_PROVIDER === 'openai') {
                headers['Authorization'] = `Bearer ${CONFIG.OPENROUTER_API_KEY}`; // Reused config key
            } else if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio') {
                // LMStudio typically doesn't require authorization header
                // headers['Authorization'] is not needed
            }
            
            const requestBody = {
                model: CONFIG.MODEL,
                messages: [{ role: 'user', content: prompt }]
            };
            
            // Use the correct parameters based on provider
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openai') {
                requestBody.max_completion_tokens = 16000;
                // OpenAI models may not support custom temperature, use default (1)
                requestBody.temperature = 1;
            } else {
                requestBody.max_tokens = 32000;
                requestBody.temperature = 0.7;
            }
            
            // Debug logging for LMStudio
            if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio') {
                console.log('LMStudio API Request:', {
                    url: CONFIG.OPENROUTER_URL,
                    headers: headers,
                    body: requestBody,
                    bodyString: JSON.stringify(requestBody)
                });
            }
            
            const response = await fetch(CONFIG.OPENROUTER_URL, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`API request failed for ${CONFIG.CURRENT_LLM_PROVIDER}:`, {
                    status: response.status,
                    statusText: response.statusText,
                    errorText: errorText,
                    url: CONFIG.OPENROUTER_URL,
                    requestBody: requestBody
                });
                throw new Error(`API request failed: ${response.status} - ${response.statusText}: ${errorText}`);
            }

            const data = await response.json();
            
            // Extract cost information from response
            updateCostDisplay(data, description, userRequest);
            
            content = data.choices[0].message.content;
            
            content = content.replace(/^```json\s*/, '').replace(/\s*```$/, '');
            content = sanitizeJsonCodeFields(content);

            // Try full parse
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (!jsonMatch) throw new Error("Invalid response format - no JSON found");

            try {
                return JSON.parse(jsonMatch[0]);
            } catch (initialError) {
                console.log(content);
                console.warn('First JSON parse attempt failed:', initialError.message);
                
                // Try multiple nested-looking JSON objects
                const jsonBlocks = content.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
                if (jsonBlocks) {
                    for (const block of jsonBlocks) {
                        try {
                            const parsed = JSON.parse(block);
                            if (parsed.title && parsed.html) {
                                return parsed;
                            }
                        } catch {}
                    }
                }

                // No auto-cleaning step here: better to surface the real error
                throw new Error(`JSON parsing failed: ${initialError.message}`);
            }
        }

        async function callLLMAPIWithImages(prompt, userRequest = '', images = [], description = 'API Request with Images', appId = null) {
            // If appId is provided, record the prompt in the app's history
            if (appId) {
                const promptType = description.includes('Edit') ? 'edit' : 'creation';
                recordPromptInHistory(appId, prompt, promptType, userRequest);
            }
            
            // Check if provider is properly configured
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter' && (!CONFIG.OPENROUTER_API_KEY || CONFIG.OPENROUTER_API_KEY === 'sk-...')) {
                throw new Error('OpenRouter API key not configured');
            }
            
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openai' && (!CONFIG.OPENROUTER_API_KEY || CONFIG.OPENROUTER_API_KEY === 'sk-proj-...')) {
                throw new Error('OpenAI API key not configured');
            }
            
            if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio' && (!CONFIG.OPENROUTER_URL || CONFIG.OPENROUTER_URL === 'https://openrouter.ai/api/v1/chat/completions')) {
                throw new Error('LMStudio URL not configured');
            }
            
            // Prepare headers based on current provider
            let headers = {
                'Content-Type': 'application/json'
            };
            
            // Add provider-specific headers
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openrouter') {
                headers['Authorization'] = `Bearer ${CONFIG.OPENROUTER_API_KEY}`;
                headers['HTTP-Referer'] = window.location.origin;
                headers['X-Title'] = 'Self-Evolving OS';
            } else if (CONFIG.CURRENT_LLM_PROVIDER === 'openai') {
                headers['Authorization'] = `Bearer ${CONFIG.OPENROUTER_API_KEY}`; // Reused config key
            } else if (CONFIG.CURRENT_LLM_PROVIDER === 'lmstudio') {
                // LMStudio typically doesn't require authorization header
                // headers['Authorization'] is not needed
            }
            
            // Prepare messages with images
            const messages = [];
            
            // Add the main prompt
            const messageContent = [
                {
                    type: "text",
                    text: prompt
                }
            ];
            
            // Add images if provided
            if (images && images.length > 0) {
                console.log(`Adding ${images.length} images to the request`);
                images.forEach((imageData, index) => {
                    messageContent.push({
                        type: "image_url",
                        image_url: {
                            url: imageData.base64,
                            detail: "high"
                        }
                    });
                    console.log(`Added image ${index + 1}: ${imageData.name}`);
                });
            }
            
            messages.push({
                role: 'user',
                content: messageContent
            });
            
            const requestBody = {
                model: CONFIG.MODEL,
                messages: messages
            };
            
            // Use the correct parameters based on provider
            if (CONFIG.CURRENT_LLM_PROVIDER === 'openai') {
                requestBody.max_completion_tokens = 16000;
                requestBody.temperature = 1;
            } else {
                requestBody.max_tokens = 32000;
                requestBody.temperature = 0.7;
            }
            
            console.log('Sending request with images to LLM:', {
                provider: CONFIG.CURRENT_LLM_PROVIDER,
                model: CONFIG.MODEL,
                imageCount: images.length,
                promptLength: prompt.length
            });
            
            const response = await fetch(CONFIG.OPENROUTER_URL, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`API request with images failed for ${CONFIG.CURRENT_LLM_PROVIDER}:`, {
                    status: response.status,
                    statusText: response.statusText,
                    errorText: errorText,
                    url: CONFIG.OPENROUTER_URL,
                    imageCount: images.length
                });
                throw new Error(`API request failed: ${response.status} - ${response.statusText}: ${errorText}`);
            }

            const data = await response.json();
            
            // Extract cost information from response
            updateCostDisplay(data, description, userRequest);
            
            let content = data.choices[0].message.content;
            
            content = content.replace(/^```json\s*/, '').replace(/\s*```$/, '');
            content = sanitizeJsonCodeFields(content);

            // Try full parse
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (!jsonMatch) throw new Error("Invalid response format - no JSON found");

            try {
                return JSON.parse(jsonMatch[0]);
            } catch (initialError) {
                console.log(content);
                console.warn('First JSON parse attempt failed:', initialError.message);
                
                // Try multiple nested-looking JSON objects
                const jsonBlocks = content.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
                if (jsonBlocks) {
                    for (const block of jsonBlocks) {
                        try {
                            const parsed = JSON.parse(block);
                            if (parsed.title && parsed.html) {
                                return parsed;
                            }
                        } catch {}
                    }
                }

                // No auto-cleaning step here: better to surface the real error
                throw new Error(`JSON parsing failed: ${initialError.message}`);
            }
        }

        // Global cost tracking
        let totalCost = 0;

        function updateCostDisplay(responseData, description = 'API Request', prompt = '') {
            try {
                // OpenRouter includes usage information in the response
                if (responseData.usage) {
                    const usage = responseData.usage;
                    
                    // Calculate cost based on token usage
                    // These are approximate rates - OpenRouter may provide exact costs in headers
                    const promptTokens = usage.prompt_tokens || 0;
                    const completionTokens = usage.completion_tokens || 0;
                    
                    // Approximate cost calculation (Claude 3.5 Sonnet rates)
                    const promptCost = (promptTokens / 1000000) * 3.00; // $3 per 1M input tokens
                    const completionCost = (completionTokens / 1000000) * 15.00; // $15 per 1M output tokens
                    const requestCost = promptCost + completionCost;
                    
                    totalCost += requestCost;
                    
                    // Add to cost tracking history
                    addCostEntry(requestCost, description, prompt);
                    
                    // Update display
                    const costElement = document.getElementById('api-cost');
                    if (costElement) {
                        costElement.textContent = totalCost.toFixed(4);
                    }
                    
                    console.log(`Request cost: $${requestCost.toFixed(4)}, Total cost: $${totalCost.toFixed(4)}`);
                }
            } catch (error) {
                console.warn('Could not calculate API cost:', error);
            }
        }

        // Helper function to update cost without response data
        function updateCost(cost, description = 'Manual Update', prompt = '') {
            totalCost += cost;
            
            // Add to cost tracking history
            addCostEntry(cost, description, prompt);
            
            // Update display
            const costElement = document.getElementById('api-cost');
            if (costElement) {
                costElement.textContent = totalCost.toFixed(4);
            }
        }


        function addAppCSS(css, appId) {
            const styleElement = document.createElement('style');
            styleElement.id = `style-${appId}`;
            
            // Apply namespace isolation to CSS
            const namespacedCSS = namespaceCSS(css, appId);
            styleElement.textContent = namespacedCSS;
            document.head.appendChild(styleElement);
        }

        function namespaceCSS(css, appId) {
            // Scope all CSS rules to the app container with theme inheritance
            const containerSelector = `#content_${appId}`;
            
            // Add theme-aware base styles for the app container
            const themeBaseStyles = `
/* Theme-aware base styles for app ${appId} */
${containerSelector} {
    color: inherit;
    background: inherit;
}

/* Light theme styles */
.app-light-theme ${containerSelector} {
    background: #ffffff;
    color: #212529;
}

.app-light-theme ${containerSelector} input,
.app-light-theme ${containerSelector} textarea,
.app-light-theme ${containerSelector} select {
    background: #ffffff;
    color: #212529;
    border: 1px solid #ced4da;
}

.app-light-theme ${containerSelector} button {
    background: #007bff;
    color: #ffffff;
    border: 1px solid #007bff;
}

.app-light-theme ${containerSelector} button:hover {
    background: #0056b3;
    border-color: #0056b3;
}

/* Dark theme styles */
.app-dark-theme ${containerSelector} {
    background: #2c3e50;
    color: #f8f9fa;
}

.app-dark-theme ${containerSelector} input,
.app-dark-theme ${containerSelector} textarea,
.app-dark-theme ${containerSelector} select {
    background: #495057;
    color: #f8f9fa;
    border: 1px solid #6c757d;
}

.app-dark-theme ${containerSelector} button {
    background: #0d6efd;
    color: #ffffff;
    border: 1px solid #0d6efd;
}

.app-dark-theme ${containerSelector} button:hover {
    background: #0b5ed7;
    border-color: #0b5ed7;
}
            `;
            
            // Split CSS into rules and namespace each one
            const rules = css.split('}').filter(rule => rule.trim());
            const namespacedRules = rules.map(rule => {
                if (!rule.trim()) return '';
                
                const [selectors, declarations] = rule.split('{');
                if (!selectors || !declarations) return rule + '}';
                
                // Process each selector
                const processedSelectors = selectors.split(',').map(selector => {
                    const trimmedSelector = selector.trim();
                    if (!trimmedSelector) return selector;
                    
                    // Skip @media, @keyframes, and other @ rules
                    if (trimmedSelector.startsWith('@')) return selector;
                    
                    // Add container scope to each selector
                    return `${containerSelector} ${trimmedSelector}`;
                }).join(', ');
                
                return `${processedSelectors} {${declarations}}`;
            });
            
            // Combine theme base styles with namespaced app styles
            return themeBaseStyles + '\n' + namespacedRules.join('\n');
        }

        function executeAppJavaScript(javascript, appId) {
            let namespacedJS = '';
            try {
                // Store the JavaScript in a script element for later retrieval
                const scriptElement = document.createElement('script');
                scriptElement.id = `script-${appId}`;
                scriptElement.type = 'text/plain'; // Don't execute it as a script
                scriptElement.textContent = javascript;
                document.head.appendChild(scriptElement);
                
                // Apply namespace isolation to JavaScript
                const helperFunctions = createAppHelperFunctions(appId);
                namespacedJS = namespaceJavaScript(javascript, appId, helperFunctions);
                
                // Execute JavaScript in global scope so it can access document and DOM
                eval(namespacedJS);
            } catch (error) {
                console.log('Original JavaScript:', javascript);
                console.log('Namespaced JavaScript:', namespacedJS);
                console.error(`JavaScript execution failed for app ${appId}:`, error);
                throw new Error(`JavaScript execution failed for app ${appId}: ${error.message}`);
            }
        }

        function namespaceJavaScript(javascript, appId, helperFunctions = '') {
            // Wrap JavaScript in an IIFE with app namespace
            const namespacedJS = `
(function(appId) {
    // Create app-specific namespace
    appNamespace = 'app_' + appId.replace(/-/g, '_');
    window[appNamespace] = window[appNamespace] || {};
    
    ${helperFunctions}
    
    // Legacy helper functions for backward compatibility
    const getElementById = (id) => document.getElementById(appId + '_' + id);
    const querySelector = (selector) => document.querySelector('#content_' + appId + ' ' + selector);
    const querySelectorAll = (selector) => document.querySelectorAll('#content_' + appId + ' ' + selector);
    
    // Custom event helpers with namespace
    const dispatchAppEvent = (eventName, detail) => {
        document.dispatchEvent(new CustomEvent(appId + ':' + eventName, { detail }));
    };
    
    const addAppEventListener = (eventName, handler) => {
        document.addEventListener(appId + ':' + eventName, handler);
    };
    
    // Execute the app's JavaScript code
    ${javascript}
    
})('${appId}');
            `;
            
            return namespacedJS;
        }

        function updateAppTitle(appId, newTitle) {
            const app = apps.find(a => a.id === appId);
            if (app) {
                app.title = newTitle;
                
                // Update window title text
                const windowTitleTextElement = document.querySelector(`#window_${appId} .window-title-text`);
                if (windowTitleTextElement) {
                    windowTitleTextElement.textContent = newTitle;
                }
                
                // Update taskbar icon tooltip
                const iconElement = document.getElementById(`icon_${appId}`);
                if (iconElement) {
                    iconElement.title = newTitle;
                }
            }
        }

        function updateAppIcon(appId, newIcon) {
            const app = apps.find(a => a.id === appId);
            if (app) {
                app.icon = newIcon;
                
                // Update window header icon
                const windowIconElement = document.querySelector(`#window_${appId} .window-icon`);
                if (windowIconElement) {
                    windowIconElement.textContent = newIcon;
                }
                
                // Update taskbar icon
                const taskbarIconElement = document.querySelector(`#icon_${appId} .taskbar-icon`);
                if (taskbarIconElement) {
                    taskbarIconElement.textContent = newIcon;
                }
                
                // Update apps submenu if it's currently visible
                const submenu = document.getElementById('apps-submenu');
                if (submenu && submenu.classList.contains('show')) {
                    updateAppsSubmenuContent();
                }
                
                console.log(`Updated app ${appId} icon to: ${newIcon}`);
            }
        }

        function autoSizeAndCenterWindow(appId) {
            const windowElement = document.getElementById(`window_${appId}`);
            const contentElement = document.getElementById(`content_${appId}`);
            
            if (!windowElement || !contentElement) return;
            
            // Temporarily make content visible and remove size constraints to measure it properly
            const originalDisplay = contentElement.style.display;
            const originalVisibility = contentElement.style.visibility;
            const originalWindowWidth = windowElement.style.width;
            const originalWindowHeight = windowElement.style.height;
            
            // Set content to be fully visible for measurement
            contentElement.style.display = 'block';
            contentElement.style.visibility = 'visible';
            
            // Temporarily set window to auto size to get natural content dimensions
            windowElement.style.width = 'auto';
            windowElement.style.height = 'auto';
            
            // Force a reflow to get accurate measurements
            windowElement.offsetHeight;
            
            // Get the natural size of the content after it's fully rendered
            const contentRect = contentElement.getBoundingClientRect();
            const windowHeaderHeight = 50; // Window header height
            const padding = 40; // Extra padding for better appearance
            const osHeaderHeight = 50; // OS header height
            
            // Calculate optimal window size with generous limits
            const maxAvailableWidth = window.innerWidth - 100; // Leave 50px margin on each side
            const maxAvailableHeight = window.innerHeight - osHeaderHeight - 100; // Leave space for OS header and margins
            
            let optimalWidth = Math.max(350, Math.min(maxAvailableWidth, contentRect.width + padding));
            let optimalHeight = Math.max(250, Math.min(maxAvailableHeight, contentRect.height + windowHeaderHeight + padding));
            
            // Update window size
            windowElement.style.width = optimalWidth + 'px';
            windowElement.style.height = optimalHeight + 'px';
            
            // Center the window in the desktop area
            const desktop = document.getElementById('desktop');
            const desktopRect = desktop.getBoundingClientRect();
            const availableWidth = desktopRect.width;
            const availableHeight = desktopRect.height;
            
            const centerX = Math.max(10, (availableWidth - optimalWidth) / 2);
            const centerY = Math.max(10, (availableHeight - optimalHeight) / 2);
            
            windowElement.style.left = centerX + 'px';
            windowElement.style.top = centerY + 'px';
            
            // Restore original content state
            contentElement.style.display = originalDisplay;
            contentElement.style.visibility = originalVisibility;
        }

        function regenerateApp(appId) {
            const app = apps.find(a => a.id === appId);
            if (app && app.customRequest) {
                processAppWithLLM(app.customRequest, appId);
            }
        }

        function modifyApp(appId, modificationRequest) {
            console.log(`Modifying app ${appId} with request: ${modificationRequest}`);
            
            const app = apps.find(a => a.id === appId);
            if (!app) {
                console.error(`App ${appId} not found`);
                return;
            }
            
            // Extract current app code
            const appContentElement = document.getElementById(`content_${appId}`);
            const currentHTML = appContentElement ? appContentElement.innerHTML : '';
            
            // Extract current CSS for this app
            const currentStyleElement = document.getElementById(`style-${appId}`);
            const currentCSS = currentStyleElement ? currentStyleElement.textContent : '';
            
            // Extract current JavaScript for this app
            const currentScriptElement = document.getElementById(`script-${appId}`);
            const currentJavaScript = currentScriptElement ? currentScriptElement.textContent : '';
            
            console.log(`📄 Current HTML length: ${currentHTML.length}`);
            console.log(`🎨 Current CSS length: ${currentCSS.length}`);
            console.log(`⚙️ Current JavaScript length: ${currentJavaScript.length}`);
            
            let thisAppPromptHistory = ''
            app.promptHistory.slice(1).forEach((entry, index) => {
                thisAppPromptHistory += `\n\nPrompt #${index + 1} (${entry.type}):\n${entry.userRequest}`;
            });

            // Create a modification prompt that includes the current app code
            // Use string concatenation to avoid template literal issues
            const modificationPrompt = ROLE_PROMPT +
                APPMODIFY_PROMPT.replace(/{appId}/g, appId)
                    .replace(/{appTitle}/g, app.title)
                    .replace(/{modificationRequest}/g, modificationRequest)
                    .replace(/{promptHistory}/g, thisAppPromptHistory)
                    .replace(/{currentHTML}/g, currentHTML)
                    .replace(/{currentCSS}/g, currentCSS)
                    .replace(/{currentJavaScript}/g, currentJavaScript);

            // Show loading state
            const contentElement = document.getElementById(`content_${appId}`);
            if (contentElement) {
                contentElement.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                        <h2 style="margin: 0 0 30px 0; color: #333; font-weight: 300;">Modifying your app</h2>
                        <div class="spinner" style="
                            width: 40px;
                            height: 40px;
                            border: 4px solid #f3f3f3;
                            border-top: 4px solid #0078d4;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                        "></div>
                    </div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `;
            }
            
            // Process the modification with LLM
            processAppModificationWithLLM(modificationPrompt, appId, modificationRequest);
        }

        function modifyAppWithImages(appId, modificationData) {
            console.log(`Modifying app ${appId} with request: ${modificationData.text}`);
            console.log(`Including ${modificationData.images.length} images`);
            
            const app = apps.find(a => a.id === appId);
            if (!app) {
                console.error(`App ${appId} not found`);
                return;
            }
            
            // Extract current app code
            const appContentElement = document.getElementById(`content_${appId}`);
            const currentHTML = appContentElement ? appContentElement.innerHTML : '';
            
            // Extract current CSS for this app
            const currentStyleElement = document.getElementById(`style-${appId}`);
            const currentCSS = currentStyleElement ? currentStyleElement.textContent : '';
            
            // Extract current JavaScript for this app
            const currentScriptElement = document.getElementById(`script-${appId}`);
            const currentJavaScript = currentScriptElement ? currentScriptElement.textContent : '';
            
            console.log(`📄 Current HTML length: ${currentHTML.length}`);
            console.log(`🎨 Current CSS length: ${currentCSS.length}`);
            console.log(`⚙️ Current JavaScript length: ${currentJavaScript.length}`);
            
            let thisAppPromptHistory = ''
            app.promptHistory.slice(1).forEach((entry, index) => {
                thisAppPromptHistory += `\n\nPrompt #${index + 1} (${entry.type}):\n${entry.userRequest}`;
            });

            // Create a modification prompt that includes the current app code
            let modificationPrompt = ROLE_PROMPT +
                APPMODIFY_PROMPT.replace(/{appId}/g, appId)
                    .replace(/{appTitle}/g, app.title)
                    .replace(/{modificationRequest}/g, modificationData.text)
                    .replace(/{promptHistory}/g, thisAppPromptHistory)
                    .replace(/{currentHTML}/g, currentHTML)
                    .replace(/{currentCSS}/g, currentCSS)
                    .replace(/{currentJavaScript}/g, currentJavaScript);

            // Add image context if images are provided
            if (modificationData.images && modificationData.images.length > 0) {
                modificationPrompt += `\n\nIMAGE CONTEXT:\nThe user has provided ${modificationData.images.length} screenshot(s) to help with the modification. Please analyze the provided images and incorporate any relevant visual information, UI elements, or design patterns shown in the screenshots into your modification of the app.`;
            }

            // Show loading state
            const contentElement = document.getElementById(`content_${appId}`);
            if (contentElement) {
                contentElement.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                        <h2 style="margin: 0 0 30px 0; color: #333; font-weight: 300;">Modifying your app</h2>
                        ${modificationData.images.length > 0 ? `<p style="margin: 0 0 20px 0; color: #666;">Analyzing ${modificationData.images.length} screenshot(s)...</p>` : ''}
                        <div class="spinner" style="
                            width: 40px;
                            height: 40px;
                            border: 4px solid #f3f3f3;
                            border-top: 4px solid #0078d4;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                        "></div>
                    </div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `;
            }
            
            // Process the modification with LLM, including images
            processAppModificationWithLLMAndImages(modificationPrompt, appId, modificationData.text, modificationData.images);
        }

        async function processAppModificationWithLLM(prompt, appId, modificationRequest, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`🔄 Processing app modification (attempt ${retryCount + 1}/${maxRetries}) for app ${appId}`);
                
                // Call LLM API with the modification prompt
                const response = await callLLMAPI(prompt, modificationRequest, 'App Edit Request', appId);
                console.log('Modification response:', response);
                
                if (response && response.html) {
                    console.log(`✅ App modification successful on attempt ${retryCount + 1}`);
                    
                    // Update the app content
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Keep the original request but add modification history
                        const app = apps.find(a => a.id === appId);
                        if (app) {
                            if (!app.modificationHistory) {
                                app.modificationHistory = [];
                            }
                            app.modificationHistory.push({
                                request: modificationRequest,
                                timestamp: new Date().toISOString()
                            });
                            // Update the current state to reflect the latest modification
                            app.lastModification = modificationRequest;
                        }
                        
                        // Note: App title and icon are preserved during editing
                        
                        console.log(`App ${appId} successfully modified`);
                    }
                } else {
                    throw new Error('Invalid modification response - missing HTML content');
                }
                
            } catch (error) {
                console.error(`❌ App modification failed (attempt ${retryCount + 1}):`, error);
                
                // Don't retry if it's a configuration error
                const isConfigError = error.message.includes('not configured') ||
                                    error.message.includes('API key') ||
                                    error.message.includes('URL not configured');
                
                // Check if we should retry
                if (retryCount < maxRetries - 1 && !isConfigError) {
                    console.log(`🔄 Retrying modification in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">🔄 Retrying Modification...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppModificationWithLLM(prompt, appId, modificationRequest, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`💥 All ${maxRetries} modification attempts failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">❌ Modification Failed</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        async function processAppModificationWithLLMAndImages(prompt, appId, modificationRequest, images, retryCount = 0) {
            const maxRetries = 3;
            
            try {
                debugLog(`🔄 Processing app modification with images (attempt ${retryCount + 1}/${maxRetries}) for app ${appId}`);
                
                // Call LLM API with the modification prompt and images
                const response = await callLLMAPIWithImages(prompt, modificationRequest, images, 'App Edit Request with Images', appId);
                console.log('Modification response:', response);
                
                if (response && response.html) {
                    console.log(`✅ App modification with images successful on attempt ${retryCount + 1}`);
                    
                    // Update the app content
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = response.html;
                        
                        // Add CSS if provided
                        if (response.css) {
                            addAppCSS(response.css, appId);
                        }
                        
                        // Execute JavaScript if provided
                        if (response.javascript) {
                            executeAppJavaScript(response.javascript, appId);
                        }
                        
                        // Keep the original request but add modification history
                        const app = apps.find(a => a.id === appId);
                        if (app) {
                            if (!app.modificationHistory) {
                                app.modificationHistory = [];
                            }
                            app.modificationHistory.push({
                                request: modificationRequest,
                                timestamp: new Date().toISOString(),
                                hasImages: true,
                                imageCount: images.length
                            });
                            // Update the current state to reflect the latest modification
                            app.lastModification = modificationRequest;
                        }
                        
                        // Note: App title and icon are preserved during editing
                        
                        console.log(`App ${appId} successfully modified with ${images.length} images`);
                    }
                } else {
                    throw new Error('Invalid modification response - missing HTML content');
                }
                
            } catch (error) {
                console.error(`❌ App modification with images failed (attempt ${retryCount + 1}):`, error);
                
                // Don't retry if it's a configuration error
                const isConfigError = error.message.includes('not configured') ||
                                    error.message.includes('API key') ||
                                    error.message.includes('URL not configured');
                
                // Check if we should retry
                if (retryCount < maxRetries - 1 && !isConfigError) {
                    console.log(`🔄 Retrying modification with images in 2 seconds... (${retryCount + 2}/${maxRetries})`);
                    
                    // Show retry status
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h3 style="margin: 0 0 15px 0; color: #ffc107;">🔄 Retrying Modification...</h3>
                                <p style="color: #666; margin: 0 0 10px 0;">Attempt ${retryCount + 2} of ${maxRetries}</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">Previous error: ${error.message}</p>
                            </div>
                        `;
                    }
                    
                    // Retry after 2 seconds
                    setTimeout(() => {
                        processAppModificationWithLLMAndImages(prompt, appId, modificationRequest, images, retryCount + 1);
                    }, 2000);
                    
                } else {
                    // All retries exhausted, show final error
                    console.error(`💥 All ${maxRetries} modification attempts with images failed for app ${appId}`);
                    const contentElement = document.getElementById(`content_${appId}`);
                    if (contentElement) {
                        contentElement.innerHTML = `
                            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; text-align: center; padding: 40px;">
                                <h2 style="margin: 0 0 20px 0; color: #dc3545;">❌ Modification Failed</h2>
                                <p style="color: #666; margin: 0 0 15px 0;">Failed after ${maxRetries} attempts</p>
                                <p style="color: #999; font-size: 14px; margin: 0;">${error.message}</p>
                            </div>
                        `;
                    }
                }
            }
        }

        function updateAppCSS(css, appId) {
            // Remove existing app-specific CSS
            const existingStyle = document.getElementById(`style-${appId}`);
            if (existingStyle) {
                existingStyle.remove();
            }
            
            // Add new CSS
            if (css) {
                addAppCSS(css, appId);
            }
        }

        function updateAppJavaScript(javascript, appId) {
            // Remove existing app-specific JavaScript
            const existingScript = document.getElementById(`script-${appId}`);
            if (existingScript) {
                existingScript.remove();
            }
            
            // Add new JavaScript
            if (javascript) {
                const scriptElement = document.createElement('script');
                scriptElement.id = `script-${appId}`;
                scriptElement.textContent = javascript;
                document.head.appendChild(scriptElement);
            }
        }

        function showSettings() {
            const settingsContent = `
                <div class="settings-container">
                    <h2 id="settings-main-title" style="margin: 0 0 20px 0; color: #333; border-bottom: 2px solid #0078d4; padding-bottom: 10px;">⚙️ Settings</h2>
                    
                    <div class="settings-categories">
                        <div class="settings-nav">
                            <button class="settings-nav-btn active" data-category="general">🔧 General</button>
                            <button class="settings-nav-btn" data-category="appearance">🎨 Appearance</button>
                            <button class="settings-nav-btn" data-category="voice">🎤 Voice & Audio</button>
                            <button class="settings-nav-btn" data-category="ai">🤖 AI Models</button>
                            <button class="settings-nav-btn" data-category="system">💻 System</button>
                            <button class="settings-nav-btn" data-category="about">ℹ️ About</button>
                        </div>
                        
                        <div class="settings-content">
                            <!-- General Settings -->
                            <div class="settings-panel active" id="general-panel">
                                <h3>General Settings</h3>
                                <p style="color: #666; font-style: italic; text-align: center; padding: 40px 20px;">
                                    No general settings available at this time.
                                </p>
                            </div>
                            
                            <!-- Appearance Settings -->
                            <div class="settings-panel" id="appearance-panel">
                                <h3>Appearance Settings</h3>
                                <div class="setting-item">
                                    <label for="theme">Theme</label>
                                    <select id="theme">
                                        <option value="light" selected>Light Mode</option>
                                        <option value="dark">Dark Mode</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Voice & Audio Settings -->
                            <div class="settings-panel" id="voice-panel">
                                <h3>Voice & Audio Settings</h3>
                                <div class="setting-item">
                                    <label for="voice-recognition-type">Voice recognition engine</label>
                                    <select id="voice-recognition-type">
                                        <option value="whisper" selected>OpenAI Whisper (Recommended)</option>
                                        <option value="web">Web Speech API (Browser)</option>
                                    </select>
                                </div>
                                <div class="setting-item">
                                    <label for="web-speech-language">Web Speech API language</label>
                                    <select id="web-speech-language">
                                        <option value="en-US" selected>English (United States)</option>
                                        <option value="en-GB">English (United Kingdom)</option>
                                        <option value="en-AU">English (Australia)</option>
                                        <option value="en-CA">English (Canada)</option>
                                        <option value="en-IN">English (India)</option>
                                        <option value="es-ES">Spanish (Spain)</option>
                                        <option value="es-MX">Spanish (Mexico)</option>
                                        <option value="es-AR">Spanish (Argentina)</option>
                                        <option value="fr-FR">French (France)</option>
                                        <option value="fr-CA">French (Canada)</option>
                                        <option value="de-DE">German (Germany)</option>
                                        <option value="it-IT">Italian (Italy)</option>
                                        <option value="pt-BR">Portuguese (Brazil)</option>
                                        <option value="pt-PT">Portuguese (Portugal)</option>
                                        <option value="ru-RU">Russian (Russia)</option>
                                        <option value="ja-JP">Japanese (Japan)</option>
                                        <option value="ko-KR">Korean (South Korea)</option>
                                        <option value="zh-CN">Chinese (Mandarin, Simplified)</option>
                                        <option value="zh-TW">Chinese (Traditional, Taiwan)</option>
                                        <option value="zh-HK">Chinese (Cantonese, Hong Kong)</option>
                                        <option value="ar-SA">Arabic (Saudi Arabia)</option>
                                        <option value="hi-IN">Hindi (India)</option>
                                        <option value="th-TH">Thai (Thailand)</option>
                                        <option value="vi-VN">Vietnamese (Vietnam)</option>
                                        <option value="nl-NL">Dutch (Netherlands)</option>
                                        <option value="sv-SE">Swedish (Sweden)</option>
                                        <option value="da-DK">Danish (Denmark)</option>
                                        <option value="no-NO">Norwegian (Norway)</option>
                                        <option value="fi-FI">Finnish (Finland)</option>
                                        <option value="pl-PL">Polish (Poland)</option>
                                        <option value="cs-CZ">Czech (Czech Republic)</option>
                                        <option value="hu-HU">Hungarian (Hungary)</option>
                                        <option value="tr-TR">Turkish (Turkey)</option>
                                        <option value="he-IL">Hebrew (Israel)</option>
                                        <option value="id-ID">Indonesian (Indonesia)</option>
                                        <option value="ms-MY">Malay (Malaysia)</option>
                                        <option value="uk-UA">Ukrainian (Ukraine)</option>
                                        <option value="bg-BG">Bulgarian (Bulgaria)</option>
                                        <option value="hr-HR">Croatian (Croatia)</option>
                                        <option value="sk-SK">Slovak (Slovakia)</option>
                                        <option value="sl-SI">Slovenian (Slovenia)</option>
                                        <option value="et-EE">Estonian (Estonia)</option>
                                        <option value="lv-LV">Latvian (Latvia)</option>
                                        <option value="lt-LT">Lithuanian (Lithuania)</option>
                                        <option value="ro-RO">Romanian (Romania)</option>
                                        <option value="el-GR">Greek (Greece)</option>
                                        <option value="ca-ES">Catalan (Spain)</option>
                                        <option value="eu-ES">Basque (Spain)</option>
                                        <option value="gl-ES">Galician (Spain)</option>
                                    </select>
                                </div>
                                <div class="setting-item">
                                    <button id="test-microphone" class="settings-btn">🎤 Test Microphone</button>
                                </div>
                                <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                                    <p style="font-size: 12px; color: #666; margin: 5px 0;">
                                        <strong>OpenAI Whisper:</strong> More accurate, supports multiple languages, requires API key<br>
                                        <strong>Web Speech API:</strong> Free, works offline, limited language support
                                    </p>
                                </div>
                            </div>
                            
                            <!-- AI Models Settings -->
                            <div class="settings-panel" id="ai-panel">
                                <h3>AI Model Settings</h3>
                                
                                <!-- Voice Recognition Section -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">🎤 Voice Recognition</h4>
                                    <div class="setting-item">
                                        <label for="openai-whisper-key">OpenAI Whisper API Key</label>
                                        <input type="password" id="openai-whisper-key" placeholder="sk-proj-...">
                                    </div>
                                    <div class="setting-item">
                                        <label for="openai-whisper-url">OpenAI Whisper API URL</label>
                                        <input type="url" id="openai-whisper-url" value="https://api.openai.com/v1/audio/transcriptions" placeholder="https://api.openai.com/v1/audio/transcriptions">
                                    </div>
                                </div>
                                
                                <!-- Code Generation Section -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">💻 Code Generation</h4>
                                    
                                    <!-- Provider Selection -->
                                    <div class="setting-item">
                                        <label for="llm-provider">LLM Provider</label>
                                        <select id="llm-provider">
                                            <option value="openrouter">OpenRouter</option>
                                            <option value="openai">OpenAI API</option>
                                            <option value="lmstudio">LMStudio</option>
                                        </select>
                                    </div>
                                    
                                    <!-- OpenRouter Configuration -->
                                    <div id="openrouter-config" class="provider-config">
                                        <div class="setting-item">
                                            <label for="openrouter-api-key">OpenRouter API Key</label>
                                            <input type="password" id="openrouter-api-key" placeholder="sk-or-v1-...">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-url">OpenRouter API URL</label>
                                            <input type="url" id="openrouter-url" value="https://openrouter.ai/api/v1/chat/completions" placeholder="https://openrouter.ai/api/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-simple-model">Simple Model Name</label>
                                            <input type="text" id="openrouter-simple-model" value="google/gemini-2.5-flash-lite-preview-06-17" placeholder="google/gemini-2.5-flash-lite-preview-06-17">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openrouter-tough-model">Tough Model Name</label>
                                            <input type="text" id="openrouter-tough-model" value="anthropic/claude-sonnet-4" placeholder="anthropic/claude-sonnet-4">
                                        </div>
                                    </div>
                                    
                                    <!-- OpenAI Configuration -->
                                    <div id="openai-config" class="provider-config" style="display: none;">
                                        <div class="setting-item">
                                            <label for="openai-api-key">OpenAI API Key</label>
                                            <input type="password" id="openai-api-key" placeholder="sk-...">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-url">OpenAI API URL</label>
                                            <input type="url" id="openai-url" value="https://api.openai.com/v1/chat/completions" placeholder="https://api.openai.com/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-simple-model">Simple Model Name</label>
                                            <input type="text" id="openai-simple-model" value="gpt-4o-mini" placeholder="gpt-4o-mini">
                                        </div>
                                        <div class="setting-item">
                                            <label for="openai-tough-model">Tough Model Name</label>
                                            <input type="text" id="openai-tough-model" value="gpt-4o" placeholder="gpt-4o">
                                        </div>
                                    </div>
                                    
                                    <!-- LMStudio Configuration -->
                                    <div id="lmstudio-config" class="provider-config" style="display: none;">
                                        <div class="setting-item">
                                            <label for="lmstudio-url">LMStudio API URL</label>
                                            <input type="url" id="lmstudio-url" value="http://localhost:1234/v1/chat/completions" placeholder="http://localhost:1234/v1/chat/completions">
                                        </div>
                                        <div class="setting-item">
                                            <label for="lmstudio-simple-model">Simple Model Name</label>
                                            <input type="text" id="lmstudio-simple-model" value="llama-3.2-3b-instruct" placeholder="llama-3.2-3b-instruct">
                                        </div>
                                        <div class="setting-item">
                                            <label for="lmstudio-tough-model">Tough Model Name</label>
                                            <input type="text" id="lmstudio-tough-model" value="llama-3.1-8b-instruct" placeholder="llama-3.1-8b-instruct">
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- General Settings -->
                                <div class="setting-section">
                                    <h4 style="color: #0078d4; margin: 20px 0 10px 0; font-size: 16px; font-weight: 600;">⚙️ General</h4>
                                    <div class="setting-item">
                                        <label for="api-timeout">API Timeout (seconds)</label>
                                        <input type="number" id="api-timeout" value="30" min="10" max="120">
                                    </div>
                                    <div class="setting-item">
                                        <label for="max-retries">Max Retries</label>
                                        <input type="number" id="max-retries" value="3" min="1" max="10">
                                    </div>
                                    <div class="setting-item">
                                        <label for="cost-tracking">Enable cost tracking</label>
                                        <input type="checkbox" id="cost-tracking" checked>
                                    </div>
                                    <div class="setting-item">
                                        <button id="reset-cost" class="settings-btn">💰 Reset Cost Counter</button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- System Settings -->
                            <div class="settings-panel" id="system-panel">
                                <h3>System Settings</h3>
                                <div class="setting-item">
                                    <label for="debug-mode">Debug mode</label>
                                    <input type="checkbox" id="debug-mode">
                                </div>
                                <div class="setting-item">
                                    <button id="clear-cache" class="settings-btn">🗑️ Clear Cache</button>
                                </div>
                                <div class="setting-item">
                                    <button id="export-settings" class="settings-btn">📤 Export Settings</button>
                                </div>
                                <div class="setting-item">
                                    <button id="import-settings" class="settings-btn">📥 Import Settings</button>
                                    <input type="file" id="settings-file-input" accept=".json" style="display: none;">
                                </div>
                                <div class="setting-item">
                                    <button id="reset-settings" class="settings-btn">🔄 Reset All Settings</button>
                                </div>
                            </div>
                            
                            <!-- About Settings -->
                            <div class="settings-panel" id="about-panel">
                                <h3>About Self-Evolving OS</h3>
                                <div class="about-info">
                                    <p><strong>Version:</strong> 2.0.0</p>
                                    <p><strong>Build:</strong> 2025.01.20</p>
                                    <p><strong>Platform:</strong> Web-based OS</p>
                                    <p><strong>AI Models:</strong> OpenAI GPT & Claude</p>
                                    <p><strong>Features:</strong> Voice commands, AI app generation, Dynamic UI</p>
                                    <br>
                                    <p><strong>Total Apps Created:</strong> <span id="total-apps-created">0</span></p>
                                    <p><strong>Current Session Apps:</strong> <span id="current-session-apps">0</span></p>
                                    <p><strong>Total API Cost:</strong> $<span id="total-api-cost">0.00</span></p>
                                    <br>
                                    <p style="font-size: 12px; color: #666;">
                                        Self-Evolving OS is an experimental AI-powered operating system interface
                                        that can create and modify applications on demand using natural language commands.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                </div>
            `;
            
            // Create Settings app directly
            const settingsId = generateAppId();
            const settingsApp = {
                id: settingsId,
                type: 'system',
                title: 'Settings',
                isMinimized: false,
                isMaximized: false,
                customRequest: 'System Settings'
            };

            apps.push(settingsApp);
            createWindow(settingsId, 'Settings', settingsContent, 700, 500);
            createTaskbarIcon(settingsId, 'Settings');
            updateAppCount();
            
            // Add settings-specific CSS
            addSettingsCSS(settingsId);
            
            // Add event listeners for settings functionality
            setTimeout(() => {
                initializeSettingsEventListeners(settingsId);
            }, 100);
            
            document.getElementById('start-menu').classList.remove('show');
        }

        function addSettingsCSS(appId) {
            const settingsCSS = `
                .settings-container {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                }
                
                .settings-categories {
                    display: flex;
                    flex: 1;
                    gap: 0;
                }
                
                .settings-nav {
                    width: 200px;
                    background: #f8f9fa;
                    border-right: 1px solid #dee2e6;
                    padding: 10px 0;
                    display: flex;
                    flex-direction: column;
                }
                
                .settings-nav-btn {
                    background: none;
                    border: none;
                    padding: 12px 20px;
                    text-align: left;
                    cursor: pointer;
                    font-size: 14px;
                    color: #495057;
                    transition: all 0.2s ease;
                    border-left: 3px solid transparent;
                }
                
                .settings-nav-btn:hover {
                    background: #e9ecef;
                    color: #0078d4;
                }
                
                .settings-nav-btn.active {
                    background: #e3f2fd;
                    color: #0078d4;
                    border-left-color: #0078d4;
                    font-weight: 600;
                }
                
                .settings-content {
                    flex: 1;
                    padding: 20px;
                    overflow-y: auto;
                }
                
                .settings-panel {
                    display: none;
                }
                
                .settings-panel.active {
                    display: block;
                }
                
                .settings-panel h3 {
                    margin: 0 0 20px 0;
                    color: #333;
                    font-size: 18px;
                    font-weight: 600;
                }
                
                .setting-item {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    padding: 12px 0;
                    border-bottom: 1px solid #f0f0f0;
                }
                
                .setting-item:last-child {
                    border-bottom: none;
                }
                
                .setting-item label {
                    font-weight: 500;
                    color: #333;
                    flex: 1;
                }
                
                .setting-item input, .setting-item select {
                    padding: 6px 10px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 14px;
                }
                
                .setting-item input[type="checkbox"] {
                    width: 18px;
                    height: 18px;
                }
                
                .setting-item input[type="range"] {
                    width: 120px;
                    margin-right: 10px;
                }
                
                .settings-btn {
                    background: #6c757d;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                    transition: background 0.2s ease;
                }
                
                .settings-btn:hover {
                    background: #5a6268;
                }
                
                .settings-btn.primary {
                    background: #0078d4;
                }
                
                .settings-btn.primary:hover {
                    background: #106ebe;
                }
                
                .settings-footer {
                    padding: 15px 20px;
                    border-top: 1px solid #dee2e6;
                    background: #f8f9fa;
                    display: flex;
                    gap: 10px;
                    justify-content: flex-end;
                }
                
                .about-info {
                    line-height: 1.6;
                }
                
                .about-info p {
                    margin: 5px 0;
                }
            `;
            
            addAppCSS(settingsCSS, appId);
        }

        function initializeSettingsEventListeners(settingsId) {
            // Navigation between settings categories
            const navButtons = document.querySelectorAll('.settings-nav-btn');
            const panels = document.querySelectorAll('.settings-panel');
            
            navButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const category = btn.dataset.category;
                    
                    // Update active nav button
                    navButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Update active panel
                    panels.forEach(p => p.classList.remove('active'));
                    document.getElementById(category + '-panel').classList.add('active');
                });
            });
            
            // Transparency slider
            const transparencySlider = document.getElementById('transparency');
            const transparencyValue = document.getElementById('transparency-value');
            if (transparencySlider && transparencyValue) {
                transparencySlider.addEventListener('input', (e) => {
                    const value = Math.round(e.target.value * 100);
                    transparencyValue.textContent = value + '%';
                });
            }
            
            // Microphone sensitivity slider
            const sensitivitySlider = document.getElementById('microphone-sensitivity');
            const sensitivityValue = document.getElementById('sensitivity-value');
            if (sensitivitySlider && sensitivityValue) {
                sensitivitySlider.addEventListener('input', (e) => {
                    const value = Math.round(e.target.value * 100);
                    sensitivityValue.textContent = value + '%';
                });
            }
            
            // Test microphone button
            const testMicBtn = document.getElementById('test-microphone');
            if (testMicBtn) {
                testMicBtn.addEventListener('click', () => {
                    testMicrophone();
                });
            }
            
            // Reset cost button
            const resetCostBtn = document.getElementById('reset-cost');
            if (resetCostBtn) {
                resetCostBtn.addEventListener('click', () => {
                    if (confirm('Reset the API cost counter to $0.00?')) {
                        totalCost = 0;
                        document.getElementById('api-cost').textContent = '0.00';
                        alert('Cost counter reset successfully!');
                    }
                });
            }
            
            // Clear cache button
            const clearCacheBtn = document.getElementById('clear-cache');
            if (clearCacheBtn) {
                clearCacheBtn.addEventListener('click', () => {
                    if (confirm('Clear all cached data? This will not affect your current apps.')) {
                        // Could implement cache clearing here
                        alert('Cache cleared successfully!');
                    }
                });
            }
            
            // Export settings button
            const exportBtn = document.getElementById('export-settings');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    const settings = {
                        version: '2.0.0',
                        exportDate: new Date().toISOString(),
                        settings: {
                            autoSave: document.getElementById('auto-save')?.checked,
                            startupApps: document.getElementById('startup-apps')?.checked,
                            maxApps: document.getElementById('max-apps')?.value,
                            theme: document.getElementById('theme')?.value,
                            transparency: document.getElementById('transparency')?.value,
                            animations: document.getElementById('animations')?.checked,
                            voiceEnabled: document.getElementById('voice-enabled')?.checked,
                            pushToTalk: document.getElementById('push-to-talk')?.checked,
                            debugMode: document.getElementById('debug-mode')?.checked,
                            performanceMode: document.getElementById('performance-mode')?.checked
                        }
                    };
                    
                    const dataStr = JSON.stringify(settings, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = 'self_evolving_os_settings.json';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                });
            }
            
            // Import settings button
            const importBtn = document.getElementById('import-settings');
            const fileInput = document.getElementById('settings-file-input');
            if (importBtn && fileInput) {
                importBtn.addEventListener('click', () => {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const settings = JSON.parse(e.target.result);
                                if (settings.settings) {
                                    // Apply imported settings
                                    Object.keys(settings.settings).forEach(key => {
                                        const element = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());
                                        if (element) {
                                            if (element.type === 'checkbox') {
                                                element.checked = settings.settings[key];
                                            } else {
                                                element.value = settings.settings[key];
                                            }
                                        }
                                    });
                                    alert('Settings imported successfully!');
                                }
                            } catch (error) {
                                alert('Failed to import settings: Invalid file format');
                            }
                        };
                        reader.readAsText(file);
                    }
                });
            }
            
            // Reset settings button
            const resetBtn = document.getElementById('reset-settings');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (confirm('Reset all settings and restart the setup assistant? This will delete all your current configuration and close all apps.')) {
                        // Delete the settings cookie
                        document.cookie = 'selfEvolvingOS_settings=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
                        
                        // Clear any localStorage data
                        localStorage.removeItem('costHistory');
                        
                        // Reset global variables to defaults
                        voiceRecognitionType = 'whisper';
                        CONFIG.OPENAI_API_KEY = 'sk-proj-...';
                        CONFIG.OPENROUTER_API_KEY = 'sk-...';
                        CONFIG.CURRENT_LLM_PROVIDER = 'openrouter';
                        totalCost = 0;
                        costHistory = [];
                        window.costHistory = costHistory;
                        
                        // Update cost display
                        const costElement = document.getElementById('api-cost');
                        if (costElement) {
                            costElement.textContent = '0.00';
                        }
                        
                        // Close all apps
                        [...apps].forEach(app => closeWindow(app.id));
                        
                        // Show confirmation and reload
                        alert('Settings reset successfully! The page will reload and the setup assistant will start.');
                        
                        // Reload the page to restart with fresh state
                        window.location.reload();
                    }
                });
            }
            
            // Voice recognition type change handler
            const voiceTypeSelect = document.getElementById('voice-recognition-type');
            if (voiceTypeSelect) {
                voiceTypeSelect.addEventListener('change', async (e) => {
                    const newType = e.target.value;
                    console.log(`Switching voice recognition from ${voiceRecognitionType} to ${newType}`);
                    
                    // Stop current voice session if active
                    if (isListening) {
                        stopVoiceSession();
                    }
                    
                    // Update the global setting
                    voiceRecognitionType = newType;
                    
                    // Re-initialize voice system with new type
                    try {
                        await initializeVoice();
                        console.log(`Voice system re-initialized with ${newType}`);
                        
                        // Show confirmation
                        const statusMsg = newType === 'web' ?
                            'Switched to Web Speech API (Browser-based)' :
                            'Switched to OpenAI Whisper (Cloud-based)';
                        
                        // Temporarily show status
                        updateVoiceStatus(statusMsg, 'ready');
                        setTimeout(() => {
                            updateVoiceStatus(`Voice Ready (${newType === 'web' ? 'Web' : 'Whisper'})`, 'ready');
                        }, 3000);
                        
                    } catch (error) {
                        console.error('Failed to re-initialize voice system:', error);
                        updateVoiceStatus('Voice Error', 'error');
                        
                        // Revert the selection if initialization failed
                        voiceTypeSelect.value = voiceRecognitionType === 'web' ? 'whisper' : 'web';
                        voiceRecognitionType = voiceTypeSelect.value;
                    }
                });
            }
            
            // Web Speech API language change handler
            const webSpeechLanguageSelect = document.getElementById('web-speech-language');
            if (webSpeechLanguageSelect) {
                webSpeechLanguageSelect.addEventListener('change', async (e) => {
                    const newLanguage = e.target.value;
                    console.log(`Changing Web Speech API language to: ${newLanguage}`);
                    
                    // If currently using Web Speech API, re-initialize with new language
                    if (voiceRecognitionType === 'web') {
                        // Stop current voice session if active
                        if (isListening) {
                            stopVoiceSession();
                        }
                        
                        try {
                            await initializeVoice();
                            console.log(`Web Speech API re-initialized with language: ${newLanguage}`);
                            
                            // Show confirmation
                            const languageText = e.target.options[e.target.selectedIndex].text;
                            updateVoiceStatus(`Language changed to ${languageText}`, 'ready');
                            setTimeout(() => {
                                updateVoiceStatus('Voice Ready (Web)', 'ready');
                            }, 3000);
                            
                        } catch (error) {
                            console.error('Failed to re-initialize Web Speech API with new language:', error);
                            updateVoiceStatus('Language Change Error', 'error');
                            setTimeout(() => {
                                updateVoiceStatus('Voice Ready (Web)', 'ready');
                            }, 2000);
                        }
                    }
                });
            }
            
            // Update about info
            const totalAppsElement = document.getElementById('total-apps-created');
            const currentAppsElement = document.getElementById('current-session-apps');
            const totalCostElement = document.getElementById('total-api-cost');
            
            if (totalAppsElement) totalAppsElement.textContent = nextAppId - 1;
            if (currentAppsElement) currentAppsElement.textContent = apps.length;
            if (totalCostElement) totalCostElement.textContent = totalCost.toFixed(4);
            
            // Auto-save settings when any input changes
            const settingsInputs = document.querySelectorAll('.settings-panel input, .settings-panel select');
            settingsInputs.forEach(input => {
                input.addEventListener('change', () => {
                    const settings = saveSettingsToCookie();
                    applySettingsToSystem(settings);
                    console.log('Settings auto-saved and applied');
                });
            });
            
            // Theme change handler for immediate application
            const themeSelect = document.getElementById('theme');
            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    const newTheme = e.target.value;
                    applyTheme(newTheme);
                    console.log(`Theme changed to: ${newTheme}`);
                });
            }
            
            // API Settings change handlers for immediate application
            const apiSettingsInputs = [
                'openai-whisper-key',
                'openai-whisper-url',
                'openrouter-api-key',
                'openrouter-url',
                'openrouter-simple-model',
                'openrouter-tough-model',
                'openai-api-key',
                'openai-url',
                'openai-simple-model',
                'openai-tough-model',
                'lmstudio-url',
                'lmstudio-simple-model',
                'lmstudio-tough-model'
            ];
            
            apiSettingsInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', () => {
                        const settings = saveSettingsToCookie();
                        applySettingsToSystem(settings);
                        console.log(`API setting ${inputId} updated and applied`);
                    });
                }
            });
            
            // Load and apply saved settings
            const savedSettings = loadSettingsFromCookie();
            if (savedSettings) {
                applySettingsToUI(savedSettings);
                applySettingsToSystem(savedSettings);
            }
    
            // LLM Provider switching functionality
            function initializeLLMProviderSwitching() {
                const providerSelect = document.getElementById('llm-provider');
                if (!providerSelect) return;
                
                // Show/hide provider configurations based on selection
                function showProviderConfig(provider) {
                    // Hide all provider configs
                    document.querySelectorAll('.provider-config').forEach(config => {
                        config.style.display = 'none';
                    });
                    
                    // Show selected provider config
                    const selectedConfig = document.getElementById(`${provider}-config`);
                    if (selectedConfig) {
                        selectedConfig.style.display = 'block';
                    }
                    
                    // Update current provider display in header
                    updateCurrentProviderDisplay(provider);
                }
                
                // Handle provider selection change
                providerSelect.addEventListener('change', (e) => {
                    const selectedProvider = e.target.value;
                    showProviderConfig(selectedProvider);
                    
                    // Save settings when provider changes
                    const settings = saveSettingsToCookie();
                    
                    // Apply settings immediately to CONFIG object
                    applySettingsToSystem(settings);
                    
                    debugLog(`LLM Provider changed to: ${selectedProvider}`);
                });
                
                // Initialize with current selection
                showProviderConfig(providerSelect.value);
            }
    
            // Update the current provider display in the header
            function updateCurrentProviderDisplay(provider) {
                const providerDisplay = document.getElementById('current-provider-display');
                if (providerDisplay) {
                    const providerNames = {
                        'openrouter': 'OpenRouter',
                        'openai': 'OpenAI',
                        'lmstudio': 'LMStudio'
                    };
                    providerDisplay.textContent = providerNames[provider] || provider;
                }
            }
            
            // Initialize cost tracking
            loadCostHistory();
            updateCostTrackingAppVisibility();
            
            // Initialize LLM provider switching
            initializeLLMProviderSwitching();
            
            // Load and display current LLM provider from settings
            const providerSettings = loadSettingsFromCookie();
            if (providerSettings && providerSettings.llmProvider) {
                updateCurrentProviderDisplay(providerSettings.llmProvider);
            } else {
                updateCurrentProviderDisplay('openrouter'); // Default
            }
            
        }

        // Initialize the system when page loads
        window.addEventListener('load', init);

        // Handle Enter key in app request input
        document.addEventListener('keypress', function(e) {
            if (e.target.id === 'app-request' && e.key === 'Enter') {
                requestApp();
            }
        });

        // Initialize voice recognition on page load
        // Voice system will be initialized by DOMContentLoaded event handler above
    </script>
</body>
</html>